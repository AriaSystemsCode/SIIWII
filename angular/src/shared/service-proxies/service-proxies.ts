//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendUserResetPasswordCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordOutput>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/DelegatedImpersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchToLinkedAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchToLinkedAccountOutput>;
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AccountInfoAppService_oldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAccountInfoForEdit(): Observable<GetAccountInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AccountInfoAppService_old/GetAccountInfoForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountInfoForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountInfoForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountInfoForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountInfoForEditOutput>;
        }));
    }

    protected processGetAccountInfoForEdit(response: HttpResponseBase): Observable<GetAccountInfoForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountInfoForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAccountInfoDto | undefined): Observable<GetAccountInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AccountInfoAppService_old/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountInfoForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountInfoForEditOutput>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<GetAccountInfoForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountInfoForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    publishProfile(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountInfoAppService_old/PublishProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPublishProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAppEntityForTableDropdown(): Observable<AccountInfoAppEntityLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountInfoAppService_old/GetAllAppEntityForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppEntityForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppEntityForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountInfoAppEntityLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountInfoAppEntityLookupTableDto[]>;
        }));
    }

    protected processGetAllAppEntityForTableDropdown(response: HttpResponseBase): Observable<AccountInfoAppEntityLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountInfoAppEntityLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCurrTenantEntityId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AccountInfoAppService_old/GetCurrTenantEntityId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrTenantEntityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrTenantEntityId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCurrTenantEntityId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AccountsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param filterType (optional) 
     * @param name (optional) 
     * @param address (optional) 
     * @param city (optional) 
     * @param state (optional) 
     * @param postal (optional) 
     * @param sSIN (optional) 
     * @param accountTypeId (optional) 
     * @param accountType (optional) 
     * @param accountTypes (optional) 
     * @param status (optional) 
     * @param languages (optional) 
     * @param countries (optional) 
     * @param classifications (optional) 
     * @param categories (optional) 
     * @param curruncies (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, filterType: number | undefined, name: string | null | undefined, address: string | null | undefined, city: string | null | undefined, state: string | null | undefined, postal: string | null | undefined, sSIN: string | null | undefined, accountTypeId: number | undefined, accountType: string | null | undefined, accountTypes: number[] | null | undefined, status: number[] | null | undefined, languages: number[] | null | undefined, countries: number[] | null | undefined, classifications: number[] | null | undefined, categories: number[] | null | undefined, curruncies: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (filterType === null)
            throw new Error("The parameter 'filterType' cannot be null.");
        else if (filterType !== undefined)
            url_ += "FilterType=" + encodeURIComponent("" + filterType) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (address !== undefined && address !== null)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (city !== undefined && city !== null)
            url_ += "City=" + encodeURIComponent("" + city) + "&";
        if (state !== undefined && state !== null)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (postal !== undefined && postal !== null)
            url_ += "Postal=" + encodeURIComponent("" + postal) + "&";
        if (sSIN !== undefined && sSIN !== null)
            url_ += "SSIN=" + encodeURIComponent("" + sSIN) + "&";
        if (accountTypeId === null)
            throw new Error("The parameter 'accountTypeId' cannot be null.");
        else if (accountTypeId !== undefined)
            url_ += "AccountTypeId=" + encodeURIComponent("" + accountTypeId) + "&";
        if (accountType !== undefined && accountType !== null)
            url_ += "AccountType=" + encodeURIComponent("" + accountType) + "&";
        if (accountTypes !== undefined && accountTypes !== null)
            accountTypes && accountTypes.forEach(item => { url_ += "AccountTypes=" + encodeURIComponent("" + item) + "&"; });
        if (status !== undefined && status !== null)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (languages !== undefined && languages !== null)
            languages && languages.forEach(item => { url_ += "Languages=" + encodeURIComponent("" + item) + "&"; });
        if (countries !== undefined && countries !== null)
            countries && countries.forEach(item => { url_ += "Countries=" + encodeURIComponent("" + item) + "&"; });
        if (classifications !== undefined && classifications !== null)
            classifications && classifications.forEach(item => { url_ += "Classifications=" + encodeURIComponent("" + item) + "&"; });
        if (categories !== undefined && categories !== null)
            categories && categories.forEach(item => { url_ += "Categories=" + encodeURIComponent("" + item) + "&"; });
        if (curruncies !== undefined && curruncies !== null)
            curruncies && curruncies.forEach(item => { url_ += "Curruncies=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAccountForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAccountForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAccountForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param ids (optional) 
     * @param tmpAccountType (optional) 
     * @return Success
     */
    getLookUPLabels(ids: string | null | undefined, tmpAccountType: LookupLabelDto[] | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetLookUPLabels?";
        if (ids !== undefined && ids !== null)
            url_ += "Ids=" + encodeURIComponent("" + ids) + "&";
        if (tmpAccountType !== undefined && tmpAccountType !== null)
            tmpAccountType && tmpAccountType.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "tmpAccountType[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookUPLabels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookUPLabels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetLookUPLabels(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPaymentMethods(): Observable<AppContactPaymentMethodDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllPaymentMethods";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppContactPaymentMethodDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppContactPaymentMethodDto[]>;
        }));
    }

    protected processGetAllPaymentMethods(response: HttpResponseBase): Observable<AppContactPaymentMethodDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppContactPaymentMethodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getAllBranches(parentId: number | undefined): Observable<TreeNodeOfBranchForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllBranches?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBranches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBranches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfBranchForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfBranchForViewDto[]>;
        }));
    }

    protected processGetAllBranches(response: HttpResponseBase): Observable<TreeNodeOfBranchForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfBranchForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param accountId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMembers(filter: string | null | undefined, accountId: number | null | undefined, filterType: MemberFilterTypeEnum, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMemberForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllMembers?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountId !== undefined && accountId !== null)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (filterType === undefined || filterType === null)
            throw new Error("The parameter 'filterType' must be defined and cannot be null.");
        else
            url_ += "FilterType=" + encodeURIComponent("" + filterType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMemberForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMemberForViewDto>;
        }));
    }

    protected processGetAllMembers(response: HttpResponseBase): Observable<PagedResultDtoOfGetMemberForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMemberForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param ids (optional) 
     * @param tmpAccountType (optional) 
     * @return Success
     */
    getLookUPIds(ids: string | null | undefined, tmpAccountType: LookupLabelDto[] | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetLookUPIds?";
        if (ids !== undefined && ids !== null)
            url_ += "Ids=" + encodeURIComponent("" + ids) + "&";
        if (tmpAccountType !== undefined && tmpAccountType !== null)
            tmpAccountType && tmpAccountType.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "tmpAccountType[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookUPIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookUPIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetLookUPIds(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param resultCount (optional) 
     * @return Success
     */
    getAccountForView(id: number | undefined, resultCount: number | undefined): Observable<GetAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (resultCount === null)
            throw new Error("The parameter 'resultCount' cannot be null.");
        else if (resultCount !== undefined)
            url_ += "resultCount=" + encodeURIComponent("" + resultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountForViewDto>;
        }));
    }

    protected processGetAccountForView(response: HttpResponseBase): Observable<GetAccountForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getMyAccountForEdit(): Observable<GetAccountInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetMyAccountForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyAccountForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyAccountForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountInfoForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountInfoForEditOutput>;
        }));
    }

    protected processGetMyAccountForEdit(response: HttpResponseBase): Observable<GetAccountInfoForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountInfoForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAccountForEdit(id: number | undefined): Observable<GetAccountInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountInfoForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountInfoForEditOutput>;
        }));
    }

    protected processGetAccountForEdit(response: HttpResponseBase): Observable<GetAccountInfoForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountInfoForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    connect(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/Connect?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConnect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConnect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConnect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    disconnect(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/Disconnect?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisconnect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisconnect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisconnect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditMyAccount(body: CreateOrEditAccountInfoDto | undefined): Observable<GetAccountInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrEditMyAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditMyAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditMyAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountInfoForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountInfoForEditOutput>;
        }));
    }

    protected processCreateOrEditMyAccount(response: HttpResponseBase): Observable<GetAccountInfoForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountInfoForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param priceLevel (optional) 
     * @return Success
     */
    updateConnectedAccountPriceLevel(id: number | undefined, priceLevel: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/UpdateConnectedAccountPriceLevel?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (priceLevel !== undefined && priceLevel !== null)
            url_ += "priceLevel=" + encodeURIComponent("" + priceLevel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConnectedAccountPriceLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConnectedAccountPriceLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateConnectedAccountPriceLevel(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAccount(body: CreateOrEditAccountInfoDto | undefined): Observable<GetAccountInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrEditAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountInfoForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountInfoForEditOutput>;
        }));
    }

    protected processCreateOrEditAccount(response: HttpResponseBase): Observable<GetAccountInfoForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountInfoForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    unPublishProfile(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/UnPublishProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnPublishProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnPublishProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnPublishProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    publishProfile(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/PublishProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPublishProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAppEntityForTableDropdown(): Observable<AccountAppEntityLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllAppEntityForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppEntityForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppEntityForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountAppEntityLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountAppEntityLookupTableDto[]>;
        }));
    }

    protected processGetAllAppEntityForTableDropdown(response: HttpResponseBase): Observable<AccountAppEntityLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountAppEntityLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMessage(body: SendMailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/SendMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAccountSummary(): Observable<AccountSummaryDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountSummary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountSummaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountSummaryDto>;
        }));
    }

    protected processGetAccountSummary(response: HttpResponseBase): Observable<AccountSummaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountSummaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getAllAccountsForDropdown(searchTerm: string | null | undefined): Observable<GetAccountForDropdownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllAccountsForDropdown?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountsForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountsForDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountForDropdownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountForDropdownDto[]>;
        }));
    }

    protected processGetAllAccountsForDropdown(response: HttpResponseBase): Observable<GetAccountForDropdownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAccountForDropdownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditPaymentMethod(body: AppContactPaymentMethodDto | undefined): Observable<AppContactPaymentMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrEditPaymentMethod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditPaymentMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditPaymentMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppContactPaymentMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppContactPaymentMethodDto>;
        }));
    }

    protected processCreateOrEditPaymentMethod(response: HttpResponseBase): Observable<AppContactPaymentMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppContactPaymentMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePaymentMethod(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/DeletePaymentMethod?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePaymentMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePaymentMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePaymentMethod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getPaymentMethodForEdit(input: number | undefined): Observable<AppContactPaymentMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetPaymentMethodForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentMethodForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentMethodForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppContactPaymentMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppContactPaymentMethodDto>;
        }));
    }

    protected processGetPaymentMethodForEdit(response: HttpResponseBase): Observable<AppContactPaymentMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppContactPaymentMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPaymentMethodDefault(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/SetPaymentMethodDefault";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPaymentMethodDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPaymentMethodDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPaymentMethodDefault(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getContactForEdit(input: number | undefined): Observable<ContactDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetContactForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDto>;
        }));
    }

    protected processGetContactForEdit(response: HttpResponseBase): Observable<ContactDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getContactForView(input: number | undefined): Observable<ContactForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetContactForView?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactForEditDto>;
        }));
    }

    protected processGetContactForView(response: HttpResponseBase): Observable<ContactForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteContact(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/DeleteContact?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditContact(body: ContactDto | undefined): Observable<ContactDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrEditContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDto>;
        }));
    }

    protected processCreateOrEditContact(response: HttpResponseBase): Observable<ContactDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBranchForEdit(input: number | undefined): Observable<BranchDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetBranchForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchDto>;
        }));
    }

    protected processGetBranchForEdit(response: HttpResponseBase): Observable<BranchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBranch(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/DeleteBranch?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBranch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBranch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAddress(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/DeleteAddress?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param addressId (optional) 
     * @param currBranchId (optional) 
     * @return Success
     */
    isAddressUsedByOtherBranch(addressId: number | undefined, currBranchId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/IsAddressUsedByOtherBranch?";
        if (addressId === null)
            throw new Error("The parameter 'addressId' cannot be null.");
        else if (addressId !== undefined)
            url_ += "addressId=" + encodeURIComponent("" + addressId) + "&";
        if (currBranchId === null)
            throw new Error("The parameter 'currBranchId' cannot be null.");
        else if (currBranchId !== undefined)
            url_ += "currBranchId=" + encodeURIComponent("" + currBranchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsAddressUsedByOtherBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAddressUsedByOtherBranch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processIsAddressUsedByOtherBranch(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditBranch(body: BranchDto | undefined): Observable<BranchDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrEditBranch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditBranch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchDto>;
        }));
    }

    protected processCreateOrEditBranch(response: HttpResponseBase): Observable<BranchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getBranchChilds(parentId: number | undefined): Observable<TreeNodeOfBranchForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetBranchChilds?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchChilds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchChilds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfBranchForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfBranchForViewDto[]>;
        }));
    }

    protected processGetBranchChilds(response: HttpResponseBase): Observable<TreeNodeOfBranchForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfBranchForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAddresses(): Observable<AppAddressDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAddresses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppAddressDto[]>;
        }));
    }

    protected processGetAddresses(response: HttpResponseBase): Observable<AppAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAddresses(): Observable<AppAddressDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllAddresses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppAddressDto[]>;
        }));
    }

    protected processGetAllAddresses(response: HttpResponseBase): Observable<AppAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountId (optional) 
     * @return Success
     */
    getAllAccountAddresses(accountId: number | undefined): Observable<AppAddressDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllAccountAddresses?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppAddressDto[]>;
        }));
    }

    protected processGetAllAccountAddresses(response: HttpResponseBase): Observable<AppAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAddress(body: AppAddressDto | undefined): Observable<AppAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrEditAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppAddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppAddressDto>;
        }));
    }

    protected processCreateOrEditAddress(response: HttpResponseBase): Observable<AppAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAddressForEdit(input: number | undefined): Observable<AppAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAddressForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppAddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppAddressDto>;
        }));
    }

    protected processGetAddressForEdit(response: HttpResponseBase): Observable<AppAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param typeName (optional) 
     * @param lookupLabelDtos (optional) 
     * @return Success
     */
    getTypeId(typeName: string | null | undefined, lookupLabelDtos: LookupLabelDto[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetTypeId?";
        if (typeName !== undefined && typeName !== null)
            url_ += "typeName=" + encodeURIComponent("" + typeName) + "&";
        if (lookupLabelDtos !== undefined && lookupLabelDtos !== null)
            lookupLabelDtos && lookupLabelDtos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "lookupLabelDtos[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param className (optional) 
     * @param totalCount (optional) 
     * @param items (optional) 
     * @return Success
     */
    getClassId(className: string | null | undefined, totalCount: number | undefined, items: TreeNodeOfGetSycEntityObjectClassificationForViewDto[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetClassId?";
        if (className !== undefined && className !== null)
            url_ += "className=" + encodeURIComponent("" + className) + "&";
        if (totalCount === null)
            throw new Error("The parameter 'totalCount' cannot be null.");
        else if (totalCount !== undefined)
            url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
        if (items !== undefined && items !== null)
            items && items.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetClassId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param className (optional) 
     * @param totalCount (optional) 
     * @param items (optional) 
     * @return Success
     */
    getDepartmentId(className: string | null | undefined, totalCount: number | undefined, items: TreeNodeOfGetSycEntityObjectCategoryForViewDto[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetDepartmentId?";
        if (className !== undefined && className !== null)
            url_ += "className=" + encodeURIComponent("" + className) + "&";
        if (totalCount === null)
            throw new Error("The parameter 'totalCount' cannot be null.");
        else if (totalCount !== undefined)
            url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
        if (items !== undefined && items !== null)
            items && items.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetDepartmentId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param guidFile (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateExcel(guidFile: string | null | undefined, body: string[] | null | undefined): Observable<AccountExcelResultsDTO> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/ValidateExcel?";
        if (guidFile !== undefined && guidFile !== null)
            url_ += "guidFile=" + encodeURIComponent("" + guidFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountExcelResultsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountExcelResultsDTO>;
        }));
    }

    protected processValidateExcel(response: HttpResponseBase): Observable<AccountExcelResultsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountExcelResultsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getAccountCopyCode(code: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountCopyCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountCopyCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountCopyCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAccountCopyCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAddresses(body: AccountExcelDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/AddAddresses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddAddresses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addAddress(accountId: number | undefined, body: AppContactAddressDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/AddAddress?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addClassifications(body: AccountExcelDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/AddClassifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClassifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClassifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddClassifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCategories(body: AccountExcelDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/AddCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTitles(body: AccountExcelDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/AddTitles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTitles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTitles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddTitles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveFromExcel(body: AccountExcelResultsDTO | undefined): Observable<ExcelLogDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/SaveFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExcelLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExcelLogDto>;
        }));
    }

    protected processSaveFromExcel(response: HttpResponseBase): Observable<ExcelLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExcelLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param typeId (optional) 
     * @return Success
     */
    getExcelTemplate(typeId: number | null | undefined): Observable<ExcelTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetExcelTemplate?";
        if (typeId !== undefined && typeId !== null)
            url_ += "TypeId=" + encodeURIComponent("" + typeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExcelTemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExcelTemplateDto>;
        }));
    }

    protected processGetExcelTemplate(response: HttpResponseBase): Observable<ExcelTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExcelTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantSearchable (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getTenantsWithManualAccounts(tenantSearchable: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupAccountOrTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetTenantsWithManualAccounts?";
        if (tenantSearchable !== undefined && tenantSearchable !== null)
            url_ += "TenantSearchable=" + encodeURIComponent("" + tenantSearchable) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantsWithManualAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantsWithManualAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupAccountOrTenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupAccountOrTenantDto>;
        }));
    }

    protected processGetTenantsWithManualAccounts(response: HttpResponseBase): Observable<PagedResultDtoOfLookupAccountOrTenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupAccountOrTenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param accountSearchable (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAccountByType(accountType: SourceAccountEnum, tenantId: number | undefined, accountSearchable: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupAccountOrTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountByType?";
        if (accountType === undefined || accountType === null)
            throw new Error("The parameter 'accountType' must be defined and cannot be null.");
        else
            url_ += "AccountType=" + encodeURIComponent("" + accountType) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (accountSearchable !== undefined && accountSearchable !== null)
            url_ += "AccountSearchable=" + encodeURIComponent("" + accountSearchable) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupAccountOrTenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupAccountOrTenantDto>;
        }));
    }

    protected processGetAccountByType(response: HttpResponseBase): Observable<PagedResultDtoOfLookupAccountOrTenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupAccountOrTenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateAccountFromSourceAccount(body: CreateAccountsInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrUpdateAccountFromSourceAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateAccountFromSourceAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateAccountFromSourceAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrUpdateAccountFromSourceAccount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sourceAccountId (optional) 
     * @param targetId (optional) 
     * @param tenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    mergeAccountFromSourceAccount(sourceAccountId: number | undefined, targetId: number | undefined, tenantId: number | null | undefined, body: TargetAccountEnum | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/MergeAccountFromSourceAccount?";
        if (sourceAccountId === null)
            throw new Error("The parameter 'sourceAccountId' cannot be null.");
        else if (sourceAccountId !== undefined)
            url_ += "sourceAccountId=" + encodeURIComponent("" + sourceAccountId) + "&";
        if (targetId === null)
            throw new Error("The parameter 'targetId' cannot be null.");
        else if (targetId !== undefined)
            url_ += "targetId=" + encodeURIComponent("" + targetId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeAccountFromSourceAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeAccountFromSourceAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processMergeAccountFromSourceAccount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sourceBranchId (optional) 
     * @param targetParentId (optional) 
     * @param targetAccountId (optional) 
     * @param targetTenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    mergeAppBranchFromSourceAccount(sourceBranchId: number | undefined, targetParentId: number | undefined, targetAccountId: number | undefined, targetTenantId: number | null | undefined, body: AppContact[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/MergeAppBranchFromSourceAccount?";
        if (sourceBranchId === null)
            throw new Error("The parameter 'sourceBranchId' cannot be null.");
        else if (sourceBranchId !== undefined)
            url_ += "sourceBranchId=" + encodeURIComponent("" + sourceBranchId) + "&";
        if (targetParentId === null)
            throw new Error("The parameter 'targetParentId' cannot be null.");
        else if (targetParentId !== undefined)
            url_ += "targetParentId=" + encodeURIComponent("" + targetParentId) + "&";
        if (targetAccountId === null)
            throw new Error("The parameter 'targetAccountId' cannot be null.");
        else if (targetAccountId !== undefined)
            url_ += "targetAccountId=" + encodeURIComponent("" + targetAccountId) + "&";
        if (targetTenantId !== undefined && targetTenantId !== null)
            url_ += "targetTenantId=" + encodeURIComponent("" + targetTenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeAppBranchFromSourceAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeAppBranchFromSourceAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processMergeAppBranchFromSourceAccount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param branchId (optional) 
     * @param tenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createAccountFromSourceAccount(branchId: number | undefined, tenantId: number | null | undefined, body: TargetAccountEnum | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateAccountFromSourceAccount?";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountFromSourceAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountFromSourceAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateAccountFromSourceAccount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param branchId (optional) 
     * @param parentId (optional) 
     * @param tenantId (optional) 
     * @param accountId (optional) 
     * @param merge (optional) 
     * @param body (optional) 
     * @return Success
     */
    createAppBranchFromSourceAccount(branchId: number | undefined, parentId: number | undefined, tenantId: number | null | undefined, accountId: number | undefined, merge: boolean | undefined, body: AppContact[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateAppBranchFromSourceAccount?";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (merge === null)
            throw new Error("The parameter 'merge' cannot be null.");
        else if (merge !== undefined)
            url_ += "merge=" + encodeURIComponent("" + merge) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppBranchFromSourceAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppBranchFromSourceAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateAppBranchFromSourceAccount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sourceAccountId (optional) 
     * @param targetAccountId (optional) 
     * @param sourceTenantId (optional) 
     * @param targetTenantId (optional) 
     * @param deleteSourceAccount (optional) 
     * @param deleteTargetAccount (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    deleteAccountForSourceAccount(sourceAccountType: SourceAccountEnum, targetAccountType: TargetAccountEnum, sourceAccountId: number | undefined, targetAccountId: number | undefined, sourceTenantId: number | null | undefined, targetTenantId: number | null | undefined, deleteSourceAccount: boolean | undefined, deleteTargetAccount: boolean | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/DeleteAccountForSourceAccount?";
        if (sourceAccountType === undefined || sourceAccountType === null)
            throw new Error("The parameter 'sourceAccountType' must be defined and cannot be null.");
        else
            url_ += "SourceAccountType=" + encodeURIComponent("" + sourceAccountType) + "&";
        if (targetAccountType === undefined || targetAccountType === null)
            throw new Error("The parameter 'targetAccountType' must be defined and cannot be null.");
        else
            url_ += "TargetAccountType=" + encodeURIComponent("" + targetAccountType) + "&";
        if (sourceAccountId === null)
            throw new Error("The parameter 'sourceAccountId' cannot be null.");
        else if (sourceAccountId !== undefined)
            url_ += "SourceAccountId=" + encodeURIComponent("" + sourceAccountId) + "&";
        if (targetAccountId === null)
            throw new Error("The parameter 'targetAccountId' cannot be null.");
        else if (targetAccountId !== undefined)
            url_ += "TargetAccountId=" + encodeURIComponent("" + targetAccountId) + "&";
        if (sourceTenantId !== undefined && sourceTenantId !== null)
            url_ += "SourceTenantId=" + encodeURIComponent("" + sourceTenantId) + "&";
        if (targetTenantId !== undefined && targetTenantId !== null)
            url_ += "TargetTenantId=" + encodeURIComponent("" + targetTenantId) + "&";
        if (deleteSourceAccount === null)
            throw new Error("The parameter 'deleteSourceAccount' cannot be null.");
        else if (deleteSourceAccount !== undefined)
            url_ += "DeleteSourceAccount=" + encodeURIComponent("" + deleteSourceAccount) + "&";
        if (deleteTargetAccount === null)
            throw new Error("The parameter 'deleteTargetAccount' cannot be null.");
        else if (deleteTargetAccount !== undefined)
            url_ += "DeleteTargetAccount=" + encodeURIComponent("" + deleteTargetAccount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountForSourceAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountForSourceAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteAccountForSourceAccount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppAdvertisementsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param maxTenantIdFilter (optional) 
     * @param minTenantIdFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param startTimeFilter (optional) 
     * @param endTimeFilter (optional) 
     * @param timeZoneFilter (optional) 
     * @param publishOnHomePageFilter (optional) 
     * @param publishOnMarketLandingPageFilter (optional) 
     * @param maxApprovalDateTimeFilter (optional) 
     * @param minApprovalDateTimeFilter (optional) 
     * @param paymentMethodFilter (optional) 
     * @param maxInvoiceNumberFilter (optional) 
     * @param minInvoiceNumberFilter (optional) 
     * @param maxNumberOfOccurencesFilter (optional) 
     * @param minNumberOfOccurencesFilter (optional) 
     * @param maxPeriodOfViewFilter (optional) 
     * @param minPeriodOfViewFilter (optional) 
     * @param appEntityNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param url (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, maxTenantIdFilter: number | null | undefined, minTenantIdFilter: number | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, startTimeFilter: string | null | undefined, endTimeFilter: string | null | undefined, timeZoneFilter: string | null | undefined, publishOnHomePageFilter: number | null | undefined, publishOnMarketLandingPageFilter: number | null | undefined, maxApprovalDateTimeFilter: moment.Moment | null | undefined, minApprovalDateTimeFilter: moment.Moment | null | undefined, paymentMethodFilter: string | null | undefined, maxInvoiceNumberFilter: number | null | undefined, minInvoiceNumberFilter: number | null | undefined, maxNumberOfOccurencesFilter: number | null | undefined, minNumberOfOccurencesFilter: number | null | undefined, maxPeriodOfViewFilter: number | null | undefined, minPeriodOfViewFilter: number | null | undefined, appEntityNameFilter: string | null | undefined, userNameFilter: string | null | undefined, url: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppAdvertisementForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (maxTenantIdFilter !== undefined && maxTenantIdFilter !== null)
            url_ += "MaxTenantIdFilter=" + encodeURIComponent("" + maxTenantIdFilter) + "&";
        if (minTenantIdFilter !== undefined && minTenantIdFilter !== null)
            url_ += "MinTenantIdFilter=" + encodeURIComponent("" + minTenantIdFilter) + "&";
        if (maxStartDateFilter !== undefined && maxStartDateFilter !== null)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toISOString() : "") + "&";
        if (minStartDateFilter !== undefined && minStartDateFilter !== null)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toISOString() : "") + "&";
        if (maxEndDateFilter !== undefined && maxEndDateFilter !== null)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toISOString() : "") + "&";
        if (minEndDateFilter !== undefined && minEndDateFilter !== null)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toISOString() : "") + "&";
        if (startTimeFilter !== undefined && startTimeFilter !== null)
            url_ += "StartTimeFilter=" + encodeURIComponent("" + startTimeFilter) + "&";
        if (endTimeFilter !== undefined && endTimeFilter !== null)
            url_ += "EndTimeFilter=" + encodeURIComponent("" + endTimeFilter) + "&";
        if (timeZoneFilter !== undefined && timeZoneFilter !== null)
            url_ += "TimeZoneFilter=" + encodeURIComponent("" + timeZoneFilter) + "&";
        if (publishOnHomePageFilter !== undefined && publishOnHomePageFilter !== null)
            url_ += "PublishOnHomePageFilter=" + encodeURIComponent("" + publishOnHomePageFilter) + "&";
        if (publishOnMarketLandingPageFilter !== undefined && publishOnMarketLandingPageFilter !== null)
            url_ += "PublishOnMarketLandingPageFilter=" + encodeURIComponent("" + publishOnMarketLandingPageFilter) + "&";
        if (maxApprovalDateTimeFilter !== undefined && maxApprovalDateTimeFilter !== null)
            url_ += "MaxApprovalDateTimeFilter=" + encodeURIComponent(maxApprovalDateTimeFilter ? "" + maxApprovalDateTimeFilter.toISOString() : "") + "&";
        if (minApprovalDateTimeFilter !== undefined && minApprovalDateTimeFilter !== null)
            url_ += "MinApprovalDateTimeFilter=" + encodeURIComponent(minApprovalDateTimeFilter ? "" + minApprovalDateTimeFilter.toISOString() : "") + "&";
        if (paymentMethodFilter !== undefined && paymentMethodFilter !== null)
            url_ += "PaymentMethodFilter=" + encodeURIComponent("" + paymentMethodFilter) + "&";
        if (maxInvoiceNumberFilter !== undefined && maxInvoiceNumberFilter !== null)
            url_ += "MaxInvoiceNumberFilter=" + encodeURIComponent("" + maxInvoiceNumberFilter) + "&";
        if (minInvoiceNumberFilter !== undefined && minInvoiceNumberFilter !== null)
            url_ += "MinInvoiceNumberFilter=" + encodeURIComponent("" + minInvoiceNumberFilter) + "&";
        if (maxNumberOfOccurencesFilter !== undefined && maxNumberOfOccurencesFilter !== null)
            url_ += "MaxNumberOfOccurencesFilter=" + encodeURIComponent("" + maxNumberOfOccurencesFilter) + "&";
        if (minNumberOfOccurencesFilter !== undefined && minNumberOfOccurencesFilter !== null)
            url_ += "MinNumberOfOccurencesFilter=" + encodeURIComponent("" + minNumberOfOccurencesFilter) + "&";
        if (maxPeriodOfViewFilter !== undefined && maxPeriodOfViewFilter !== null)
            url_ += "MaxPeriodOfViewFilter=" + encodeURIComponent("" + maxPeriodOfViewFilter) + "&";
        if (minPeriodOfViewFilter !== undefined && minPeriodOfViewFilter !== null)
            url_ += "MinPeriodOfViewFilter=" + encodeURIComponent("" + minPeriodOfViewFilter) + "&";
        if (appEntityNameFilter !== undefined && appEntityNameFilter !== null)
            url_ += "AppEntityNameFilter=" + encodeURIComponent("" + appEntityNameFilter) + "&";
        if (userNameFilter !== undefined && userNameFilter !== null)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (url !== undefined && url !== null)
            url_ += "Url=" + encodeURIComponent("" + url) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppAdvertisementForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppAdvertisementForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppAdvertisementForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppAdvertisementForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppAdvertisementForView(id: number | undefined): Observable<GetAppAdvertisementForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetAppAdvertisementForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppAdvertisementForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppAdvertisementForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppAdvertisementForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppAdvertisementForViewDto>;
        }));
    }

    protected processGetAppAdvertisementForView(response: HttpResponseBase): Observable<GetAppAdvertisementForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppAdvertisementForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppAdvertisementForEdit(id: number | undefined): Observable<GetAppAdvertisementForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetAppAdvertisementForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppAdvertisementForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppAdvertisementForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppAdvertisementForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppAdvertisementForEditOutput>;
        }));
    }

    protected processGetAppAdvertisementForEdit(response: HttpResponseBase): Observable<GetAppAdvertisementForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppAdvertisementForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppAdvertisementDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAppEntityForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetAllAppEntityForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppEntityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppEntityForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto>;
        }));
    }

    protected processGetAllAppEntityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppAdvertisementUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetAllUserForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppAdvertisementUserLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppAdvertisementUserLookupTableDto>;
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAppAdvertisementUserLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppAdvertisementUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param topAdsInCurrentPeriod (optional) 
     * @param publishOnHomePage (optional) 
     * @param publishOnMarketLandingPage (optional) 
     * @return Success
     */
    getCurrentPeriodAdvertisement(topAdsInCurrentPeriod: number | undefined, publishOnHomePage: boolean | null | undefined, publishOnMarketLandingPage: boolean | null | undefined): Observable<GetAppAdvertisementForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetCurrentPeriodAdvertisement?";
        if (topAdsInCurrentPeriod === null)
            throw new Error("The parameter 'topAdsInCurrentPeriod' cannot be null.");
        else if (topAdsInCurrentPeriod !== undefined)
            url_ += "topAdsInCurrentPeriod=" + encodeURIComponent("" + topAdsInCurrentPeriod) + "&";
        if (publishOnHomePage !== undefined && publishOnHomePage !== null)
            url_ += "PublishOnHomePage=" + encodeURIComponent("" + publishOnHomePage) + "&";
        if (publishOnMarketLandingPage !== undefined && publishOnMarketLandingPage !== null)
            url_ += "PublishOnMarketLandingPage=" + encodeURIComponent("" + publishOnMarketLandingPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentPeriodAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentPeriodAdvertisement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppAdvertisementForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppAdvertisementForViewDto[]>;
        }));
    }

    protected processGetCurrentPeriodAdvertisement(response: HttpResponseBase): Observable<GetAppAdvertisementForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAppAdvertisementForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAdvertisementForUpdate(): Observable<PagedResultDtoOfGetAppAdvertisementForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetAllAdvertisementForUpdate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdvertisementForUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdvertisementForUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppAdvertisementForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppAdvertisementForViewDto>;
        }));
    }

    protected processGetAllAdvertisementForUpdate(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppAdvertisementForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppAdvertisementForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTimeZonesList(): Observable<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppAdvertisements/GetTimeZonesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimeZonesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimeZonesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectItemDto[]>;
        }));
    }

    protected processGetTimeZonesList(response: HttpResponseBase): Observable<SelectItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppEntitiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppEntityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppEntityForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppEntityForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppEntityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppEntityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param names (optional) 
     * @param body (optional) 
     * @return Success
     */
    checkArray(names: string | null | undefined, body: number[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/checkArray?";
        if (names !== undefined && names !== null)
            url_ += "names=" + encodeURIComponent("" + names) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckArray(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckArray(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckArray(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppEntityRelations(id: number | undefined): Observable<GetAppEntityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityRelations?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityRelations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityRelations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppEntityForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppEntityForViewDto>;
        }));
    }

    protected processGetAppEntityRelations(response: HttpResponseBase): Observable<GetAppEntityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppEntityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppEntityState(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityState?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAppEntityState(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param jsonString (optional) 
     * @return Success
     */
    setAppEntityState(id: number | undefined, jsonString: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/SetAppEntityState?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (jsonString !== undefined && jsonString !== null)
            url_ += "jsonString=" + encodeURIComponent("" + jsonString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAppEntityState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAppEntityState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAppEntityState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppEntityForView(id: number | undefined): Observable<GetAppEntityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppEntityForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppEntityForViewDto>;
        }));
    }

    protected processGetAppEntityForView(response: HttpResponseBase): Observable<GetAppEntityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppEntityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppEntityForEdit(id: number | undefined): Observable<GetAppEntityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppEntityForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppEntityForEditOutput>;
        }));
    }

    protected processGetAppEntityForEdit(response: HttpResponseBase): Observable<GetAppEntityForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppEntityForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAddressTypeForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllAddressTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAddressTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAddressTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllAddressTypeForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @return Success
     */
    getAppEntitiesToExcel(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntitiesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntitiesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntitiesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppEntitiesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycEntityObjectTypeForTableDropdown(): Observable<AppEntitySycEntityObjectTypeLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllSycEntityObjectTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycEntityObjectTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycEntityObjectTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppEntitySycEntityObjectTypeLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppEntitySycEntityObjectTypeLookupTableDto[]>;
        }));
    }

    protected processGetAllSycEntityObjectTypeForTableDropdown(response: HttpResponseBase): Observable<AppEntitySycEntityObjectTypeLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppEntitySycEntityObjectTypeLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycEntityObjectStatusForTableDropdown(): Observable<AppEntitySycEntityObjectStatusLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllSycEntityObjectStatusForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycEntityObjectStatusForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycEntityObjectStatusForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppEntitySycEntityObjectStatusLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppEntitySycEntityObjectStatusLookupTableDto[]>;
        }));
    }

    protected processGetAllSycEntityObjectStatusForTableDropdown(response: HttpResponseBase): Observable<AppEntitySycEntityObjectStatusLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppEntitySycEntityObjectStatusLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSydObjectForTableDropdown(): Observable<AppEntitySydObjectLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllSydObjectForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSydObjectForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSydObjectForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppEntitySydObjectLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppEntitySydObjectLookupTableDto[]>;
        }));
    }

    protected processGetAllSydObjectForTableDropdown(response: HttpResponseBase): Observable<AppEntitySydObjectLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppEntitySydObjectLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllLanguageForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllLanguageForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLanguageForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLanguageForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllLanguageForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAccountTypesForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllAccountTypesForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountTypesForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountTypesForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllAccountTypesForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getAllEntitiesByTypeCode(code: string | null | undefined): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllEntitiesByTypeCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntitiesByTypeCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntitiesByTypeCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllEntitiesByTypeCode(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getMarketPlaceSizes(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetMarketPlaceSizes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMarketPlaceSizes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMarketPlaceSizes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetMarketPlaceSizes(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEntitiesByTypeCodeWithPaging(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllEntitiesByTypeCodeWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntitiesByTypeCodeWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntitiesByTypeCodeWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelDto>;
        }));
    }

    protected processGetAllEntitiesByTypeCodeWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLineSheetColorSort(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetLineSheetColorSort";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineSheetColorSort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineSheetColorSort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetLineSheetColorSort(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLineSheetDetailPageSort(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetLineSheetDetailPageSort";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineSheetDetailPageSort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineSheetDetailPageSort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetLineSheetDetailPageSort(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBackgroundWithPaging(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelWithAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllBackgroundWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBackgroundWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBackgroundWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelWithAttachmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelWithAttachmentDto>;
        }));
    }

    protected processGetAllBackgroundWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelWithAttachmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelWithAttachmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForTableDropdownWithPaging(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllCurrencyForTableDropdownWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForTableDropdownWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForTableDropdownWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelDto>;
        }));
    }

    protected processGetAllCurrencyForTableDropdownWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLanguageForTableDropdownWithPaging(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllLanguageForTableDropdownWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLanguageForTableDropdownWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLanguageForTableDropdownWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelDto>;
        }));
    }

    protected processGetAllLanguageForTableDropdownWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCountryForTableDropdowWithPaging(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllCountryForTableDropdowWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdowWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdowWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelDto>;
        }));
    }

    protected processGetAllCountryForTableDropdowWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAccountTypesForTableDropdownWithPaging(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllAccountTypesForTableDropdownWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountTypesForTableDropdownWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountTypesForTableDropdownWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelDto>;
        }));
    }

    protected processGetAllAccountTypesForTableDropdownWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAccountTypeForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllAccountTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllAccountTypeForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param sycEntityObjectStatusNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param entityObjectTypeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEntityTypeForTableDropdown(filter: string | null | undefined, nameFilter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, extraDataFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, sycEntityObjectStatusNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, entityObjectTypeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllEntityTypeForTableDropdown?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (sycEntityObjectStatusNameFilter !== undefined && sycEntityObjectStatusNameFilter !== null)
            url_ += "SycEntityObjectStatusNameFilter=" + encodeURIComponent("" + sycEntityObjectStatusNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntityTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntityTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelDto>;
        }));
    }

    protected processGetAllEntityTypeForTableDropdown(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCurrencyForTableDropdown(): Observable<CurrencyInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllCurrencyForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyInfoDto[]>;
        }));
    }

    protected processGetAllCurrencyForTableDropdown(response: HttpResponseBase): Observable<CurrencyInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllTitlesForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllTitlesForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTitlesForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTitlesForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllTitlesForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPhoneTypeForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllPhoneTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPhoneTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPhoneTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllPhoneTypeForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveEntity(body: AppEntityDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/SaveEntity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveEntity(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveContact(body: AppContactDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/SaveContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveContact(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityCategoriesWithPaging(entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityCategoriesWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityCategoriesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityCategoriesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
        }));
    }

    protected processGetAppEntityCategoriesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityClassificationsWithPaging(entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityClassificationsWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityClassificationsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityClassificationsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityClassificationDto>;
        }));
    }

    protected processGetAppEntityClassificationsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityDepartmentsWithPaging(entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityDepartmentsWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityDepartmentsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityDepartmentsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
        }));
    }

    protected processGetAppEntityDepartmentsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityCategoriesNamesWithPaging(entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfString> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityCategoriesNamesWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityCategoriesNamesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityCategoriesNamesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfString>;
        }));
    }

    protected processGetAppEntityCategoriesNamesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityClassificationsNamesWithPaging(entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfString> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityClassificationsNamesWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityClassificationsNamesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityClassificationsNamesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfString>;
        }));
    }

    protected processGetAppEntityClassificationsNamesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityDepartmentsNamesWithPaging(entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfString> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityDepartmentsNamesWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityDepartmentsNamesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityDepartmentsNamesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfString>;
        }));
    }

    protected processGetAppEntityDepartmentsNamesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityAttachmentsWithPaging(entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityAttachmentsWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityAttachmentsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityAttachmentsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityAttachmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityAttachmentDto>;
        }));
    }

    protected processGetAppEntityAttachmentsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityAttachmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityAttachmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param entityIds (optional) 
     * @param getDefaultOnly (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntitysAttachmentsWithPaging(tenantId: number | null | undefined, entityIds: number[] | null | undefined, getDefaultOnly: boolean | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntitysAttachmentsWithPaging?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (entityIds !== undefined && entityIds !== null)
            entityIds && entityIds.forEach(item => { url_ += "EntityIds=" + encodeURIComponent("" + item) + "&"; });
        if (getDefaultOnly === null)
            throw new Error("The parameter 'getDefaultOnly' cannot be null.");
        else if (getDefaultOnly !== undefined)
            url_ += "GetDefaultOnly=" + encodeURIComponent("" + getDefaultOnly) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntitysAttachmentsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntitysAttachmentsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityAttachmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityAttachmentDto>;
        }));
    }

    protected processGetAppEntitysAttachmentsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityAttachmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityAttachmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param attributeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityExtraWithPaging(entityId: number | undefined, attributeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityExtraDataDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityExtraWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (attributeIds !== undefined && attributeIds !== null)
            attributeIds && attributeIds.forEach(item => { url_ += "AttributeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityExtraWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityExtraWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityExtraDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityExtraDataDto>;
        }));
    }

    protected processGetAppEntityExtraWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityExtraDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityExtraDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entitlyId (optional) 
     * @param removeComment (optional) 
     * @return Success
     */
    updateEntityCommentsCount(entitlyId: number | undefined, removeComment: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/UpdateEntityCommentsCount?";
        if (entitlyId === null)
            throw new Error("The parameter 'entitlyId' cannot be null.");
        else if (entitlyId !== undefined)
            url_ += "entitlyId=" + encodeURIComponent("" + entitlyId) + "&";
        if (removeComment === null)
            throw new Error("The parameter 'removeComment' cannot be null.");
        else if (removeComment !== undefined)
            url_ += "RemoveComment=" + encodeURIComponent("" + removeComment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEntityCommentsCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEntityCommentsCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateEntityCommentsCount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param attributeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityAttrDistinctWithPaging(entityId: number | undefined, attributeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfInt64> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityAttrDistinctWithPaging?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (attributeIds !== undefined && attributeIds !== null)
            attributeIds && attributeIds.forEach(item => { url_ += "AttributeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityAttrDistinctWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityAttrDistinctWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInt64>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInt64>;
        }));
    }

    protected processGetAppEntityAttrDistinctWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfInt64> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInt64.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityIds (optional) 
     * @param attr (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppEntityColorsWithPaging(entityIds: number[] | null | undefined, attr: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityExtraDataDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAppEntityColorsWithPaging?";
        if (entityIds !== undefined && entityIds !== null)
            entityIds && entityIds.forEach(item => { url_ += "EntityIds=" + encodeURIComponent("" + item) + "&"; });
        if (attr !== undefined && attr !== null)
            url_ += "Attr=" + encodeURIComponent("" + attr) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEntityColorsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEntityColorsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityExtraDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityExtraDataDto>;
        }));
    }

    protected processGetAppEntityColorsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityExtraDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityExtraDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entitlyId (optional) 
     * @param reaction (optional) 
     * @return Success
     */
    createOrUpdateReaction(entitlyId: number | undefined, reaction: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/CreateOrUpdateReaction?";
        if (entitlyId === null)
            throw new Error("The parameter 'entitlyId' cannot be null.");
        else if (entitlyId !== undefined)
            url_ += "entitlyId=" + encodeURIComponent("" + entitlyId) + "&";
        if (reaction === null)
            throw new Error("The parameter 'reaction' cannot be null.");
        else if (reaction !== undefined)
            url_ += "reaction=" + encodeURIComponent("" + reaction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateReaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateReaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateReaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entitlyId (optional) 
     * @return Success
     */
    createUserView(entitlyId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/CreateUserView?";
        if (entitlyId === null)
            throw new Error("The parameter 'entitlyId' cannot be null.");
        else if (entitlyId !== undefined)
            url_ += "entitlyId=" + encodeURIComponent("" + entitlyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateUserView(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUserReaction(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/DeleteUserReaction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserReaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserReaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUserReaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @return Success
     */
    getCurrentUserReaction(entityId: number | undefined): Observable<AppEntityUserReactionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetCurrentUserReaction?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserReaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserReaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppEntityUserReactionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppEntityUserReactionDto>;
        }));
    }

    protected processGetCurrentUserReaction(response: HttpResponseBase): Observable<AppEntityUserReactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppEntityUserReactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @return Success
     */
    getUsersReactionsCount(entityId: number | undefined): Observable<AppEntityUserReactionsCountDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetUsersReactionsCount?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersReactionsCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersReactionsCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppEntityUserReactionsCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppEntityUserReactionsCountDto>;
        }));
    }

    protected processGetUsersReactionsCount(response: HttpResponseBase): Observable<AppEntityUserReactionsCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppEntityUserReactionsCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param reaction (optional) 
     * @return Success
     */
    getAllUsersReactions(entityId: number | undefined, reaction: number | null | undefined): Observable<PagedResultDtoOfAppEntityUserReactionsDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetAllUsersReactions?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (reaction !== undefined && reaction !== null)
            url_ += "reaction=" + encodeURIComponent("" + reaction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsersReactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsersReactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityUserReactionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityUserReactionsDto>;
        }));
    }

    protected processGetAllUsersReactions(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityUserReactionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityUserReactionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param numberOfPosts (optional) 
     * @param numberOfDays (optional) 
     * @return Success
     */
    getTopPosts(numberOfPosts: number | undefined, numberOfDays: number | undefined): Observable<TopPostDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetTopPosts?";
        if (numberOfPosts === null)
            throw new Error("The parameter 'numberOfPosts' cannot be null.");
        else if (numberOfPosts !== undefined)
            url_ += "numberOfPosts=" + encodeURIComponent("" + numberOfPosts) + "&";
        if (numberOfDays === null)
            throw new Error("The parameter 'numberOfDays' cannot be null.");
        else if (numberOfDays !== undefined)
            url_ += "numberOfDays=" + encodeURIComponent("" + numberOfDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopPostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopPostDto[]>;
        }));
    }

    protected processGetTopPosts(response: HttpResponseBase): Observable<TopPostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TopPostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param numberOfUsers (optional) 
     * @param numberOfDays (optional) 
     * @return Success
     */
    getTopContributors(numberOfUsers: number | undefined, numberOfDays: number | undefined): Observable<UserInformationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetTopContributors?";
        if (numberOfUsers === null)
            throw new Error("The parameter 'numberOfUsers' cannot be null.");
        else if (numberOfUsers !== undefined)
            url_ += "numberOfUsers=" + encodeURIComponent("" + numberOfUsers) + "&";
        if (numberOfDays === null)
            throw new Error("The parameter 'numberOfDays' cannot be null.");
        else if (numberOfDays !== undefined)
            url_ += "numberOfDays=" + encodeURIComponent("" + numberOfDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopContributors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopContributors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInformationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInformationDto[]>;
        }));
    }

    protected processGetTopContributors(response: HttpResponseBase): Observable<UserInformationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInformationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param numberOfCompanies (optional) 
     * @param numberOfDays (optional) 
     * @return Success
     */
    getTopCompanies(numberOfCompanies: number | undefined, numberOfDays: number | undefined): Observable<TopCompany[]> {
        let url_ = this.baseUrl + "/api/services/app/AppEntities/GetTopCompanies?";
        if (numberOfCompanies === null)
            throw new Error("The parameter 'numberOfCompanies' cannot be null.");
        else if (numberOfCompanies !== undefined)
            url_ += "numberOfCompanies=" + encodeURIComponent("" + numberOfCompanies) + "&";
        if (numberOfDays === null)
            throw new Error("The parameter 'numberOfDays' cannot be null.");
        else if (numberOfDays !== undefined)
            url_ += "numberOfDays=" + encodeURIComponent("" + numberOfDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopCompany[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopCompany[]>;
        }));
    }

    protected processGetTopCompanies(response: HttpResponseBase): Observable<TopCompany[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TopCompany.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppEventGuestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxUserResponceFilter (optional) 
     * @param minUserResponceFilter (optional) 
     * @param eventIdFilter (optional) 
     * @param currentUserFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxUserResponceFilter: number | null | undefined, minUserResponceFilter: number | null | undefined, eventIdFilter: number | null | undefined, currentUserFilter: boolean | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppEventGuestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEventGuests/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxUserResponceFilter !== undefined && maxUserResponceFilter !== null)
            url_ += "MaxUserResponceFilter=" + encodeURIComponent("" + maxUserResponceFilter) + "&";
        if (minUserResponceFilter !== undefined && minUserResponceFilter !== null)
            url_ += "MinUserResponceFilter=" + encodeURIComponent("" + minUserResponceFilter) + "&";
        if (eventIdFilter !== undefined && eventIdFilter !== null)
            url_ += "EventIdFilter=" + encodeURIComponent("" + eventIdFilter) + "&";
        if (currentUserFilter === null)
            throw new Error("The parameter 'currentUserFilter' cannot be null.");
        else if (currentUserFilter !== undefined)
            url_ += "CurrentUserFilter=" + encodeURIComponent("" + currentUserFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppEventGuestForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppEventGuestForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppEventGuestForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppEventGuestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppEventGuestForEdit(id: number | undefined): Observable<GetAppEventGuestForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppEventGuests/GetAppEventGuestForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEventGuestForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEventGuestForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppEventGuestForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppEventGuestForEditOutput>;
        }));
    }

    protected processGetAppEventGuestForEdit(response: HttpResponseBase): Observable<GetAppEventGuestForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppEventGuestForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppEventGuestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEventGuests/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEventGuests/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param isOnLineFilter (optional) 
     * @param isPublishedFilter (optional) 
     * @param creatorUserIdFilter (optional) 
     * @param idFilter (optional) 
     * @param entityIdFilter (optional) 
     * @param includeAttachments (optional) 
     * @param timeZoneFilter (optional) 
     * @param maxFromDateFilter (optional) 
     * @param minFromDateFilter (optional) 
     * @param maxToDateFilter (optional) 
     * @param minToDateFilter (optional) 
     * @param maxFromTimeFilter (optional) 
     * @param minFromTimeFilter (optional) 
     * @param maxToTimeFilter (optional) 
     * @param minToTimeFilter (optional) 
     * @param privacyFilter (optional) 
     * @param guestCanInviteFriendsFilter (optional) 
     * @param locationFilter (optional) 
     * @param appEntityNameFilter (optional) 
     * @param cityFilter (optional) 
     * @param stateFilter (optional) 
     * @param postalFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filterType: EventsFilterTypesEnum, filter: string | null | undefined, isOnLineFilter: boolean | null | undefined, isPublishedFilter: boolean | null | undefined, creatorUserIdFilter: number | null | undefined, idFilter: number | null | undefined, entityIdFilter: number | null | undefined, includeAttachments: boolean | undefined, timeZoneFilter: string | null | undefined, maxFromDateFilter: moment.Moment | null | undefined, minFromDateFilter: moment.Moment | null | undefined, maxToDateFilter: moment.Moment | null | undefined, minToDateFilter: moment.Moment | null | undefined, maxFromTimeFilter: moment.Moment | null | undefined, minFromTimeFilter: moment.Moment | null | undefined, maxToTimeFilter: moment.Moment | null | undefined, minToTimeFilter: moment.Moment | null | undefined, privacyFilter: boolean | null | undefined, guestCanInviteFriendsFilter: boolean | null | undefined, locationFilter: string | null | undefined, appEntityNameFilter: string | null | undefined, cityFilter: string | null | undefined, stateFilter: string | null | undefined, postalFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppEventForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/GetAll?";
        if (filterType === undefined || filterType === null)
            throw new Error("The parameter 'filterType' must be defined and cannot be null.");
        else
            url_ += "FilterType=" + encodeURIComponent("" + filterType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (isOnLineFilter !== undefined && isOnLineFilter !== null)
            url_ += "IsOnLineFilter=" + encodeURIComponent("" + isOnLineFilter) + "&";
        if (isPublishedFilter !== undefined && isPublishedFilter !== null)
            url_ += "IsPublishedFilter=" + encodeURIComponent("" + isPublishedFilter) + "&";
        if (creatorUserIdFilter !== undefined && creatorUserIdFilter !== null)
            url_ += "CreatorUserIdFilter=" + encodeURIComponent("" + creatorUserIdFilter) + "&";
        if (idFilter !== undefined && idFilter !== null)
            url_ += "IdFilter=" + encodeURIComponent("" + idFilter) + "&";
        if (entityIdFilter !== undefined && entityIdFilter !== null)
            url_ += "EntityIdFilter=" + encodeURIComponent("" + entityIdFilter) + "&";
        if (includeAttachments === null)
            throw new Error("The parameter 'includeAttachments' cannot be null.");
        else if (includeAttachments !== undefined)
            url_ += "IncludeAttachments=" + encodeURIComponent("" + includeAttachments) + "&";
        if (timeZoneFilter !== undefined && timeZoneFilter !== null)
            url_ += "TimeZoneFilter=" + encodeURIComponent("" + timeZoneFilter) + "&";
        if (maxFromDateFilter !== undefined && maxFromDateFilter !== null)
            url_ += "MaxFromDateFilter=" + encodeURIComponent(maxFromDateFilter ? "" + maxFromDateFilter.toISOString() : "") + "&";
        if (minFromDateFilter !== undefined && minFromDateFilter !== null)
            url_ += "MinFromDateFilter=" + encodeURIComponent(minFromDateFilter ? "" + minFromDateFilter.toISOString() : "") + "&";
        if (maxToDateFilter !== undefined && maxToDateFilter !== null)
            url_ += "MaxToDateFilter=" + encodeURIComponent(maxToDateFilter ? "" + maxToDateFilter.toISOString() : "") + "&";
        if (minToDateFilter !== undefined && minToDateFilter !== null)
            url_ += "MinToDateFilter=" + encodeURIComponent(minToDateFilter ? "" + minToDateFilter.toISOString() : "") + "&";
        if (maxFromTimeFilter !== undefined && maxFromTimeFilter !== null)
            url_ += "MaxFromTimeFilter=" + encodeURIComponent(maxFromTimeFilter ? "" + maxFromTimeFilter.toISOString() : "") + "&";
        if (minFromTimeFilter !== undefined && minFromTimeFilter !== null)
            url_ += "MinFromTimeFilter=" + encodeURIComponent(minFromTimeFilter ? "" + minFromTimeFilter.toISOString() : "") + "&";
        if (maxToTimeFilter !== undefined && maxToTimeFilter !== null)
            url_ += "MaxToTimeFilter=" + encodeURIComponent(maxToTimeFilter ? "" + maxToTimeFilter.toISOString() : "") + "&";
        if (minToTimeFilter !== undefined && minToTimeFilter !== null)
            url_ += "MinToTimeFilter=" + encodeURIComponent(minToTimeFilter ? "" + minToTimeFilter.toISOString() : "") + "&";
        if (privacyFilter !== undefined && privacyFilter !== null)
            url_ += "PrivacyFilter=" + encodeURIComponent("" + privacyFilter) + "&";
        if (guestCanInviteFriendsFilter !== undefined && guestCanInviteFriendsFilter !== null)
            url_ += "GuestCanInviteFriendsFilter=" + encodeURIComponent("" + guestCanInviteFriendsFilter) + "&";
        if (locationFilter !== undefined && locationFilter !== null)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&";
        if (appEntityNameFilter !== undefined && appEntityNameFilter !== null)
            url_ += "AppEntityNameFilter=" + encodeURIComponent("" + appEntityNameFilter) + "&";
        if (cityFilter !== undefined && cityFilter !== null)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (stateFilter !== undefined && stateFilter !== null)
            url_ += "StateFilter=" + encodeURIComponent("" + stateFilter) + "&";
        if (postalFilter !== undefined && postalFilter !== null)
            url_ += "PostalFilter=" + encodeURIComponent("" + postalFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppEventForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppEventForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppEventForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppEventForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppEventForEdit(id: number | undefined): Observable<GetAppEventForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/GetAppEventForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEventForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEventForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppEventForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppEventForEditDto>;
        }));
    }

    protected processGetAppEventForEdit(response: HttpResponseBase): Observable<GetAppEventForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppEventForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param entityId (optional) 
     * @param timeZone (optional) 
     * @return Success
     */
    getAppEventForView(id: number | undefined, entityId: number | undefined, timeZone: string | null | undefined): Observable<GetAppEventForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/GetAppEventForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (timeZone !== undefined && timeZone !== null)
            url_ += "timeZone=" + encodeURIComponent("" + timeZone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEventForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEventForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppEventForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppEventForViewDto>;
        }));
    }

    protected processGetAppEventForView(response: HttpResponseBase): Observable<GetAppEventForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppEventForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppEventDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param isOnLineFilter (optional) 
     * @param maxFromDateFilter (optional) 
     * @param minFromDateFilter (optional) 
     * @param maxToDateFilter (optional) 
     * @param minToDateFilter (optional) 
     * @param maxFromTimeFilter (optional) 
     * @param minFromTimeFilter (optional) 
     * @param maxToTimeFilter (optional) 
     * @param minToTimeFilter (optional) 
     * @param privacyFilter (optional) 
     * @param guestCanInviteFriendsFilter (optional) 
     * @param locationFilter (optional) 
     * @param appEntityNameFilter (optional) 
     * @return Success
     */
    getAppEventsToExcel(filter: string | null | undefined, isOnLineFilter: number | null | undefined, maxFromDateFilter: moment.Moment | null | undefined, minFromDateFilter: moment.Moment | null | undefined, maxToDateFilter: moment.Moment | null | undefined, minToDateFilter: moment.Moment | null | undefined, maxFromTimeFilter: moment.Moment | null | undefined, minFromTimeFilter: moment.Moment | null | undefined, maxToTimeFilter: moment.Moment | null | undefined, minToTimeFilter: moment.Moment | null | undefined, privacyFilter: number | null | undefined, guestCanInviteFriendsFilter: number | null | undefined, locationFilter: string | null | undefined, appEntityNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/GetAppEventsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (isOnLineFilter !== undefined && isOnLineFilter !== null)
            url_ += "IsOnLineFilter=" + encodeURIComponent("" + isOnLineFilter) + "&";
        if (maxFromDateFilter !== undefined && maxFromDateFilter !== null)
            url_ += "MaxFromDateFilter=" + encodeURIComponent(maxFromDateFilter ? "" + maxFromDateFilter.toISOString() : "") + "&";
        if (minFromDateFilter !== undefined && minFromDateFilter !== null)
            url_ += "MinFromDateFilter=" + encodeURIComponent(minFromDateFilter ? "" + minFromDateFilter.toISOString() : "") + "&";
        if (maxToDateFilter !== undefined && maxToDateFilter !== null)
            url_ += "MaxToDateFilter=" + encodeURIComponent(maxToDateFilter ? "" + maxToDateFilter.toISOString() : "") + "&";
        if (minToDateFilter !== undefined && minToDateFilter !== null)
            url_ += "MinToDateFilter=" + encodeURIComponent(minToDateFilter ? "" + minToDateFilter.toISOString() : "") + "&";
        if (maxFromTimeFilter !== undefined && maxFromTimeFilter !== null)
            url_ += "MaxFromTimeFilter=" + encodeURIComponent(maxFromTimeFilter ? "" + maxFromTimeFilter.toISOString() : "") + "&";
        if (minFromTimeFilter !== undefined && minFromTimeFilter !== null)
            url_ += "MinFromTimeFilter=" + encodeURIComponent(minFromTimeFilter ? "" + minFromTimeFilter.toISOString() : "") + "&";
        if (maxToTimeFilter !== undefined && maxToTimeFilter !== null)
            url_ += "MaxToTimeFilter=" + encodeURIComponent(maxToTimeFilter ? "" + maxToTimeFilter.toISOString() : "") + "&";
        if (minToTimeFilter !== undefined && minToTimeFilter !== null)
            url_ += "MinToTimeFilter=" + encodeURIComponent(minToTimeFilter ? "" + minToTimeFilter.toISOString() : "") + "&";
        if (privacyFilter !== undefined && privacyFilter !== null)
            url_ += "PrivacyFilter=" + encodeURIComponent("" + privacyFilter) + "&";
        if (guestCanInviteFriendsFilter !== undefined && guestCanInviteFriendsFilter !== null)
            url_ += "GuestCanInviteFriendsFilter=" + encodeURIComponent("" + guestCanInviteFriendsFilter) + "&";
        if (locationFilter !== undefined && locationFilter !== null)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&";
        if (appEntityNameFilter !== undefined && appEntityNameFilter !== null)
            url_ += "AppEntityNameFilter=" + encodeURIComponent("" + appEntityNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppEventsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppEventsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppEventsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    publish(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/Publish?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPublish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    unPublish(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AppEvents/UnPublish?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnPublish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUnPublish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param appItemListId (optional) 
     * @param selectorOnly (optional) 
     * @param filter (optional) 
     * @param lastKey (optional) 
     * @param selectorKey (optional) 
     * @param priceListId (optional) 
     * @param arrtibuteFilters (optional) 
     * @param classificationFilters (optional) 
     * @param categoryFilters (optional) 
     * @param departmentFilters (optional) 
     * @param entityObjectTypeId (optional) 
     * @param minimumPrice (optional) 
     * @param maximumPrice (optional) 
     * @param itemType (optional) 
     * @param listingStatus (optional) 
     * @param publishStatus (optional) 
     * @param visibilityStatus (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(tenantId: number | null | undefined, appItemListId: number | null | undefined, selectorOnly: boolean | null | undefined, filter: string | null | undefined, filterType: ItemsFilterTypesEnum, lastKey: string | null | undefined, selectorKey: string | null | undefined, priceListId: number | undefined, arrtibuteFilters: ArrtibuteFilter[] | null | undefined, classificationFilters: number[] | null | undefined, categoryFilters: number[] | null | undefined, departmentFilters: number[] | null | undefined, entityObjectTypeId: number | undefined, minimumPrice: number | undefined, maximumPrice: number | undefined, itemType: number | undefined, listingStatus: number | undefined, publishStatus: number | undefined, visibilityStatus: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAll?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (appItemListId !== undefined && appItemListId !== null)
            url_ += "AppItemListId=" + encodeURIComponent("" + appItemListId) + "&";
        if (selectorOnly !== undefined && selectorOnly !== null)
            url_ += "SelectorOnly=" + encodeURIComponent("" + selectorOnly) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (filterType === undefined || filterType === null)
            throw new Error("The parameter 'filterType' must be defined and cannot be null.");
        else
            url_ += "FilterType=" + encodeURIComponent("" + filterType) + "&";
        if (lastKey !== undefined && lastKey !== null)
            url_ += "LastKey=" + encodeURIComponent("" + lastKey) + "&";
        if (selectorKey !== undefined && selectorKey !== null)
            url_ += "SelectorKey=" + encodeURIComponent("" + selectorKey) + "&";
        if (priceListId === null)
            throw new Error("The parameter 'priceListId' cannot be null.");
        else if (priceListId !== undefined)
            url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (arrtibuteFilters !== undefined && arrtibuteFilters !== null)
            arrtibuteFilters && arrtibuteFilters.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "ArrtibuteFilters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (classificationFilters !== undefined && classificationFilters !== null)
            classificationFilters && classificationFilters.forEach(item => { url_ += "ClassificationFilters=" + encodeURIComponent("" + item) + "&"; });
        if (categoryFilters !== undefined && categoryFilters !== null)
            categoryFilters && categoryFilters.forEach(item => { url_ += "CategoryFilters=" + encodeURIComponent("" + item) + "&"; });
        if (departmentFilters !== undefined && departmentFilters !== null)
            departmentFilters && departmentFilters.forEach(item => { url_ += "departmentFilters=" + encodeURIComponent("" + item) + "&"; });
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (minimumPrice === null)
            throw new Error("The parameter 'minimumPrice' cannot be null.");
        else if (minimumPrice !== undefined)
            url_ += "MinimumPrice=" + encodeURIComponent("" + minimumPrice) + "&";
        if (maximumPrice === null)
            throw new Error("The parameter 'maximumPrice' cannot be null.");
        else if (maximumPrice !== undefined)
            url_ += "MaximumPrice=" + encodeURIComponent("" + maximumPrice) + "&";
        if (itemType === null)
            throw new Error("The parameter 'itemType' cannot be null.");
        else if (itemType !== undefined)
            url_ += "ItemType=" + encodeURIComponent("" + itemType) + "&";
        if (listingStatus === null)
            throw new Error("The parameter 'listingStatus' cannot be null.");
        else if (listingStatus !== undefined)
            url_ += "ListingStatus=" + encodeURIComponent("" + listingStatus) + "&";
        if (publishStatus === null)
            throw new Error("The parameter 'publishStatus' cannot be null.");
        else if (publishStatus !== undefined)
            url_ += "PublishStatus=" + encodeURIComponent("" + publishStatus) + "&";
        if (visibilityStatus === null)
            throw new Error("The parameter 'visibilityStatus' cannot be null.");
        else if (visibilityStatus !== undefined)
            url_ += "VisibilityStatus=" + encodeURIComponent("" + visibilityStatus) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppItemForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppItemForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppItemForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    old_GetAll(body: GetAllAppItemsInput | undefined): Observable<PagedResultDtoOfGetAppItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/old_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOld_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOld_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppItemForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppItemForViewDto>;
        }));
    }

    protected processOld_GetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppItemForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param firstAttributeId (optional) 
     * @param secondAttributeId (optional) 
     * @param value (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSecondAttributeValues(itemId: number | undefined, firstAttributeId: number | undefined, secondAttributeId: number | undefined, value: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetSecondAttributeValues?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (firstAttributeId === null)
            throw new Error("The parameter 'firstAttributeId' cannot be null.");
        else if (firstAttributeId !== undefined)
            url_ += "FirstAttributeId=" + encodeURIComponent("" + firstAttributeId) + "&";
        if (secondAttributeId === null)
            throw new Error("The parameter 'secondAttributeId' cannot be null.");
        else if (secondAttributeId !== undefined)
            url_ += "SecondAttributeId=" + encodeURIComponent("" + secondAttributeId) + "&";
        if (value !== undefined && value !== null)
            url_ += "Value=" + encodeURIComponent("" + value) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSecondAttributeValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSecondAttributeValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupLabelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupLabelDto>;
        }));
    }

    protected processGetSecondAttributeValues(response: HttpResponseBase): Observable<PagedResultDtoOfLookupLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param firstAttributeId (optional) 
     * @param value (optional) 
     * @return Success
     */
    getFirstAttributeAttachments(itemId: number | undefined, firstAttributeId: number | undefined, value: string | null | undefined): Observable<AppEntityAttachmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetFirstAttributeAttachments?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (firstAttributeId === null)
            throw new Error("The parameter 'firstAttributeId' cannot be null.");
        else if (firstAttributeId !== undefined)
            url_ += "FirstAttributeId=" + encodeURIComponent("" + firstAttributeId) + "&";
        if (value !== undefined && value !== null)
            url_ += "Value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFirstAttributeAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFirstAttributeAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppEntityAttachmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppEntityAttachmentDto[]>;
        }));
    }

    protected processGetFirstAttributeAttachments(response: HttpResponseBase): Observable<AppEntityAttachmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppEntityAttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param attributeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getFirstAttributeValues(itemId: number | undefined, attributeId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfExtraDataSelectedValues> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetFirstAttributeValues?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (attributeId === null)
            throw new Error("The parameter 'attributeId' cannot be null.");
        else if (attributeId !== undefined)
            url_ += "AttributeId=" + encodeURIComponent("" + attributeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFirstAttributeValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFirstAttributeValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfExtraDataSelectedValues>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfExtraDataSelectedValues>;
        }));
    }

    protected processGetFirstAttributeValues(response: HttpResponseBase): Observable<PagedResultDtoOfExtraDataSelectedValues> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExtraDataSelectedValues.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appItemId (optional) 
     * @param extraAttributeId (optional) 
     * @param extraAttributeCode (optional) 
     * @return Success
     */
    getItemVariationDataForView(appItemId: number | undefined, extraAttributeId: number | undefined, extraAttributeCode: string | null | undefined): Observable<AppItemVariationsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetItemVariationDataForView?";
        if (appItemId === null)
            throw new Error("The parameter 'appItemId' cannot be null.");
        else if (appItemId !== undefined)
            url_ += "appItemId=" + encodeURIComponent("" + appItemId) + "&";
        if (extraAttributeId === null)
            throw new Error("The parameter 'extraAttributeId' cannot be null.");
        else if (extraAttributeId !== undefined)
            url_ += "extraAttributeId=" + encodeURIComponent("" + extraAttributeId) + "&";
        if (extraAttributeCode !== undefined && extraAttributeCode !== null)
            url_ += "extraAttributeCode=" + encodeURIComponent("" + extraAttributeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemVariationDataForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemVariationDataForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppItemVariationsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppItemVariationsDto[]>;
        }));
    }

    protected processGetItemVariationDataForView(response: HttpResponseBase): Observable<AppItemVariationsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppItemVariationsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appItemId (optional) 
     * @param priceLevel (optional) 
     * @param currencyCode (optional) 
     * @param attributeId (optional) 
     * @param attributeCode (optional) 
     * @return Success
     */
    getAppItemPrice(appItemId: number | undefined, priceLevel: string | null | undefined, currencyCode: string | null | undefined, attributeId: number | null | undefined, attributeCode: string | null | undefined): Observable<AppItemAttributePriceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemPrice?";
        if (appItemId === null)
            throw new Error("The parameter 'appItemId' cannot be null.");
        else if (appItemId !== undefined)
            url_ += "appItemId=" + encodeURIComponent("" + appItemId) + "&";
        if (priceLevel !== undefined && priceLevel !== null)
            url_ += "priceLevel=" + encodeURIComponent("" + priceLevel) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "currencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (attributeId !== undefined && attributeId !== null)
            url_ += "attributeId=" + encodeURIComponent("" + attributeId) + "&";
        if (attributeCode !== undefined && attributeCode !== null)
            url_ += "attributeCode=" + encodeURIComponent("" + attributeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppItemAttributePriceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppItemAttributePriceDto[]>;
        }));
    }

    protected processGetAppItemPrice(response: HttpResponseBase): Observable<AppItemAttributePriceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppItemAttributePriceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param getAppItemAttributesInputForExtraData_EntityObjectTypeId (optional) 
     * @param getAppItemAttributesInputForExtraData_ItemId (optional) 
     * @param getAppItemAttributesInputForExtraData_ItemEntityId (optional) 
     * @param getAppItemAttributesInputForExtraData_Sorting (optional) 
     * @param getAppItemAttributesInputForExtraData_SkipCount (optional) 
     * @param getAppItemAttributesInputForExtraData_MaxResultCount (optional) 
     * @param currencyCode (optional) 
     * @param itemId (optional) 
     * @param getAppItemAttributesInputForCategories_Sorting (optional) 
     * @param getAppItemAttributesInputForCategories_SkipCount (optional) 
     * @param getAppItemAttributesInputForCategories_MaxResultCount (optional) 
     * @param getAppItemAttributesInputForClassifications_Sorting (optional) 
     * @param getAppItemAttributesInputForClassifications_SkipCount (optional) 
     * @param getAppItemAttributesInputForClassifications_MaxResultCount (optional) 
     * @param getAppItemAttributesInputForDepartments_Sorting (optional) 
     * @param getAppItemAttributesInputForDepartments_SkipCount (optional) 
     * @param getAppItemAttributesInputForDepartments_MaxResultCount (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemForView(getAppItemAttributesInputForExtraData_EntityObjectTypeId: number | undefined, getAppItemAttributesInputForExtraData_recommandedOrAdditional: RecommandedOrAdditional, getAppItemAttributesInputForExtraData_ItemId: number | undefined, getAppItemAttributesInputForExtraData_ItemEntityId: number | undefined, getAppItemAttributesInputForExtraData_Sorting: string | null | undefined, getAppItemAttributesInputForExtraData_SkipCount: number | undefined, getAppItemAttributesInputForExtraData_MaxResultCount: number | undefined, currencyCode: string | null | undefined, itemId: number | undefined, getAppItemAttributesInputForCategories_Sorting: string | null | undefined, getAppItemAttributesInputForCategories_SkipCount: number | undefined, getAppItemAttributesInputForCategories_MaxResultCount: number | undefined, getAppItemAttributesInputForClassifications_Sorting: string | null | undefined, getAppItemAttributesInputForClassifications_SkipCount: number | undefined, getAppItemAttributesInputForClassifications_MaxResultCount: number | undefined, getAppItemAttributesInputForDepartments_Sorting: string | null | undefined, getAppItemAttributesInputForDepartments_SkipCount: number | undefined, getAppItemAttributesInputForDepartments_MaxResultCount: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAppItemDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemForView?";
        if (getAppItemAttributesInputForExtraData_EntityObjectTypeId === null)
            throw new Error("The parameter 'getAppItemAttributesInputForExtraData_EntityObjectTypeId' cannot be null.");
        else if (getAppItemAttributesInputForExtraData_EntityObjectTypeId !== undefined)
            url_ += "GetAppItemAttributesInputForExtraData.EntityObjectTypeId=" + encodeURIComponent("" + getAppItemAttributesInputForExtraData_EntityObjectTypeId) + "&";
        if (getAppItemAttributesInputForExtraData_recommandedOrAdditional === undefined || getAppItemAttributesInputForExtraData_recommandedOrAdditional === null)
            throw new Error("The parameter 'getAppItemAttributesInputForExtraData_recommandedOrAdditional' must be defined and cannot be null.");
        else
            url_ += "GetAppItemAttributesInputForExtraData.recommandedOrAdditional=" + encodeURIComponent("" + getAppItemAttributesInputForExtraData_recommandedOrAdditional) + "&";
        if (getAppItemAttributesInputForExtraData_ItemId === null)
            throw new Error("The parameter 'getAppItemAttributesInputForExtraData_ItemId' cannot be null.");
        else if (getAppItemAttributesInputForExtraData_ItemId !== undefined)
            url_ += "GetAppItemAttributesInputForExtraData.ItemId=" + encodeURIComponent("" + getAppItemAttributesInputForExtraData_ItemId) + "&";
        if (getAppItemAttributesInputForExtraData_ItemEntityId === null)
            throw new Error("The parameter 'getAppItemAttributesInputForExtraData_ItemEntityId' cannot be null.");
        else if (getAppItemAttributesInputForExtraData_ItemEntityId !== undefined)
            url_ += "GetAppItemAttributesInputForExtraData.ItemEntityId=" + encodeURIComponent("" + getAppItemAttributesInputForExtraData_ItemEntityId) + "&";
        if (getAppItemAttributesInputForExtraData_Sorting !== undefined && getAppItemAttributesInputForExtraData_Sorting !== null)
            url_ += "GetAppItemAttributesInputForExtraData.Sorting=" + encodeURIComponent("" + getAppItemAttributesInputForExtraData_Sorting) + "&";
        if (getAppItemAttributesInputForExtraData_SkipCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForExtraData_SkipCount' cannot be null.");
        else if (getAppItemAttributesInputForExtraData_SkipCount !== undefined)
            url_ += "GetAppItemAttributesInputForExtraData.SkipCount=" + encodeURIComponent("" + getAppItemAttributesInputForExtraData_SkipCount) + "&";
        if (getAppItemAttributesInputForExtraData_MaxResultCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForExtraData_MaxResultCount' cannot be null.");
        else if (getAppItemAttributesInputForExtraData_MaxResultCount !== undefined)
            url_ += "GetAppItemAttributesInputForExtraData.MaxResultCount=" + encodeURIComponent("" + getAppItemAttributesInputForExtraData_MaxResultCount) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (getAppItemAttributesInputForCategories_Sorting !== undefined && getAppItemAttributesInputForCategories_Sorting !== null)
            url_ += "GetAppItemAttributesInputForCategories.Sorting=" + encodeURIComponent("" + getAppItemAttributesInputForCategories_Sorting) + "&";
        if (getAppItemAttributesInputForCategories_SkipCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForCategories_SkipCount' cannot be null.");
        else if (getAppItemAttributesInputForCategories_SkipCount !== undefined)
            url_ += "GetAppItemAttributesInputForCategories.SkipCount=" + encodeURIComponent("" + getAppItemAttributesInputForCategories_SkipCount) + "&";
        if (getAppItemAttributesInputForCategories_MaxResultCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForCategories_MaxResultCount' cannot be null.");
        else if (getAppItemAttributesInputForCategories_MaxResultCount !== undefined)
            url_ += "GetAppItemAttributesInputForCategories.MaxResultCount=" + encodeURIComponent("" + getAppItemAttributesInputForCategories_MaxResultCount) + "&";
        if (getAppItemAttributesInputForClassifications_Sorting !== undefined && getAppItemAttributesInputForClassifications_Sorting !== null)
            url_ += "GetAppItemAttributesInputForClassifications.Sorting=" + encodeURIComponent("" + getAppItemAttributesInputForClassifications_Sorting) + "&";
        if (getAppItemAttributesInputForClassifications_SkipCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForClassifications_SkipCount' cannot be null.");
        else if (getAppItemAttributesInputForClassifications_SkipCount !== undefined)
            url_ += "GetAppItemAttributesInputForClassifications.SkipCount=" + encodeURIComponent("" + getAppItemAttributesInputForClassifications_SkipCount) + "&";
        if (getAppItemAttributesInputForClassifications_MaxResultCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForClassifications_MaxResultCount' cannot be null.");
        else if (getAppItemAttributesInputForClassifications_MaxResultCount !== undefined)
            url_ += "GetAppItemAttributesInputForClassifications.MaxResultCount=" + encodeURIComponent("" + getAppItemAttributesInputForClassifications_MaxResultCount) + "&";
        if (getAppItemAttributesInputForDepartments_Sorting !== undefined && getAppItemAttributesInputForDepartments_Sorting !== null)
            url_ += "GetAppItemAttributesInputForDepartments.Sorting=" + encodeURIComponent("" + getAppItemAttributesInputForDepartments_Sorting) + "&";
        if (getAppItemAttributesInputForDepartments_SkipCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForDepartments_SkipCount' cannot be null.");
        else if (getAppItemAttributesInputForDepartments_SkipCount !== undefined)
            url_ += "GetAppItemAttributesInputForDepartments.SkipCount=" + encodeURIComponent("" + getAppItemAttributesInputForDepartments_SkipCount) + "&";
        if (getAppItemAttributesInputForDepartments_MaxResultCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForDepartments_MaxResultCount' cannot be null.");
        else if (getAppItemAttributesInputForDepartments_MaxResultCount !== undefined)
            url_ += "GetAppItemAttributesInputForDepartments.MaxResultCount=" + encodeURIComponent("" + getAppItemAttributesInputForDepartments_MaxResultCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppItemDetailForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppItemDetailForViewDto>;
        }));
    }

    protected processGetAppItemForView(response: HttpResponseBase): Observable<GetAppItemDetailForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppItemDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemCategoriesWithPaging(itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemCategoriesWithPaging?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemCategoriesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemCategoriesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
        }));
    }

    protected processGetAppItemCategoriesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemClassificationsWithPaging(itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemClassificationsWithPaging?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemClassificationsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemClassificationsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityClassificationDto>;
        }));
    }

    protected processGetAppItemClassificationsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemDepartmentsWithPaging(itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemDepartmentsWithPaging?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemDepartmentsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemDepartmentsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
        }));
    }

    protected processGetAppItemDepartmentsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemDepartmentsWithFullNameWithPaging(itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemDepartmentsWithFullNameWithPaging?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemDepartmentsWithFullNameWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemDepartmentsWithFullNameWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityCategoryDto>;
        }));
    }

    protected processGetAppItemDepartmentsWithFullNameWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemCategoriesNamesWithPaging(itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfString> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemCategoriesNamesWithPaging?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemCategoriesNamesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemCategoriesNamesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfString>;
        }));
    }

    protected processGetAppItemCategoriesNamesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemClassificationsNamesWithPaging(itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfString> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemClassificationsNamesWithPaging?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemClassificationsNamesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemClassificationsNamesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfString>;
        }));
    }

    protected processGetAppItemClassificationsNamesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemDepartmentsNamesWithPaging(itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfString> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemDepartmentsNamesWithPaging?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemDepartmentsNamesWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemDepartmentsNamesWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfString>;
        }));
    }

    protected processGetAppItemDepartmentsNamesWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityObjectTypeId (optional) 
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemAttachmentsWithPaging(entityObjectTypeId: number | undefined, recommandedOrAdditional: RecommandedOrAdditional, itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppEntityAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemAttachmentsWithPaging?";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (recommandedOrAdditional === undefined || recommandedOrAdditional === null)
            throw new Error("The parameter 'recommandedOrAdditional' must be defined and cannot be null.");
        else
            url_ += "recommandedOrAdditional=" + encodeURIComponent("" + recommandedOrAdditional) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemAttachmentsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemAttachmentsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppEntityAttachmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppEntityAttachmentDto>;
        }));
    }

    protected processGetAppItemAttachmentsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfAppEntityAttachmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppEntityAttachmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityObjectTypeId (optional) 
     * @param itemId (optional) 
     * @param itemEntityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemExtraDataWithPaging(entityObjectTypeId: number | undefined, recommandedOrAdditional: RecommandedOrAdditional, itemId: number | undefined, itemEntityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfExtraDataAttrDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemExtraDataWithPaging?";
        if (entityObjectTypeId === null)
            throw new Error("The parameter 'entityObjectTypeId' cannot be null.");
        else if (entityObjectTypeId !== undefined)
            url_ += "EntityObjectTypeId=" + encodeURIComponent("" + entityObjectTypeId) + "&";
        if (recommandedOrAdditional === undefined || recommandedOrAdditional === null)
            throw new Error("The parameter 'recommandedOrAdditional' must be defined and cannot be null.");
        else
            url_ += "recommandedOrAdditional=" + encodeURIComponent("" + recommandedOrAdditional) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemEntityId === null)
            throw new Error("The parameter 'itemEntityId' cannot be null.");
        else if (itemEntityId !== undefined)
            url_ += "ItemEntityId=" + encodeURIComponent("" + itemEntityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemExtraDataWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemExtraDataWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfExtraDataAttrDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfExtraDataAttrDto>;
        }));
    }

    protected processGetAppItemExtraDataWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfExtraDataAttrDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExtraDataAttrDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param getAppItemAttributesInputForCategories_Sorting (optional) 
     * @param getAppItemAttributesInputForCategories_SkipCount (optional) 
     * @param getAppItemAttributesInputForCategories_MaxResultCount (optional) 
     * @param getAppItemAttributesInputForClassifications_Sorting (optional) 
     * @param getAppItemAttributesInputForClassifications_SkipCount (optional) 
     * @param getAppItemAttributesInputForClassifications_MaxResultCount (optional) 
     * @param getAppItemAttributesInputForDepartments_Sorting (optional) 
     * @param getAppItemAttributesInputForDepartments_SkipCount (optional) 
     * @param getAppItemAttributesInputForDepartments_MaxResultCount (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAppItemForEdit(itemId: number | undefined, getAppItemAttributesInputForCategories_Sorting: string | null | undefined, getAppItemAttributesInputForCategories_SkipCount: number | undefined, getAppItemAttributesInputForCategories_MaxResultCount: number | undefined, getAppItemAttributesInputForClassifications_Sorting: string | null | undefined, getAppItemAttributesInputForClassifications_SkipCount: number | undefined, getAppItemAttributesInputForClassifications_MaxResultCount: number | undefined, getAppItemAttributesInputForDepartments_Sorting: string | null | undefined, getAppItemAttributesInputForDepartments_SkipCount: number | undefined, getAppItemAttributesInputForDepartments_MaxResultCount: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAppItemForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemForEdit?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (getAppItemAttributesInputForCategories_Sorting !== undefined && getAppItemAttributesInputForCategories_Sorting !== null)
            url_ += "GetAppItemAttributesInputForCategories.Sorting=" + encodeURIComponent("" + getAppItemAttributesInputForCategories_Sorting) + "&";
        if (getAppItemAttributesInputForCategories_SkipCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForCategories_SkipCount' cannot be null.");
        else if (getAppItemAttributesInputForCategories_SkipCount !== undefined)
            url_ += "GetAppItemAttributesInputForCategories.SkipCount=" + encodeURIComponent("" + getAppItemAttributesInputForCategories_SkipCount) + "&";
        if (getAppItemAttributesInputForCategories_MaxResultCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForCategories_MaxResultCount' cannot be null.");
        else if (getAppItemAttributesInputForCategories_MaxResultCount !== undefined)
            url_ += "GetAppItemAttributesInputForCategories.MaxResultCount=" + encodeURIComponent("" + getAppItemAttributesInputForCategories_MaxResultCount) + "&";
        if (getAppItemAttributesInputForClassifications_Sorting !== undefined && getAppItemAttributesInputForClassifications_Sorting !== null)
            url_ += "GetAppItemAttributesInputForClassifications.Sorting=" + encodeURIComponent("" + getAppItemAttributesInputForClassifications_Sorting) + "&";
        if (getAppItemAttributesInputForClassifications_SkipCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForClassifications_SkipCount' cannot be null.");
        else if (getAppItemAttributesInputForClassifications_SkipCount !== undefined)
            url_ += "GetAppItemAttributesInputForClassifications.SkipCount=" + encodeURIComponent("" + getAppItemAttributesInputForClassifications_SkipCount) + "&";
        if (getAppItemAttributesInputForClassifications_MaxResultCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForClassifications_MaxResultCount' cannot be null.");
        else if (getAppItemAttributesInputForClassifications_MaxResultCount !== undefined)
            url_ += "GetAppItemAttributesInputForClassifications.MaxResultCount=" + encodeURIComponent("" + getAppItemAttributesInputForClassifications_MaxResultCount) + "&";
        if (getAppItemAttributesInputForDepartments_Sorting !== undefined && getAppItemAttributesInputForDepartments_Sorting !== null)
            url_ += "GetAppItemAttributesInputForDepartments.Sorting=" + encodeURIComponent("" + getAppItemAttributesInputForDepartments_Sorting) + "&";
        if (getAppItemAttributesInputForDepartments_SkipCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForDepartments_SkipCount' cannot be null.");
        else if (getAppItemAttributesInputForDepartments_SkipCount !== undefined)
            url_ += "GetAppItemAttributesInputForDepartments.SkipCount=" + encodeURIComponent("" + getAppItemAttributesInputForDepartments_SkipCount) + "&";
        if (getAppItemAttributesInputForDepartments_MaxResultCount === null)
            throw new Error("The parameter 'getAppItemAttributesInputForDepartments_MaxResultCount' cannot be null.");
        else if (getAppItemAttributesInputForDepartments_MaxResultCount !== undefined)
            url_ += "GetAppItemAttributesInputForDepartments.MaxResultCount=" + encodeURIComponent("" + getAppItemAttributesInputForDepartments_MaxResultCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppItemForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppItemForEditOutput>;
        }));
    }

    protected processGetAppItemForEdit(response: HttpResponseBase): Observable<GetAppItemForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppItemForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppItemDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishProduct(body: PublishItemOptions | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/PublishProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPublishProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appItemId (optional) 
     * @return Success
     */
    makeProductPrivate(appItemId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/MakeProductPrivate?";
        if (appItemId === null)
            throw new Error("The parameter 'appItemId' cannot be null.");
        else if (appItemId !== undefined)
            url_ += "appItemId=" + encodeURIComponent("" + appItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeProductPrivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeProductPrivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMakeProductPrivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appItemId (optional) 
     * @return Success
     */
    syncProduct(appItemId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/SyncProduct?";
        if (appItemId === null)
            throw new Error("The parameter 'appItemId' cannot be null.");
        else if (appItemId !== undefined)
            url_ += "appItemId=" + encodeURIComponent("" + appItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appItemId (optional) 
     * @return Success
     */
    unHideProduct(appItemId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/UnHideProduct?";
        if (appItemId === null)
            throw new Error("The parameter 'appItemId' cannot be null.");
        else if (appItemId !== undefined)
            url_ += "appItemId=" + encodeURIComponent("" + appItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnHideProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnHideProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnHideProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appItemId (optional) 
     * @return Success
     */
    hideProduct(appItemId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/HideProduct?";
        if (appItemId === null)
            throw new Error("The parameter 'appItemId' cannot be null.");
        else if (appItemId !== undefined)
            url_ += "appItemId=" + encodeURIComponent("" + appItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHideProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHideProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHideProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shareProduct(body: SharingItemOptions | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/ShareProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShareProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShareProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processShareProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPublishItemOptions(id: number | undefined): Observable<PublishItemOptions> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetPublishItemOptions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublishItemOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublishItemOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PublishItemOptions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PublishItemOptions>;
        }));
    }

    protected processGetPublishItemOptions(response: HttpResponseBase): Observable<PublishItemOptions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PublishItemOptions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getAppItemsToExcel(filter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetAppItemsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppItemsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unPublishProduct(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/UnPublishProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnPublishProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnPublishProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnPublishProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @return Success
     */
    getVariations(itemId: number | undefined): Observable<AppItemVariationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetVariations?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVariations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVariations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppItemVariationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppItemVariationDto[]>;
        }));
    }

    protected processGetVariations(response: HttpResponseBase): Observable<AppItemVariationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppItemVariationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productTypeId (optional) 
     * @return Success
     */
    getExcelTemplate(productTypeId: number | null | undefined): Observable<ExcelTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetExcelTemplate?";
        if (productTypeId !== undefined && productTypeId !== null)
            url_ += "productTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExcelTemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExcelTemplateDto>;
        }));
    }

    protected processGetExcelTemplate(response: HttpResponseBase): Observable<ExcelTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExcelTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param guidFile (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateExcel(guidFile: string | null | undefined, body: string[] | null | undefined): Observable<AppItemExcelResultsDTO> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/ValidateExcel?";
        if (guidFile !== undefined && guidFile !== null)
            url_ += "guidFile=" + encodeURIComponent("" + guidFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppItemExcelResultsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppItemExcelResultsDTO>;
        }));
    }

    protected processValidateExcel(response: HttpResponseBase): Observable<AppItemExcelResultsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppItemExcelResultsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryName (optional) 
     * @param totalCount (optional) 
     * @param items (optional) 
     * @return Success
     */
    getCategoryId(categoryName: string | null | undefined, totalCount: number | undefined, items: TreeNodeOfGetSycEntityObjectCategoryForViewDto[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetCategoryId?";
        if (categoryName !== undefined && categoryName !== null)
            url_ += "categoryName=" + encodeURIComponent("" + categoryName) + "&";
        if (totalCount === null)
            throw new Error("The parameter 'totalCount' cannot be null.");
        else if (totalCount !== undefined)
            url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
        if (items !== undefined && items !== null)
            items && items.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCategoryId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param className (optional) 
     * @param totalCount (optional) 
     * @param items (optional) 
     * @return Success
     */
    getClassId(className: string | null | undefined, totalCount: number | undefined, items: TreeNodeOfGetSycEntityObjectClassificationForViewDto[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetClassId?";
        if (className !== undefined && className !== null)
            url_ += "className=" + encodeURIComponent("" + className) + "&";
        if (totalCount === null)
            throw new Error("The parameter 'totalCount' cannot be null.");
        else if (totalCount !== undefined)
            url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
        if (items !== undefined && items !== null)
            items && items.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetClassId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param typeName (optional) 
     * @param lookupLabelDtos (optional) 
     * @return Success
     */
    getTypeId(typeName: string | null | undefined, lookupLabelDtos: CurrencyInfoDto[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetTypeId?";
        if (typeName !== undefined && typeName !== null)
            url_ += "typeName=" + encodeURIComponent("" + typeName) + "&";
        if (lookupLabelDtos !== undefined && lookupLabelDtos !== null)
            lookupLabelDtos && lookupLabelDtos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "lookupLabelDtos[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getItemCopyCode(code: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetItemCopyCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemCopyCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemCopyCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetItemCopyCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addClassifications(body: AppItemExcelDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/AddClassifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClassifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClassifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddClassifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCategories(body: AppItemExcelDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/AddCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveFromExcel(body: AppItemExcelResultsDTO | undefined): Observable<ExcelLogDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/SaveFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExcelLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExcelLogDto>;
        }));
    }

    protected processSaveFromExcel(response: HttpResponseBase): Observable<ExcelLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExcelLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param lUpdateSeq (optional) 
     * @return Success
     */
    generateProductCode(productId: number | undefined, lUpdateSeq: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GenerateProductCode?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (lUpdateSeq === null)
            throw new Error("The parameter 'lUpdateSeq' cannot be null.");
        else if (lUpdateSeq !== undefined)
            url_ += "lUpdateSeq=" + encodeURIComponent("" + lUpdateSeq) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateProductCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateProductCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @param name (optional) 
     * @param segmentNumber (optional) 
     * @param segmentHeader (optional) 
     * @param segmentMask (optional) 
     * @param segmentLength (optional) 
     * @param segmentType (optional) 
     * @param isAutoGenerated (optional) 
     * @param isEditable (optional) 
     * @param isVisible (optional) 
     * @param codeStartingValue (optional) 
     * @param lookOrFieldName (optional) 
     * @param sycIdentifierDefinitionId (optional) 
     * @param id (optional) 
     * @param lUpdateSequence (optional) 
     * @return Success
     */
    getProductCode(code: string | null | undefined, name: string | null | undefined, segmentNumber: number | undefined, segmentHeader: string | null | undefined, segmentMask: string | null | undefined, segmentLength: number | undefined, segmentType: string | null | undefined, isAutoGenerated: boolean | undefined, isEditable: boolean | undefined, isVisible: boolean | undefined, codeStartingValue: number | undefined, lookOrFieldName: string | null | undefined, sycIdentifierDefinitionId: number | null | undefined, id: number | undefined, lUpdateSequence: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetProductCode?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (segmentNumber === null)
            throw new Error("The parameter 'segmentNumber' cannot be null.");
        else if (segmentNumber !== undefined)
            url_ += "SegmentNumber=" + encodeURIComponent("" + segmentNumber) + "&";
        if (segmentHeader !== undefined && segmentHeader !== null)
            url_ += "SegmentHeader=" + encodeURIComponent("" + segmentHeader) + "&";
        if (segmentMask !== undefined && segmentMask !== null)
            url_ += "SegmentMask=" + encodeURIComponent("" + segmentMask) + "&";
        if (segmentLength === null)
            throw new Error("The parameter 'segmentLength' cannot be null.");
        else if (segmentLength !== undefined)
            url_ += "SegmentLength=" + encodeURIComponent("" + segmentLength) + "&";
        if (segmentType !== undefined && segmentType !== null)
            url_ += "SegmentType=" + encodeURIComponent("" + segmentType) + "&";
        if (isAutoGenerated === null)
            throw new Error("The parameter 'isAutoGenerated' cannot be null.");
        else if (isAutoGenerated !== undefined)
            url_ += "IsAutoGenerated=" + encodeURIComponent("" + isAutoGenerated) + "&";
        if (isEditable === null)
            throw new Error("The parameter 'isEditable' cannot be null.");
        else if (isEditable !== undefined)
            url_ += "IsEditable=" + encodeURIComponent("" + isEditable) + "&";
        if (isVisible === null)
            throw new Error("The parameter 'isVisible' cannot be null.");
        else if (isVisible !== undefined)
            url_ += "IsVisible=" + encodeURIComponent("" + isVisible) + "&";
        if (codeStartingValue === null)
            throw new Error("The parameter 'codeStartingValue' cannot be null.");
        else if (codeStartingValue !== undefined)
            url_ += "CodeStartingValue=" + encodeURIComponent("" + codeStartingValue) + "&";
        if (lookOrFieldName !== undefined && lookOrFieldName !== null)
            url_ += "LookOrFieldName=" + encodeURIComponent("" + lookOrFieldName) + "&";
        if (sycIdentifierDefinitionId !== undefined && sycIdentifierDefinitionId !== null)
            url_ += "SycIdentifierDefinitionId=" + encodeURIComponent("" + sycIdentifierDefinitionId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (lUpdateSequence === null)
            throw new Error("The parameter 'lUpdateSequence' cannot be null.");
        else if (lUpdateSequence !== undefined)
            url_ += "lUpdateSequence=" + encodeURIComponent("" + lUpdateSequence) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetProductCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getProductVariationsTypes(productId: number | undefined): Observable<ProductVariationsType[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetProductVariationsTypes?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductVariationsTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductVariationsTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductVariationsType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductVariationsType[]>;
        }));
    }

    protected processGetProductVariationsTypes(response: HttpResponseBase): Observable<ProductVariationsType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductVariationsType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param identifierId (optional) 
     * @param productCode (optional) 
     * @param productTypeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getVariationsCodes(identifierId: number | undefined, productCode: string | null | undefined, productTypeId: number | undefined, body: VariationItemDto[] | null | undefined): Observable<VariationItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItems/GetVariationsCodes?";
        if (identifierId === null)
            throw new Error("The parameter 'identifierId' cannot be null.");
        else if (identifierId !== undefined)
            url_ += "identifierId=" + encodeURIComponent("" + identifierId) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "productCode=" + encodeURIComponent("" + productCode) + "&";
        if (productTypeId === null)
            throw new Error("The parameter 'productTypeId' cannot be null.");
        else if (productTypeId !== undefined)
            url_ += "productTypeId=" + encodeURIComponent("" + productTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVariationsCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVariationsCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VariationItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VariationItemDto[]>;
        }));
    }

    protected processGetVariationsCodes(response: HttpResponseBase): Observable<VariationItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VariationItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppItemSelectorsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param maxSelectedIdFilter (optional) 
     * @param minSelectedIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, maxSelectedIdFilter: number | null | undefined, minSelectedIdFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppItemSelectorForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItemSelectors/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (keyFilter !== undefined && keyFilter !== null)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&";
        if (maxSelectedIdFilter !== undefined && maxSelectedIdFilter !== null)
            url_ += "MaxSelectedIdFilter=" + encodeURIComponent("" + maxSelectedIdFilter) + "&";
        if (minSelectedIdFilter !== undefined && minSelectedIdFilter !== null)
            url_ += "MinSelectedIdFilter=" + encodeURIComponent("" + minSelectedIdFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppItemSelectorForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppItemSelectorForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppItemSelectorForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppItemSelectorForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppItemSelectorForEdit(id: number | undefined): Observable<GetAppItemSelectorForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppItemSelectors/GetAppItemSelectorForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemSelectorForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemSelectorForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppItemSelectorForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppItemSelectorForEditOutput>;
        }));
    }

    protected processGetAppItemSelectorForEdit(response: HttpResponseBase): Observable<GetAppItemSelectorForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppItemSelectorForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppItemSelectorDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItemSelectors/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional) 
     * @param selectedId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteAllTempWithKey(key: string | undefined, selectedId: number | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemSelectors/DeleteAllTempWithKey?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (selectedId === null)
            throw new Error("The parameter 'selectedId' cannot be null.");
        else if (selectedId !== undefined)
            url_ += "SelectedId=" + encodeURIComponent("" + selectedId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllTempWithKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllTempWithKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllTempWithKey(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional) 
     * @param selectedId (optional) 
     * @param id (optional) 
     * @return Success
     */
    delete(key: string | undefined, selectedId: number | undefined, id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItemSelectors/Delete?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (selectedId === null)
            throw new Error("The parameter 'selectedId' cannot be null.");
        else if (selectedId !== undefined)
            url_ += "SelectedId=" + encodeURIComponent("" + selectedId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional) 
     * @param body (optional) 
     * @return Success
     */
    selectAll(key: string | undefined, body: GetAllAppItemsInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItemSelectors/SelectAll?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSelectAll(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional) 
     * @param body (optional) 
     * @return Success
     */
    invert(key: string | undefined, body: GetAllAppItemsInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItemSelectors/Invert?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processInvert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppItemsListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param noLimit (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, filterType: ItemsListFilterTypesEnum, noLimit: boolean | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppItemsListForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (filterType === undefined || filterType === null)
            throw new Error("The parameter 'filterType' must be defined and cannot be null.");
        else
            url_ += "FilterType=" + encodeURIComponent("" + filterType) + "&";
        if (noLimit === null)
            throw new Error("The parameter 'noLimit' cannot be null.");
        else if (noLimit !== undefined)
            url_ += "NoLimit=" + encodeURIComponent("" + noLimit) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppItemsListForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppItemsListForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppItemsListForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppItemsListForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemsListId (optional) 
     * @return Success
     */
    getItemsListVariations(itemId: number | undefined, itemsListId: number | undefined): Observable<AppItemsListItemVariationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetItemsListVariations?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemsListId === null)
            throw new Error("The parameter 'itemsListId' cannot be null.");
        else if (itemsListId !== undefined)
            url_ += "ItemsListId=" + encodeURIComponent("" + itemsListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemsListVariations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemsListVariations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppItemsListItemVariationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppItemsListItemVariationDto[]>;
        }));
    }

    protected processGetItemsListVariations(response: HttpResponseBase): Observable<AppItemsListItemVariationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppItemsListItemVariationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemId (optional) 
     * @param itemsListId (optional) 
     * @return Success
     */
    getItemsListDetailId(itemId: number | undefined, itemsListId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetItemsListDetailId?";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (itemsListId === null)
            throw new Error("The parameter 'itemsListId' cannot be null.");
        else if (itemsListId !== undefined)
            url_ += "ItemsListId=" + encodeURIComponent("" + itemsListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemsListDetailId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemsListDetailId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetItemsListDetailId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @param itemId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDetails(itemListId: number | undefined, itemId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfCreateOrEditAppItemsListItemDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetDetails?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "ItemListId=" + encodeURIComponent("" + itemListId) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfCreateOrEditAppItemsListItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfCreateOrEditAppItemsListItemDto>;
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<PagedResultDtoOfCreateOrEditAppItemsListItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCreateOrEditAppItemsListItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @param itemId (optional) 
     * @return Success
     */
    getSelectedVariations(itemListId: number | undefined, itemId: number | undefined): Observable<CreateOrEditAppItemsListItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetSelectedVariations?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "ItemListId=" + encodeURIComponent("" + itemListId) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedVariations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedVariations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrEditAppItemsListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrEditAppItemsListItemDto[]>;
        }));
    }

    protected processGetSelectedVariations(response: HttpResponseBase): Observable<CreateOrEditAppItemsListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreateOrEditAppItemsListItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppItemsListForView(id: number | undefined): Observable<GetAppItemsListForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetAppItemsListForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemsListForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemsListForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppItemsListForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppItemsListForEditOutput>;
        }));
    }

    protected processGetAppItemsListForView(response: HttpResponseBase): Observable<GetAppItemsListForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppItemsListForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppItemsListForEdit(id: number | undefined): Observable<GetAppItemsListForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetAppItemsListForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemsListForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemsListForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppItemsListForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppItemsListForEditOutput>;
        }));
    }

    protected processGetAppItemsListForEdit(response: HttpResponseBase): Observable<GetAppItemsListForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppItemsListForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppItemsListDto | undefined): Observable<GetAppItemsListForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppItemsListForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppItemsListForEditOutput>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<GetAppItemsListForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppItemsListForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveState(body: CreateOrEditAppItemsListDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/SaveState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @param status (optional) 
     * @return Success
     */
    changeStatus(itemListId: number | undefined, status: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/ChangeStatus?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @return Success
     */
    getStatus(itemListId: number | undefined): Observable<GetStatusResult> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetStatus?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStatusResult>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<GetStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStatusResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cancel(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/Cancel?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @param key (optional) 
     * @return Success
     */
    saveSelection(itemListId: number | undefined, key: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/SaveSelection?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @param itemId (optional) 
     * @param body (optional) 
     * @return Success
     */
    marItemsAs(itemListId: number | undefined, itemId: number | undefined, body: StateEnum | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/MarItemsAs?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarItemsAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarItemsAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarItemsAs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markManyItemsAs(body: CreateOrEditAppItemsListItemDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/MarkManyItemsAs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkManyItemsAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkManyItemsAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkManyItemsAs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditItem(body: CreateOrEditAppItemsListItemDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/CreateOrEditItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPublishOptions(id: number | undefined): Observable<PublishItemOptions> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetPublishOptions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublishOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublishOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PublishItemOptions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PublishItemOptions>;
        }));
    }

    protected processGetPublishOptions(response: HttpResponseBase): Observable<PublishItemOptions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PublishItemOptions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param inputIds (optional) 
     * @return Success
     */
    deleteItem(inputIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/DeleteItem?";
        if (inputIds !== undefined && inputIds !== null)
            inputIds && inputIds.forEach(item => { url_ += "inputIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getAppItemsListsToExcel(filter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/GetAppItemsListsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppItemsListsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppItemsListsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppItemsListsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publish(body: PublishItemOptions | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/Publish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPublish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @return Success
     */
    unHideItemList(itemListId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/UnHideItemList?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnHideItemList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnHideItemList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnHideItemList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @return Success
     */
    hideItemList(itemListId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/HideItemList?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHideItemList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHideItemList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHideItemList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @return Success
     */
    makeItemListPrivate(itemListId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/MakeItemListPrivate?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeItemListPrivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeItemListPrivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMakeItemListPrivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param itemListId (optional) 
     * @return Success
     */
    syncItemList(itemListId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/SyncItemList?";
        if (itemListId === null)
            throw new Error("The parameter 'itemListId' cannot be null.");
        else if (itemListId !== undefined)
            url_ += "itemListId=" + encodeURIComponent("" + itemListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncItemList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncItemList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncItemList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shareItemList(body: ShareItemListOptions | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/ShareItemList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShareItemList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShareItemList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processShareItemList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unPublish(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppItemsLists/UnPublish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnPublish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnPublish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppItemStockAvailabilityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param typeId (optional) 
     * @return Success
     */
    getExcelTemplate(typeId: number | null | undefined): Observable<ExcelTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItemStockAvailability/GetExcelTemplate?";
        if (typeId !== undefined && typeId !== null)
            url_ += "TypeId=" + encodeURIComponent("" + typeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExcelTemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExcelTemplateDto>;
        }));
    }

    protected processGetExcelTemplate(response: HttpResponseBase): Observable<ExcelTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExcelTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveFromExcel(body: AppItemStockAvailabilityExcelResultsDTO | undefined): Observable<ExcelLogDto> {
        let url_ = this.baseUrl + "/api/services/app/AppItemStockAvailability/SaveFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExcelLogDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExcelLogDto>;
        }));
    }

    protected processSaveFromExcel(response: HttpResponseBase): Observable<ExcelLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExcelLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param guidFile (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateExcel(guidFile: string | null | undefined, body: string[] | null | undefined): Observable<AppItemStockAvailabilityExcelResultsDTO> {
        let url_ = this.baseUrl + "/api/services/app/AppItemStockAvailability/ValidateExcel?";
        if (guidFile !== undefined && guidFile !== null)
            url_ += "guidFile=" + encodeURIComponent("" + guidFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppItemStockAvailabilityExcelResultsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppItemStockAvailabilityExcelResultsDTO>;
        }));
    }

    protected processValidateExcel(response: HttpResponseBase): Observable<AppItemStockAvailabilityExcelResultsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppItemStockAvailabilityExcelResultsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppPostsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param typeFilter (optional) 
     * @param fromCreationDateFilter (optional) 
     * @param toCreationDateFilter (optional) 
     * @param appContactNameFilter (optional) 
     * @param appEntityNameFilter (optional) 
     * @param postId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, typeFilter: PostType | undefined, fromCreationDateFilter: moment.Moment | null | undefined, toCreationDateFilter: moment.Moment | null | undefined, appContactNameFilter: string | null | undefined, appEntityNameFilter: string | null | undefined, postId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppPostForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&";
        if (fromCreationDateFilter !== undefined && fromCreationDateFilter !== null)
            url_ += "FromCreationDateFilter=" + encodeURIComponent(fromCreationDateFilter ? "" + fromCreationDateFilter.toISOString() : "") + "&";
        if (toCreationDateFilter !== undefined && toCreationDateFilter !== null)
            url_ += "ToCreationDateFilter=" + encodeURIComponent(toCreationDateFilter ? "" + toCreationDateFilter.toISOString() : "") + "&";
        if (appContactNameFilter !== undefined && appContactNameFilter !== null)
            url_ += "AppContactNameFilter=" + encodeURIComponent("" + appContactNameFilter) + "&";
        if (appEntityNameFilter !== undefined && appEntityNameFilter !== null)
            url_ += "AppEntityNameFilter=" + encodeURIComponent("" + appEntityNameFilter) + "&";
        if (postId === null)
            throw new Error("The parameter 'postId' cannot be null.");
        else if (postId !== undefined)
            url_ += "PostId=" + encodeURIComponent("" + postId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppPostForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppPostForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppPostForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppPostForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param noOfPosts (optional) 
     * @param noOfDays (optional) 
     * @return Success
     */
    getTopNewsDigest(noOfPosts: number | undefined, noOfDays: number | undefined): Observable<GetAppPostForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetTopNewsDigest?";
        if (noOfPosts === null)
            throw new Error("The parameter 'noOfPosts' cannot be null.");
        else if (noOfPosts !== undefined)
            url_ += "noOfPosts=" + encodeURIComponent("" + noOfPosts) + "&";
        if (noOfDays === null)
            throw new Error("The parameter 'noOfDays' cannot be null.");
        else if (noOfDays !== undefined)
            url_ += "noOfDays=" + encodeURIComponent("" + noOfDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopNewsDigest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopNewsDigest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppPostForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppPostForViewDto[]>;
        }));
    }

    protected processGetTopNewsDigest(response: HttpResponseBase): Observable<GetAppPostForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAppPostForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureAllByID(profilePictureId: string | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetProfilePictureAllByID?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureAllByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureAllByID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureAllByID(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppPostForEdit(id: number | undefined): Observable<GetAppPostForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetAppPostForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPostForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPostForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppPostForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppPostForEditOutput>;
        }));
    }

    protected processGetAppPostForEdit(response: HttpResponseBase): Observable<GetAppPostForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppPostForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppPostForView(id: number | undefined): Observable<GetAppPostForViewOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetAppPostForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPostForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPostForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppPostForViewOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppPostForViewOutput>;
        }));
    }

    protected processGetAppPostForView(response: HttpResponseBase): Observable<GetAppPostForViewOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppPostForViewOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppPostDto | undefined): Observable<GetAppPostForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppPostForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppPostForViewDto>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<GetAppPostForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppPostForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param typeFilter (optional) 
     * @param appContactNameFilter (optional) 
     * @param appEntityNameFilter (optional) 
     * @return Success
     */
    getAppPostsToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, typeFilter: string | null | undefined, appContactNameFilter: string | null | undefined, appEntityNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetAppPostsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (typeFilter !== undefined && typeFilter !== null)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&";
        if (appContactNameFilter !== undefined && appContactNameFilter !== null)
            url_ += "AppContactNameFilter=" + encodeURIComponent("" + appContactNameFilter) + "&";
        if (appEntityNameFilter !== undefined && appEntityNameFilter !== null)
            url_ += "AppEntityNameFilter=" + encodeURIComponent("" + appEntityNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPostsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPostsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppPostsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAppContactForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppPostAppContactLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetAllAppContactForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppContactForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppContactForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppPostAppContactLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppPostAppContactLookupTableDto>;
        }));
    }

    protected processGetAllAppContactForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAppPostAppContactLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppPostAppContactLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAppEntityForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAppPostAppEntityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/GetAllAppEntityForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppEntityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppEntityForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAppPostAppEntityLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAppPostAppEntityLookupTableDto>;
        }));
    }

    protected processGetAllAppEntityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAppPostAppEntityLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppPostAppEntityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param url (optional) 
     * @return Success
     */
    preview(url: string | null | undefined): Observable<LinkPreviewResult> {
        let url_ = this.baseUrl + "/api/services/app/AppPosts/Preview?";
        if (url !== undefined && url !== null)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LinkPreviewResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LinkPreviewResult>;
        }));
    }

    protected processPreview(response: HttpResponseBase): Observable<LinkPreviewResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkPreviewResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppSizeScaleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param parentId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, parentId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppSizeScaleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppSizeScale/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppSizeScaleForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppSizeScaleForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppSizeScaleForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppSizeScaleForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sizeScaleId (optional) 
     * @return Success
     */
    getSizeScaleForEdit(sizeScaleId: number | undefined): Observable<AppSizeScaleForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/AppSizeScale/GetSizeScaleForEdit?";
        if (sizeScaleId === null)
            throw new Error("The parameter 'sizeScaleId' cannot be null.");
        else if (sizeScaleId !== undefined)
            url_ += "sizeScaleId=" + encodeURIComponent("" + sizeScaleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSizeScaleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSizeScaleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSizeScaleForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSizeScaleForEditDto>;
        }));
    }

    protected processGetSizeScaleForEdit(response: HttpResponseBase): Observable<AppSizeScaleForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSizeScaleForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAppSizeScale(body: AppSizeScaleForEditDto | undefined): Observable<AppSizeScaleForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/AppSizeScale/CreateOrEditAppSizeScale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAppSizeScale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAppSizeScale(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSizeScaleForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSizeScaleForEditDto>;
        }));
    }

    protected processCreateOrEditAppSizeScale(response: HttpResponseBase): Observable<AppSizeScaleForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSizeScaleForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppTenantPlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxAddDateFilter (optional) 
     * @param minAddDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param sycPlanNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxAddDateFilter: moment.Moment | null | undefined, minAddDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, sycPlanNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppTenantPlanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantPlans/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxAddDateFilter !== undefined && maxAddDateFilter !== null)
            url_ += "MaxAddDateFilter=" + encodeURIComponent(maxAddDateFilter ? "" + maxAddDateFilter.toISOString() : "") + "&";
        if (minAddDateFilter !== undefined && minAddDateFilter !== null)
            url_ += "MinAddDateFilter=" + encodeURIComponent(minAddDateFilter ? "" + minAddDateFilter.toISOString() : "") + "&";
        if (maxEndDateFilter !== undefined && maxEndDateFilter !== null)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toISOString() : "") + "&";
        if (minEndDateFilter !== undefined && minEndDateFilter !== null)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toISOString() : "") + "&";
        if (maxStartDateFilter !== undefined && maxStartDateFilter !== null)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toISOString() : "") + "&";
        if (minStartDateFilter !== undefined && minStartDateFilter !== null)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toISOString() : "") + "&";
        if (sycPlanNameFilter !== undefined && sycPlanNameFilter !== null)
            url_ += "SycPlanNameFilter=" + encodeURIComponent("" + sycPlanNameFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppTenantPlanForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppTenantPlanForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppTenantPlanForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppTenantPlanForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppTenantPlanForView(id: number | undefined): Observable<GetAppTenantPlanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantPlans/GetAppTenantPlanForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTenantPlanForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTenantPlanForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppTenantPlanForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppTenantPlanForViewDto>;
        }));
    }

    protected processGetAppTenantPlanForView(response: HttpResponseBase): Observable<GetAppTenantPlanForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppTenantPlanForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppTenantPlanForEdit(id: number | undefined): Observable<GetAppTenantPlanForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantPlans/GetAppTenantPlanForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTenantPlanForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTenantPlanForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppTenantPlanForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppTenantPlanForEditOutput>;
        }));
    }

    protected processGetAppTenantPlanForEdit(response: HttpResponseBase): Observable<GetAppTenantPlanForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppTenantPlanForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppTenantPlanDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantPlans/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantPlans/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxAddDateFilter (optional) 
     * @param minAddDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param sycPlanNameFilter (optional) 
     * @return Success
     */
    getAppTenantPlansToExcel(filter: string | null | undefined, maxAddDateFilter: moment.Moment | null | undefined, minAddDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, sycPlanNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantPlans/GetAppTenantPlansToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxAddDateFilter !== undefined && maxAddDateFilter !== null)
            url_ += "MaxAddDateFilter=" + encodeURIComponent(maxAddDateFilter ? "" + maxAddDateFilter.toISOString() : "") + "&";
        if (minAddDateFilter !== undefined && minAddDateFilter !== null)
            url_ += "MinAddDateFilter=" + encodeURIComponent(minAddDateFilter ? "" + minAddDateFilter.toISOString() : "") + "&";
        if (maxEndDateFilter !== undefined && maxEndDateFilter !== null)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toISOString() : "") + "&";
        if (minEndDateFilter !== undefined && minEndDateFilter !== null)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toISOString() : "") + "&";
        if (maxStartDateFilter !== undefined && maxStartDateFilter !== null)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toISOString() : "") + "&";
        if (minStartDateFilter !== undefined && minStartDateFilter !== null)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toISOString() : "") + "&";
        if (sycPlanNameFilter !== undefined && sycPlanNameFilter !== null)
            url_ += "SycPlanNameFilter=" + encodeURIComponent("" + sycPlanNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTenantPlansToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTenantPlansToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppTenantPlansToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycPlanForTableDropdown(): Observable<AppTenantPlanSycPlanLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantPlans/GetAllSycPlanForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycPlanForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycPlanForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppTenantPlanSycPlanLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppTenantPlanSycPlanLookupTableDto[]>;
        }));
    }

    protected processGetAllSycPlanForTableDropdown(response: HttpResponseBase): Observable<AppTenantPlanSycPlanLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppTenantPlanSycPlanLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppTenantsActivitiesLogsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxActivityDateFilter (optional) 
     * @param minActivityDateFilter (optional) 
     * @param maxUnitsFilter (optional) 
     * @param minUnitsFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param billedFilter (optional) 
     * @param isManualFilter (optional) 
     * @param invoiceNumberFilter (optional) 
     * @param maxInvoiceDateFilter (optional) 
     * @param minInvoiceDateFilter (optional) 
     * @param sycServiceCodeFilter (optional) 
     * @param sycApplicationNameFilter (optional) 
     * @param appTransactionCodeFilter (optional) 
     * @param sycPlanNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxActivityDateFilter: moment.Moment | null | undefined, minActivityDateFilter: moment.Moment | null | undefined, maxUnitsFilter: number | null | undefined, minUnitsFilter: number | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxAmountFilter: number | null | undefined, minAmountFilter: number | null | undefined, billedFilter: number | null | undefined, isManualFilter: number | null | undefined, invoiceNumberFilter: string | null | undefined, maxInvoiceDateFilter: moment.Moment | null | undefined, minInvoiceDateFilter: moment.Moment | null | undefined, sycServiceCodeFilter: string | null | undefined, sycApplicationNameFilter: string | null | undefined, appTransactionCodeFilter: string | null | undefined, sycPlanNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxActivityDateFilter !== undefined && maxActivityDateFilter !== null)
            url_ += "MaxActivityDateFilter=" + encodeURIComponent(maxActivityDateFilter ? "" + maxActivityDateFilter.toISOString() : "") + "&";
        if (minActivityDateFilter !== undefined && minActivityDateFilter !== null)
            url_ += "MinActivityDateFilter=" + encodeURIComponent(minActivityDateFilter ? "" + minActivityDateFilter.toISOString() : "") + "&";
        if (maxUnitsFilter !== undefined && maxUnitsFilter !== null)
            url_ += "MaxUnitsFilter=" + encodeURIComponent("" + maxUnitsFilter) + "&";
        if (minUnitsFilter !== undefined && minUnitsFilter !== null)
            url_ += "MinUnitsFilter=" + encodeURIComponent("" + minUnitsFilter) + "&";
        if (maxUnitPriceFilter !== undefined && maxUnitPriceFilter !== null)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter !== undefined && minUnitPriceFilter !== null)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxAmountFilter !== undefined && maxAmountFilter !== null)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&";
        if (minAmountFilter !== undefined && minAmountFilter !== null)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&";
        if (billedFilter !== undefined && billedFilter !== null)
            url_ += "BilledFilter=" + encodeURIComponent("" + billedFilter) + "&";
        if (isManualFilter !== undefined && isManualFilter !== null)
            url_ += "IsManualFilter=" + encodeURIComponent("" + isManualFilter) + "&";
        if (invoiceNumberFilter !== undefined && invoiceNumberFilter !== null)
            url_ += "InvoiceNumberFilter=" + encodeURIComponent("" + invoiceNumberFilter) + "&";
        if (maxInvoiceDateFilter !== undefined && maxInvoiceDateFilter !== null)
            url_ += "MaxInvoiceDateFilter=" + encodeURIComponent(maxInvoiceDateFilter ? "" + maxInvoiceDateFilter.toISOString() : "") + "&";
        if (minInvoiceDateFilter !== undefined && minInvoiceDateFilter !== null)
            url_ += "MinInvoiceDateFilter=" + encodeURIComponent(minInvoiceDateFilter ? "" + minInvoiceDateFilter.toISOString() : "") + "&";
        if (sycServiceCodeFilter !== undefined && sycServiceCodeFilter !== null)
            url_ += "SycServiceCodeFilter=" + encodeURIComponent("" + sycServiceCodeFilter) + "&";
        if (sycApplicationNameFilter !== undefined && sycApplicationNameFilter !== null)
            url_ += "SycApplicationNameFilter=" + encodeURIComponent("" + sycApplicationNameFilter) + "&";
        if (appTransactionCodeFilter !== undefined && appTransactionCodeFilter !== null)
            url_ += "AppTransactionCodeFilter=" + encodeURIComponent("" + appTransactionCodeFilter) + "&";
        if (sycPlanNameFilter !== undefined && sycPlanNameFilter !== null)
            url_ += "SycPlanNameFilter=" + encodeURIComponent("" + sycPlanNameFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppTenantsActivitiesLogForView(id: number | undefined): Observable<GetAppTenantsActivitiesLogForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAppTenantsActivitiesLogForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTenantsActivitiesLogForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTenantsActivitiesLogForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppTenantsActivitiesLogForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppTenantsActivitiesLogForViewDto>;
        }));
    }

    protected processGetAppTenantsActivitiesLogForView(response: HttpResponseBase): Observable<GetAppTenantsActivitiesLogForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppTenantsActivitiesLogForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppTenantsActivitiesLogForEdit(id: number | undefined): Observable<GetAppTenantsActivitiesLogForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAppTenantsActivitiesLogForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTenantsActivitiesLogForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTenantsActivitiesLogForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppTenantsActivitiesLogForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppTenantsActivitiesLogForEditOutput>;
        }));
    }

    protected processGetAppTenantsActivitiesLogForEdit(response: HttpResponseBase): Observable<GetAppTenantsActivitiesLogForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppTenantsActivitiesLogForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppTenantsActivitiesLogDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxActivityDateFilter (optional) 
     * @param minActivityDateFilter (optional) 
     * @param maxUnitsFilter (optional) 
     * @param minUnitsFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param billedFilter (optional) 
     * @param isManualFilter (optional) 
     * @param invoiceNumberFilter (optional) 
     * @param maxInvoiceDateFilter (optional) 
     * @param minInvoiceDateFilter (optional) 
     * @param sycServiceCodeFilter (optional) 
     * @param sycApplicationNameFilter (optional) 
     * @param appTransactionCodeFilter (optional) 
     * @param sycPlanNameFilter (optional) 
     * @return Success
     */
    getAppTenantsActivitiesLogsToExcel(filter: string | null | undefined, maxActivityDateFilter: moment.Moment | null | undefined, minActivityDateFilter: moment.Moment | null | undefined, maxUnitsFilter: number | null | undefined, minUnitsFilter: number | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxAmountFilter: number | null | undefined, minAmountFilter: number | null | undefined, billedFilter: number | null | undefined, isManualFilter: number | null | undefined, invoiceNumberFilter: string | null | undefined, maxInvoiceDateFilter: moment.Moment | null | undefined, minInvoiceDateFilter: moment.Moment | null | undefined, sycServiceCodeFilter: string | null | undefined, sycApplicationNameFilter: string | null | undefined, appTransactionCodeFilter: string | null | undefined, sycPlanNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAppTenantsActivitiesLogsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxActivityDateFilter !== undefined && maxActivityDateFilter !== null)
            url_ += "MaxActivityDateFilter=" + encodeURIComponent(maxActivityDateFilter ? "" + maxActivityDateFilter.toISOString() : "") + "&";
        if (minActivityDateFilter !== undefined && minActivityDateFilter !== null)
            url_ += "MinActivityDateFilter=" + encodeURIComponent(minActivityDateFilter ? "" + minActivityDateFilter.toISOString() : "") + "&";
        if (maxUnitsFilter !== undefined && maxUnitsFilter !== null)
            url_ += "MaxUnitsFilter=" + encodeURIComponent("" + maxUnitsFilter) + "&";
        if (minUnitsFilter !== undefined && minUnitsFilter !== null)
            url_ += "MinUnitsFilter=" + encodeURIComponent("" + minUnitsFilter) + "&";
        if (maxUnitPriceFilter !== undefined && maxUnitPriceFilter !== null)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter !== undefined && minUnitPriceFilter !== null)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxAmountFilter !== undefined && maxAmountFilter !== null)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&";
        if (minAmountFilter !== undefined && minAmountFilter !== null)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&";
        if (billedFilter !== undefined && billedFilter !== null)
            url_ += "BilledFilter=" + encodeURIComponent("" + billedFilter) + "&";
        if (isManualFilter !== undefined && isManualFilter !== null)
            url_ += "IsManualFilter=" + encodeURIComponent("" + isManualFilter) + "&";
        if (invoiceNumberFilter !== undefined && invoiceNumberFilter !== null)
            url_ += "InvoiceNumberFilter=" + encodeURIComponent("" + invoiceNumberFilter) + "&";
        if (maxInvoiceDateFilter !== undefined && maxInvoiceDateFilter !== null)
            url_ += "MaxInvoiceDateFilter=" + encodeURIComponent(maxInvoiceDateFilter ? "" + maxInvoiceDateFilter.toISOString() : "") + "&";
        if (minInvoiceDateFilter !== undefined && minInvoiceDateFilter !== null)
            url_ += "MinInvoiceDateFilter=" + encodeURIComponent(minInvoiceDateFilter ? "" + minInvoiceDateFilter.toISOString() : "") + "&";
        if (sycServiceCodeFilter !== undefined && sycServiceCodeFilter !== null)
            url_ += "SycServiceCodeFilter=" + encodeURIComponent("" + sycServiceCodeFilter) + "&";
        if (sycApplicationNameFilter !== undefined && sycApplicationNameFilter !== null)
            url_ += "SycApplicationNameFilter=" + encodeURIComponent("" + sycApplicationNameFilter) + "&";
        if (appTransactionCodeFilter !== undefined && appTransactionCodeFilter !== null)
            url_ += "AppTransactionCodeFilter=" + encodeURIComponent("" + appTransactionCodeFilter) + "&";
        if (sycPlanNameFilter !== undefined && sycPlanNameFilter !== null)
            url_ += "SycPlanNameFilter=" + encodeURIComponent("" + sycPlanNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTenantsActivitiesLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTenantsActivitiesLogsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppTenantsActivitiesLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycServiceForTableDropdown(): Observable<AppTenantsActivitiesLogSycServiceLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAllSycServiceForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycServiceForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycServiceForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppTenantsActivitiesLogSycServiceLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppTenantsActivitiesLogSycServiceLookupTableDto[]>;
        }));
    }

    protected processGetAllSycServiceForTableDropdown(response: HttpResponseBase): Observable<AppTenantsActivitiesLogSycServiceLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppTenantsActivitiesLogSycServiceLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycApplicationForTableDropdown(): Observable<AppTenantsActivitiesLogSycApplicationLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAllSycApplicationForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycApplicationForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycApplicationForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppTenantsActivitiesLogSycApplicationLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppTenantsActivitiesLogSycApplicationLookupTableDto[]>;
        }));
    }

    protected processGetAllSycApplicationForTableDropdown(response: HttpResponseBase): Observable<AppTenantsActivitiesLogSycApplicationLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppTenantsActivitiesLogSycApplicationLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAppTransactionForTableDropdown(): Observable<AppTenantsActivitiesLogAppTransactionLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAllAppTransactionForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppTransactionForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppTransactionForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppTenantsActivitiesLogAppTransactionLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppTenantsActivitiesLogAppTransactionLookupTableDto[]>;
        }));
    }

    protected processGetAllAppTransactionForTableDropdown(response: HttpResponseBase): Observable<AppTenantsActivitiesLogAppTransactionLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppTenantsActivitiesLogAppTransactionLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycPlanForTableDropdown(): Observable<AppTenantsActivitiesLogSycPlanLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAllSycPlanForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycPlanForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycPlanForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppTenantsActivitiesLogSycPlanLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppTenantsActivitiesLogSycPlanLookupTableDto[]>;
        }));
    }

    protected processGetAllSycPlanForTableDropdown(response: HttpResponseBase): Observable<AppTenantsActivitiesLogSycPlanLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppTenantsActivitiesLogSycPlanLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllTenantForTableDropdown(): Observable<AppTenantsActivitiesLogTenantLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppTenantsActivitiesLogs/GetAllTenantForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenantForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenantForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppTenantsActivitiesLogTenantLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppTenantsActivitiesLogTenantLookupTableDto[]>;
        }));
    }

    protected processGetAllTenantForTableDropdown(response: HttpResponseBase): Observable<AppTenantsActivitiesLogTenantLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppTenantsActivitiesLogTenantLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppTransactionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditSalesOrder(body: CreateOrEditAppTransactionsDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/CreateOrEditSalesOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditSalesOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditSalesOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEditSalesOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditPurchaseOrder(body: CreateOrEditAppTransactionsDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/CreateOrEditPurchaseOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditPurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditPurchaseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEditPurchaseOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppTransactionsDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param transactionId (optional) 
     * @return Success
     */
    getAppTransactionsForView(transactionId: number | undefined): Observable<GetAppTransactionsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/GetAppTransactionsForView?";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTransactionsForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTransactionsForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppTransactionsForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppTransactionsForViewDto>;
        }));
    }

    protected processGetAppTransactionsForView(response: HttpResponseBase): Observable<GetAppTransactionsForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppTransactionsForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tranType (optional) 
     * @return Success
     */
    getNextOrderNumber(tranType: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/GetNextOrderNumber?";
        if (tranType !== undefined && tranType !== null)
            url_ += "tranType=" + encodeURIComponent("" + tranType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextOrderNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextOrderNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetNextOrderNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCurrentTenantAccountProfileInformation(): Observable<GetAccountInformationOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/GetCurrentTenantAccountProfileInformation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentTenantAccountProfileInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentTenantAccountProfileInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountInformationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountInformationOutputDto>;
        }));
    }

    protected processGetCurrentTenantAccountProfileInformation(response: HttpResponseBase): Observable<GetAccountInformationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountInformationOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAccountRelatedContacts(accountId: number | undefined, filter: string | null | undefined): Observable<GetContactInformationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/GetAccountRelatedContacts?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountRelatedContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountRelatedContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactInformationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactInformationDto[]>;
        }));
    }

    protected processGetAccountRelatedContacts(response: HttpResponseBase): Observable<GetContactInformationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetContactInformationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param filterType (optional) 
     * @param name (optional) 
     * @param address (optional) 
     * @param city (optional) 
     * @param state (optional) 
     * @param postal (optional) 
     * @param sSIN (optional) 
     * @param accountTypeId (optional) 
     * @param accountType (optional) 
     * @param accountTypes (optional) 
     * @param status (optional) 
     * @param languages (optional) 
     * @param countries (optional) 
     * @param classifications (optional) 
     * @param categories (optional) 
     * @param curruncies (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getRelatedAccounts(filter: string | null | undefined, filterType: number | undefined, name: string | null | undefined, address: string | null | undefined, city: string | null | undefined, state: string | null | undefined, postal: string | null | undefined, sSIN: string | null | undefined, accountTypeId: number | undefined, accountType: string | null | undefined, accountTypes: number[] | null | undefined, status: number[] | null | undefined, languages: number[] | null | undefined, countries: number[] | null | undefined, classifications: number[] | null | undefined, categories: number[] | null | undefined, curruncies: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAccountInformationOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTransaction/GetRelatedAccounts?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (filterType === null)
            throw new Error("The parameter 'filterType' cannot be null.");
        else if (filterType !== undefined)
            url_ += "FilterType=" + encodeURIComponent("" + filterType) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (address !== undefined && address !== null)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (city !== undefined && city !== null)
            url_ += "City=" + encodeURIComponent("" + city) + "&";
        if (state !== undefined && state !== null)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (postal !== undefined && postal !== null)
            url_ += "Postal=" + encodeURIComponent("" + postal) + "&";
        if (sSIN !== undefined && sSIN !== null)
            url_ += "SSIN=" + encodeURIComponent("" + sSIN) + "&";
        if (accountTypeId === null)
            throw new Error("The parameter 'accountTypeId' cannot be null.");
        else if (accountTypeId !== undefined)
            url_ += "AccountTypeId=" + encodeURIComponent("" + accountTypeId) + "&";
        if (accountType !== undefined && accountType !== null)
            url_ += "AccountType=" + encodeURIComponent("" + accountType) + "&";
        if (accountTypes !== undefined && accountTypes !== null)
            accountTypes && accountTypes.forEach(item => { url_ += "AccountTypes=" + encodeURIComponent("" + item) + "&"; });
        if (status !== undefined && status !== null)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (languages !== undefined && languages !== null)
            languages && languages.forEach(item => { url_ += "Languages=" + encodeURIComponent("" + item) + "&"; });
        if (countries !== undefined && countries !== null)
            countries && countries.forEach(item => { url_ += "Countries=" + encodeURIComponent("" + item) + "&"; });
        if (classifications !== undefined && classifications !== null)
            classifications && classifications.forEach(item => { url_ += "Classifications=" + encodeURIComponent("" + item) + "&"; });
        if (categories !== undefined && categories !== null)
            categories && categories.forEach(item => { url_ += "Categories=" + encodeURIComponent("" + item) + "&"; });
        if (curruncies !== undefined && curruncies !== null)
            curruncies && curruncies.forEach(item => { url_ += "Curruncies=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAccountInformationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAccountInformationOutputDto>;
        }));
    }

    protected processGetRelatedAccounts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAccountInformationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAccountInformationOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppTransactionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param maxDateFilter (optional) 
     * @param minDateFilter (optional) 
     * @param maxAddDateFilter (optional) 
     * @param minAddDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, maxDateFilter: moment.Moment | null | undefined, minDateFilter: moment.Moment | null | undefined, maxAddDateFilter: moment.Moment | null | undefined, minAddDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAppTransactionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTransactions/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (maxDateFilter !== undefined && maxDateFilter !== null)
            url_ += "MaxDateFilter=" + encodeURIComponent(maxDateFilter ? "" + maxDateFilter.toISOString() : "") + "&";
        if (minDateFilter !== undefined && minDateFilter !== null)
            url_ += "MinDateFilter=" + encodeURIComponent(minDateFilter ? "" + minDateFilter.toISOString() : "") + "&";
        if (maxAddDateFilter !== undefined && maxAddDateFilter !== null)
            url_ += "MaxAddDateFilter=" + encodeURIComponent(maxAddDateFilter ? "" + maxAddDateFilter.toISOString() : "") + "&";
        if (minAddDateFilter !== undefined && minAddDateFilter !== null)
            url_ += "MinAddDateFilter=" + encodeURIComponent(minAddDateFilter ? "" + minAddDateFilter.toISOString() : "") + "&";
        if (maxEndDateFilter !== undefined && maxEndDateFilter !== null)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toISOString() : "") + "&";
        if (minEndDateFilter !== undefined && minEndDateFilter !== null)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toISOString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAppTransactionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAppTransactionForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAppTransactionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAppTransactionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppTransactionForView(id: number | undefined): Observable<GetAppTransactionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTransactions/GetAppTransactionForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTransactionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTransactionForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppTransactionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppTransactionForViewDto>;
        }));
    }

    protected processGetAppTransactionForView(response: HttpResponseBase): Observable<GetAppTransactionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppTransactionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppTransactionForEdit(id: number | undefined): Observable<GetAppTransactionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppTransactions/GetAppTransactionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTransactionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTransactionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppTransactionForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppTransactionForEditOutput>;
        }));
    }

    protected processGetAppTransactionForEdit(response: HttpResponseBase): Observable<GetAppTransactionForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAppTransactionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAppTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppTransactions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppTransactions/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param maxDateFilter (optional) 
     * @param minDateFilter (optional) 
     * @param maxAddDateFilter (optional) 
     * @param minAddDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @return Success
     */
    getAppTransactionsToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, maxDateFilter: moment.Moment | null | undefined, minDateFilter: moment.Moment | null | undefined, maxAddDateFilter: moment.Moment | null | undefined, minAddDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppTransactions/GetAppTransactionsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (maxDateFilter !== undefined && maxDateFilter !== null)
            url_ += "MaxDateFilter=" + encodeURIComponent(maxDateFilter ? "" + maxDateFilter.toISOString() : "") + "&";
        if (minDateFilter !== undefined && minDateFilter !== null)
            url_ += "MinDateFilter=" + encodeURIComponent(minDateFilter ? "" + minDateFilter.toISOString() : "") + "&";
        if (maxAddDateFilter !== undefined && maxAddDateFilter !== null)
            url_ += "MaxAddDateFilter=" + encodeURIComponent(maxAddDateFilter ? "" + maxAddDateFilter.toISOString() : "") + "&";
        if (minAddDateFilter !== undefined && minAddDateFilter !== null)
            url_ += "MinAddDateFilter=" + encodeURIComponent(minAddDateFilter ? "" + minAddDateFilter.toISOString() : "") + "&";
        if (maxEndDateFilter !== undefined && maxEndDateFilter !== null)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toISOString() : "") + "&";
        if (minEndDateFilter !== undefined && minEndDateFilter !== null)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppTransactionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppTransactionsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAppTransactionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAuditLogListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAuditLogListDto>;
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueDto[]>;
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId !== undefined && entityId !== null)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPropertyChangeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPropertyChangeDto[]>;
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AutotaskQueuesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<GetAutotaskQueueForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AutotaskQueues/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAutotaskQueueForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAutotaskQueueForViewDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetAutotaskQueueForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAutotaskQueueForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAutotaskQueueForEdit(id: number | undefined): Observable<GetAutotaskQueueForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AutotaskQueues/GetAutotaskQueueForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAutotaskQueueForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAutotaskQueueForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAutotaskQueueForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAutotaskQueueForEditOutput>;
        }));
    }

    protected processGetAutotaskQueueForEdit(response: HttpResponseBase): Observable<GetAutotaskQueueForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAutotaskQueueForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAutotaskQueueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AutotaskQueues/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AutotaskQueues/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfCacheDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfCacheDto>;
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId !== undefined && minMessageId !== null)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfChatMessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfChatMessageDto>;
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDefaultEditionNameOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDefaultEditionNameOutput>;
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | null | undefined, application: string | null | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetUserDashboard?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Dashboard>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Dashboard>;
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddNewPageOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddNewPageOutput>;
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddNewPageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | null | undefined, dashboardName: string | null | undefined, application: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/DeletePage?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Widget>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Widget>;
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Widget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | null | undefined, application: string | null | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardOutput>;
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | null | undefined, application: string | null | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetOutput[]>;
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param application (optional) 
     * @return Success
     */
    getSettingName(application: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetSettingName?";
        if (application !== undefined && application !== null)
            url_ += "application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateToStringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateToStringOutput>;
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateToStringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateToStringOutput>;
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateToStringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateToStringOutput>;
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringOutput>;
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfEditionListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfEditionListDto>;
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionEditOutput>;
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined && selectedEditionId !== null)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscribableEditionComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscribableEditionComboboxItemDto[]>;
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmailingTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param templateName (optional) 
     * @param emailParameters (optional) 
     * @param langunage (optional) 
     * @return Success
     */
    getEmailTemplate(templateName: string | null | undefined, emailParameters: string[] | null | undefined, langunage: string | null | undefined): Observable<EmailTemplateReturnDto> {
        let url_ = this.baseUrl + "/api/services/app/EmailingTemplate/GetEmailTemplate?";
        if (templateName !== undefined && templateName !== null)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (emailParameters !== undefined && emailParameters !== null)
            emailParameters && emailParameters.forEach(item => { url_ += "emailParameters=" + encodeURIComponent("" + item) + "&"; });
        if (langunage !== undefined && langunage !== null)
            url_ += "langunage=" + encodeURIComponent("" + langunage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailTemplateReturnDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailTemplateReturnDto>;
        }));
    }

    protected processGetEmailTemplate(response: HttpResponseBase): Observable<EmailTemplateReturnDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailTemplateReturnDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopStatsData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopStatsData>;
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopStatsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRecentTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRecentTenantsOutput>;
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRecentTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetExpiringTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetExpiringTenantsOutput>;
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpiringTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIncomeStatisticsDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIncomeStatisticsDataOutput>;
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionTenantStatisticsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionTenantStatisticsOutput>;
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingsJsonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingsJsonDto>;
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckDatabaseOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckDatabaseOutput>;
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDefaultLanguage(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetDefaultLanguage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguagesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguagesOutput>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguageForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguageForEditOutput>;
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName !== undefined && baseLanguageName !== null)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter !== undefined && targetValueFilter !== null)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText !== undefined && filterText !== null)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MaintainancesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxFromFilter (optional) 
     * @param minFromFilter (optional) 
     * @param maxToFilter (optional) 
     * @param minToFilter (optional) 
     * @param publishedFilter (optional) 
     * @param dismissIdsFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxFromFilter: moment.Moment | null | undefined, minFromFilter: moment.Moment | null | undefined, maxToFilter: moment.Moment | null | undefined, minToFilter: moment.Moment | null | undefined, publishedFilter: number | null | undefined, dismissIdsFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMaintainanceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (maxFromFilter !== undefined && maxFromFilter !== null)
            url_ += "MaxFromFilter=" + encodeURIComponent(maxFromFilter ? "" + maxFromFilter.toISOString() : "") + "&";
        if (minFromFilter !== undefined && minFromFilter !== null)
            url_ += "MinFromFilter=" + encodeURIComponent(minFromFilter ? "" + minFromFilter.toISOString() : "") + "&";
        if (maxToFilter !== undefined && maxToFilter !== null)
            url_ += "MaxToFilter=" + encodeURIComponent(maxToFilter ? "" + maxToFilter.toISOString() : "") + "&";
        if (minToFilter !== undefined && minToFilter !== null)
            url_ += "MinToFilter=" + encodeURIComponent(minToFilter ? "" + minToFilter.toISOString() : "") + "&";
        if (publishedFilter !== undefined && publishedFilter !== null)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (dismissIdsFilter !== undefined && dismissIdsFilter !== null)
            url_ += "DismissIdsFilter=" + encodeURIComponent("" + dismissIdsFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMaintainanceForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMaintainanceForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaintainanceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMaintainanceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaintainanceForView(id: number | undefined): Observable<GetMaintainanceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/GetMaintainanceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintainanceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintainanceForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaintainanceForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaintainanceForViewDto>;
        }));
    }

    protected processGetMaintainanceForView(response: HttpResponseBase): Observable<GetMaintainanceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaintainanceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaintainanceForEdit(id: number | undefined): Observable<GetMaintainanceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/GetMaintainanceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintainanceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintainanceForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaintainanceForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaintainanceForEditOutput>;
        }));
    }

    protected processGetMaintainanceForEdit(response: HttpResponseBase): Observable<GetMaintainanceForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaintainanceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMaintainanceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getOpenBuild(): Observable<GetMaintainanceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/GetOpenBuild";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpenBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpenBuild(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaintainanceForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaintainanceForViewDto>;
        }));
    }

    protected processGetOpenBuild(response: HttpResponseBase): Observable<GetMaintainanceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaintainanceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    updateOpenBuildWithUserId(userId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/UpdateOpenBuildWithUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOpenBuildWithUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOpenBuildWithUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOpenBuildWithUserId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxFromFilter (optional) 
     * @param minFromFilter (optional) 
     * @param maxToFilter (optional) 
     * @param minToFilter (optional) 
     * @param publishedFilter (optional) 
     * @param dismissIdsFilter (optional) 
     * @return Success
     */
    getMaintainancesToExcel(filter: string | null | undefined, nameFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxFromFilter: moment.Moment | null | undefined, minFromFilter: moment.Moment | null | undefined, maxToFilter: moment.Moment | null | undefined, minToFilter: moment.Moment | null | undefined, publishedFilter: number | null | undefined, dismissIdsFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Maintainances/GetMaintainancesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (maxFromFilter !== undefined && maxFromFilter !== null)
            url_ += "MaxFromFilter=" + encodeURIComponent(maxFromFilter ? "" + maxFromFilter.toISOString() : "") + "&";
        if (minFromFilter !== undefined && minFromFilter !== null)
            url_ += "MinFromFilter=" + encodeURIComponent(minFromFilter ? "" + minFromFilter.toISOString() : "") + "&";
        if (maxToFilter !== undefined && maxToFilter !== null)
            url_ += "MaxToFilter=" + encodeURIComponent(maxToFilter ? "" + maxToFilter.toISOString() : "") + "&";
        if (minToFilter !== undefined && minToFilter !== null)
            url_ += "MinToFilter=" + encodeURIComponent(minToFilter ? "" + minToFilter.toISOString() : "") + "&";
        if (publishedFilter !== undefined && publishedFilter !== null)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (dismissIdsFilter !== undefined && dismissIdsFilter !== null)
            url_ += "DismissIdsFilter=" + encodeURIComponent("" + dismissIdsFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintainancesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintainancesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMaintainancesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MessageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param bodyFilter (optional) 
     * @param subjectFilter (optional) 
     * @param messageTypeIndex (optional) 
     * @param mainComponentEntitlyId (optional) 
     * @param parentId (optional) 
     * @param threadId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, bodyFilter: string | null | undefined, subjectFilter: string | null | undefined, messageTypeIndex: number | undefined, mainComponentEntitlyId: number | null | undefined, parentId: number | null | undefined, threadId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MessagePagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Message/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (bodyFilter !== undefined && bodyFilter !== null)
            url_ += "BodyFilter=" + encodeURIComponent("" + bodyFilter) + "&";
        if (subjectFilter !== undefined && subjectFilter !== null)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&";
        if (messageTypeIndex === null)
            throw new Error("The parameter 'messageTypeIndex' cannot be null.");
        else if (messageTypeIndex !== undefined)
            url_ += "messageTypeIndex=" + encodeURIComponent("" + messageTypeIndex) + "&";
        if (mainComponentEntitlyId !== undefined && mainComponentEntitlyId !== null)
            url_ += "MainComponentEntitlyId=" + encodeURIComponent("" + mainComponentEntitlyId) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (threadId !== undefined && threadId !== null)
            url_ += "ThreadId=" + encodeURIComponent("" + threadId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessagePagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessagePagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MessagePagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessagePagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param bodyFilter (optional) 
     * @param subjectFilter (optional) 
     * @param messageTypeIndex (optional) 
     * @param mainComponentEntitlyId (optional) 
     * @param parentId (optional) 
     * @param threadId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllComments(filter: string | null | undefined, bodyFilter: string | null | undefined, subjectFilter: string | null | undefined, messageTypeIndex: number | undefined, mainComponentEntitlyId: number | null | undefined, parentId: number | null | undefined, threadId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MessagePagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Message/GetAllComments?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (bodyFilter !== undefined && bodyFilter !== null)
            url_ += "BodyFilter=" + encodeURIComponent("" + bodyFilter) + "&";
        if (subjectFilter !== undefined && subjectFilter !== null)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&";
        if (messageTypeIndex === null)
            throw new Error("The parameter 'messageTypeIndex' cannot be null.");
        else if (messageTypeIndex !== undefined)
            url_ += "messageTypeIndex=" + encodeURIComponent("" + messageTypeIndex) + "&";
        if (mainComponentEntitlyId !== undefined && mainComponentEntitlyId !== null)
            url_ += "MainComponentEntitlyId=" + encodeURIComponent("" + mainComponentEntitlyId) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (threadId !== undefined && threadId !== null)
            url_ += "ThreadId=" + encodeURIComponent("" + threadId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessagePagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessagePagedResultDto>;
        }));
    }

    protected processGetAllComments(response: HttpResponseBase): Observable<MessagePagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessagePagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    delete(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Message/Delete?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hardDelete(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Message/HardDelete?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    favorite(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Message/Favorite?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFavorite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFavorite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFavorite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    archive(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Message/Archive?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processArchive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    read(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Message/Read?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMessagesForView(id: number | undefined): Observable<GetMessagesForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Message/GetMessagesForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessagesForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessagesForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMessagesForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMessagesForViewDto[]>;
        }));
    }

    protected processGetMessagesForView(response: HttpResponseBase): Observable<GetMessagesForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMessagesForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getAllUsers(searchTerm: string | null | undefined): Observable<GetUsersForMessageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Message/GetAllUsers?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUsersForMessageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUsersForMessageDto[]>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<GetUsersForMessageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetUsersForMessageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMessage(body: CreateMessageInput | undefined): Observable<GetMessagesForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Message/CreateMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMessagesForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMessagesForViewDto[]>;
        }));
    }

    protected processCreateMessage(response: HttpResponseBase): Observable<GetMessagesForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMessagesForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param users (optional) 
     * @return Success
     */
    getUsersNamesByID(users: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Message/GetUsersNamesByID?";
        if (users !== undefined && users !== null)
            url_ += "users=" + encodeURIComponent("" + users) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersNamesByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersNamesByID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetUsersNamesByID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param usersIds (optional) 
     * @return Success
     */
    getMessageRecieversName(usersIds: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/Message/GetMessageRecieversName?";
        if (usersIds !== undefined && usersIds !== null)
            url_ += "usersIds=" + encodeURIComponent("" + usersIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageRecieversName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageRecieversName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processGetMessageRecieversName(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getUnreadCounts(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Message/GetUnreadCounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnreadCounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnreadCounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetUnreadCounts(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationsOutput>;
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationSettingsOutput>;
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined && upgradeEditionId !== null)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInfoDto>;
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined && recurringPaymentsEnabled !== null)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentGatewayModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentGatewayModel[]>;
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    switchBetweenFreeEditions(upgradeEditionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/SwitchBetweenFreeEditions?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchBetweenFreeEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchBetweenFreeEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSwitchBetweenFreeEditions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    upgradeSubscriptionCostsLessThenMinAmount(editionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSubscriptionCostsLessThenMinAmount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSubscriptionCostsLessThenMinAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    hasAnyPayment(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Payment/HasAnyPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasAnyPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasAnyPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processHasAnyPayment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalOrderId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (paypalOrderId !== undefined && paypalOrderId !== null)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayPalConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayPalConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentUserProfileEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentUserProfileEditDto>;
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    disableGoogleAuthenticator(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPasswordComplexitySettingOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPasswordComplexitySettingOutput>;
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined && profilePictureId !== null)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReportDesignerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param reportUrl (optional) 
     * @return Success
     */
    getReportDesignerModel(reportUrl: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReportDesigner/GetReportDesignerModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (reportUrl !== null && reportUrl !== undefined)
            content_.append("reportUrl", reportUrl.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportDesignerModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportDesignerModel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetReportDesignerModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param permissions (optional) 
     * @return Success
     */
    getRoles(permissions: string[] | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfRoleListDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateUserSignInTokenOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateUserSignInTokenOutput>;
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripeConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param stripeSessionId (optional) 
     * @return Success
     */
    getPayment(stripeSessionId: string | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPayment?";
        if (stripeSessionId !== undefined && stripeSessionId !== null)
            url_ += "StripeSessionId=" + encodeURIComponent("" + stripeSessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaymentSession(body: StripeCreatePaymentSessionInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreatePaymentSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreatePaymentSession(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPaymentResult(paymentId: number | undefined): Observable<StripePaymentResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPaymentResult?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "PaymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripePaymentResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripePaymentResultOutput>;
        }));
    }

    protected processGetPaymentResult(response: HttpResponseBase): Observable<StripePaymentResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripePaymentResultOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SuiIconsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSuiIconForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SuiIcons/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSuiIconForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSuiIconForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSuiIconForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSuiIconForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSuiIconForEdit(id: number | undefined): Observable<GetSuiIconForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SuiIcons/GetSuiIconForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuiIconForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuiIconForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSuiIconForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSuiIconForEditOutput>;
        }));
    }

    protected processGetSuiIconForEdit(response: HttpResponseBase): Observable<GetSuiIconForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSuiIconForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSuiIconDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SuiIcons/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SuiIcons/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycApplicationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param notesFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, notesFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycApplicationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycApplications/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (notesFilter !== undefined && notesFilter !== null)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycApplicationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycApplicationForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycApplicationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycApplicationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycApplicationForView(id: number | undefined): Observable<GetSycApplicationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycApplications/GetSycApplicationForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycApplicationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycApplicationForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycApplicationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycApplicationForViewDto>;
        }));
    }

    protected processGetSycApplicationForView(response: HttpResponseBase): Observable<GetSycApplicationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycApplicationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycApplicationForEdit(id: number | undefined): Observable<GetSycApplicationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycApplications/GetSycApplicationForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycApplicationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycApplicationForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycApplicationForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycApplicationForEditOutput>;
        }));
    }

    protected processGetSycApplicationForEdit(response: HttpResponseBase): Observable<GetSycApplicationForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycApplicationForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycApplications/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycApplications/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param notesFilter (optional) 
     * @return Success
     */
    getSycApplicationsToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, notesFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycApplications/GetSycApplicationsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (notesFilter !== undefined && notesFilter !== null)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycApplicationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycApplicationsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycApplicationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycAttachmentCategoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param attributesFilter (optional) 
     * @param parentCodeFilter (optional) 
     * @param sycAttachmentCategoryNameFilter (optional) 
     * @param aspectRatioFilter (optional) 
     * @param maxFileSizeFilter (optional) 
     * @param messageFilter (optional) 
     * @param typeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, attributesFilter: string | null | undefined, parentCodeFilter: string | null | undefined, sycAttachmentCategoryNameFilter: string | null | undefined, aspectRatioFilter: string | null | undefined, maxFileSizeFilter: number | null | undefined, messageFilter: string | null | undefined, typeFilter: AttachmentType | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycAttachmentCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (attributesFilter !== undefined && attributesFilter !== null)
            url_ += "AttributesFilter=" + encodeURIComponent("" + attributesFilter) + "&";
        if (parentCodeFilter !== undefined && parentCodeFilter !== null)
            url_ += "ParentCodeFilter=" + encodeURIComponent("" + parentCodeFilter) + "&";
        if (sycAttachmentCategoryNameFilter !== undefined && sycAttachmentCategoryNameFilter !== null)
            url_ += "SycAttachmentCategoryNameFilter=" + encodeURIComponent("" + sycAttachmentCategoryNameFilter) + "&";
        if (aspectRatioFilter !== undefined && aspectRatioFilter !== null)
            url_ += "AspectRatioFilter=" + encodeURIComponent("" + aspectRatioFilter) + "&";
        if (maxFileSizeFilter !== undefined && maxFileSizeFilter !== null)
            url_ += "MaxFileSizeFilter=" + encodeURIComponent("" + maxFileSizeFilter) + "&";
        if (messageFilter !== undefined && messageFilter !== null)
            url_ += "MessageFilter=" + encodeURIComponent("" + messageFilter) + "&";
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycAttachmentCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycAttachmentCategoryForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycAttachmentCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycAttachmentCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllForAccountInfo(): Observable<GetSycAttachmentCategoryForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetAllForAccountInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForAccountInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycAttachmentCategoryForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycAttachmentCategoryForViewDto[]>;
        }));
    }

    protected processGetAllForAccountInfo(response: HttpResponseBase): Observable<GetSycAttachmentCategoryForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSycAttachmentCategoryForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycAttachmentCategoryForView(id: number | undefined): Observable<GetSycAttachmentCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetSycAttachmentCategoryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycAttachmentCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycAttachmentCategoryForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycAttachmentCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycAttachmentCategoryForViewDto>;
        }));
    }

    protected processGetSycAttachmentCategoryForView(response: HttpResponseBase): Observable<GetSycAttachmentCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycAttachmentCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getSycAttachmentCategoryForViewByCode(code: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetSycAttachmentCategoryForViewByCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycAttachmentCategoryForViewByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycAttachmentCategoryForViewByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetSycAttachmentCategoryForViewByCode(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycAttachmentCategoryForEdit(id: number | undefined): Observable<GetSycAttachmentCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetSycAttachmentCategoryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycAttachmentCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycAttachmentCategoryForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycAttachmentCategoryForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycAttachmentCategoryForEditOutput>;
        }));
    }

    protected processGetSycAttachmentCategoryForEdit(response: HttpResponseBase): Observable<GetSycAttachmentCategoryForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycAttachmentCategoryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycAttachmentCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param attributesFilter (optional) 
     * @param parentCodeFilter (optional) 
     * @param sycAttachmentCategoryNameFilter (optional) 
     * @param aspectRatioFilter (optional) 
     * @param maxFileSizeFilter (optional) 
     * @param messageFilter (optional) 
     * @param typeFilter (optional) 
     * @return Success
     */
    getSycAttachmentCategoriesToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, attributesFilter: string | null | undefined, parentCodeFilter: string | null | undefined, sycAttachmentCategoryNameFilter: string | null | undefined, aspectRatioFilter: string | null | undefined, maxFileSizeFilter: number | null | undefined, messageFilter: string | null | undefined, typeFilter: AttachmentType | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetSycAttachmentCategoriesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (attributesFilter !== undefined && attributesFilter !== null)
            url_ += "AttributesFilter=" + encodeURIComponent("" + attributesFilter) + "&";
        if (parentCodeFilter !== undefined && parentCodeFilter !== null)
            url_ += "ParentCodeFilter=" + encodeURIComponent("" + parentCodeFilter) + "&";
        if (sycAttachmentCategoryNameFilter !== undefined && sycAttachmentCategoryNameFilter !== null)
            url_ += "SycAttachmentCategoryNameFilter=" + encodeURIComponent("" + sycAttachmentCategoryNameFilter) + "&";
        if (aspectRatioFilter !== undefined && aspectRatioFilter !== null)
            url_ += "AspectRatioFilter=" + encodeURIComponent("" + aspectRatioFilter) + "&";
        if (maxFileSizeFilter !== undefined && maxFileSizeFilter !== null)
            url_ += "MaxFileSizeFilter=" + encodeURIComponent("" + maxFileSizeFilter) + "&";
        if (messageFilter !== undefined && messageFilter !== null)
            url_ += "MessageFilter=" + encodeURIComponent("" + messageFilter) + "&";
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycAttachmentCategoriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycAttachmentCategoriesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycAttachmentCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycAttachmentCategoryForTableDropdown(): Observable<SycAttachmentCategorySycAttachmentCategoryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetAllSycAttachmentCategoryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycAttachmentCategoryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycAttachmentCategoryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycAttachmentCategorySycAttachmentCategoryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycAttachmentCategorySycAttachmentCategoryLookupTableDto[]>;
        }));
    }

    protected processGetAllSycAttachmentCategoryForTableDropdown(response: HttpResponseBase): Observable<SycAttachmentCategorySycAttachmentCategoryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycAttachmentCategorySycAttachmentCategoryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycAttachmentCategoryTypesForTableDropdown(): Observable<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetAllSycAttachmentCategoryTypesForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycAttachmentCategoryTypesForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycAttachmentCategoryTypesForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectItemDto[]>;
        }));
    }

    protected processGetAllSycAttachmentCategoryTypesForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param codes (optional) 
     * @return Success
     */
    getSycAttachmentCategoriesByCodes(codes: string[] | null | undefined): Observable<SycAttachmentCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentCategories/GetSycAttachmentCategoriesByCodes?";
        if (codes !== undefined && codes !== null)
            codes && codes.forEach(item => { url_ += "codes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycAttachmentCategoriesByCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycAttachmentCategoriesByCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycAttachmentCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycAttachmentCategoryDto[]>;
        }));
    }

    protected processGetSycAttachmentCategoriesByCodes(response: HttpResponseBase): Observable<SycAttachmentCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycAttachmentCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycAttachmentTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param typeFilter (optional) 
     * @param extensionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, typeFilter: number | undefined, extensionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycAttachmentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentTypes/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&";
        if (extensionFilter !== undefined && extensionFilter !== null)
            url_ += "ExtensionFilter=" + encodeURIComponent("" + extensionFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycAttachmentTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycAttachmentTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycAttachmentTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycAttachmentTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycAttachmentTypeForView(id: number | undefined): Observable<GetSycAttachmentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentTypes/GetSycAttachmentTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycAttachmentTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycAttachmentTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycAttachmentTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycAttachmentTypeForViewDto>;
        }));
    }

    protected processGetSycAttachmentTypeForView(response: HttpResponseBase): Observable<GetSycAttachmentTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycAttachmentTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycAttachmentTypeForEdit(id: number | undefined): Observable<GetSycAttachmentTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentTypes/GetSycAttachmentTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycAttachmentTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycAttachmentTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycAttachmentTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycAttachmentTypeForEditOutput>;
        }));
    }

    protected processGetSycAttachmentTypeForEdit(response: HttpResponseBase): Observable<GetSycAttachmentTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycAttachmentTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycAttachmentTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycAttachmentTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycCountersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxCounterFilter (optional) 
     * @param minCounterFilter (optional) 
     * @param sycSegmentIdentifierDefinitionNameFilter (optional) 
     * @param sycSegmentIdentifierDefinitionIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxCounterFilter: number | null | undefined, minCounterFilter: number | null | undefined, sycSegmentIdentifierDefinitionNameFilter: string | null | undefined, sycSegmentIdentifierDefinitionIdFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycCounterForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycCounters/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxCounterFilter !== undefined && maxCounterFilter !== null)
            url_ += "MaxCounterFilter=" + encodeURIComponent("" + maxCounterFilter) + "&";
        if (minCounterFilter !== undefined && minCounterFilter !== null)
            url_ += "MinCounterFilter=" + encodeURIComponent("" + minCounterFilter) + "&";
        if (sycSegmentIdentifierDefinitionNameFilter !== undefined && sycSegmentIdentifierDefinitionNameFilter !== null)
            url_ += "SycSegmentIdentifierDefinitionNameFilter=" + encodeURIComponent("" + sycSegmentIdentifierDefinitionNameFilter) + "&";
        if (sycSegmentIdentifierDefinitionIdFilter !== undefined && sycSegmentIdentifierDefinitionIdFilter !== null)
            url_ += "SycSegmentIdentifierDefinitionIdFilter=" + encodeURIComponent("" + sycSegmentIdentifierDefinitionIdFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycCounterForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycCounterForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycCounterForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycCounterForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycCounterForView(id: number | undefined): Observable<GetSycCounterForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycCounters/GetSycCounterForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycCounterForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycCounterForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycCounterForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycCounterForViewDto>;
        }));
    }

    protected processGetSycCounterForView(response: HttpResponseBase): Observable<GetSycCounterForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycCounterForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycCounterForEdit(id: number | undefined): Observable<GetSycCounterForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycCounters/GetSycCounterForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycCounterForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycCounterForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycCounterForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycCounterForEditOutput>;
        }));
    }

    protected processGetSycCounterForEdit(response: HttpResponseBase): Observable<GetSycCounterForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycCounterForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycCounterDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycCounters/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycCounters/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxCounterFilter (optional) 
     * @param minCounterFilter (optional) 
     * @param sycSegmentIdentifierDefinitionNameFilter (optional) 
     * @param sycSegmentIdentifierDefinitionIdFilter (optional) 
     * @return Success
     */
    getSycCountersToExcel(filter: string | null | undefined, maxCounterFilter: number | null | undefined, minCounterFilter: number | null | undefined, sycSegmentIdentifierDefinitionNameFilter: string | null | undefined, sycSegmentIdentifierDefinitionIdFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycCounters/GetSycCountersToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxCounterFilter !== undefined && maxCounterFilter !== null)
            url_ += "MaxCounterFilter=" + encodeURIComponent("" + maxCounterFilter) + "&";
        if (minCounterFilter !== undefined && minCounterFilter !== null)
            url_ += "MinCounterFilter=" + encodeURIComponent("" + minCounterFilter) + "&";
        if (sycSegmentIdentifierDefinitionNameFilter !== undefined && sycSegmentIdentifierDefinitionNameFilter !== null)
            url_ += "SycSegmentIdentifierDefinitionNameFilter=" + encodeURIComponent("" + sycSegmentIdentifierDefinitionNameFilter) + "&";
        if (sycSegmentIdentifierDefinitionIdFilter !== undefined && sycSegmentIdentifierDefinitionIdFilter !== null)
            url_ += "SycSegmentIdentifierDefinitionIdFilter=" + encodeURIComponent("" + sycSegmentIdentifierDefinitionIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycCountersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycCountersToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycCountersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSycSegmentIdentifierDefinitionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SycCounters/GetAllSycSegmentIdentifierDefinitionForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycSegmentIdentifierDefinitionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycSegmentIdentifierDefinitionForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto>;
        }));
    }

    protected processGetAllSycSegmentIdentifierDefinitionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycEntityLocalizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param lang (optional) 
     * @param objectTypeId (optional) 
     * @return Success
     */
    getAll(lang: string | null | undefined, objectTypeId: number | undefined): Observable<SycEntityLocalization[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityLocalization/GetAll?";
        if (lang !== undefined && lang !== null)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (objectTypeId === null)
            throw new Error("The parameter 'objectTypeId' cannot be null.");
        else if (objectTypeId !== undefined)
            url_ += "objectTypeId=" + encodeURIComponent("" + objectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityLocalization[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityLocalization[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SycEntityLocalization[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityLocalization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param objectTypeId (optional) 
     * @param objectId (optional) 
     * @param languageCode (optional) 
     * @param key (optional) 
     * @param text (optional) 
     * @return Success
     */
    createOrUpdateLocalization(objectTypeId: number | undefined, objectId: number | undefined, languageCode: string | null | undefined, key: string | null | undefined, text: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityLocalization/CreateOrUpdateLocalization?";
        if (objectTypeId === null)
            throw new Error("The parameter 'objectTypeId' cannot be null.");
        else if (objectTypeId !== undefined)
            url_ += "objectTypeId=" + encodeURIComponent("" + objectTypeId) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (text !== undefined && text !== null)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLocalization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLocalization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateLocalization(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycEntityObjectCategoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectCategoryNameFilter (optional) 
     * @param eagger (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param departmentFlag (optional) 
     * @param entityId (optional) 
     * @param excludeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectCategoryNameFilter: string | null | undefined, eagger: boolean | undefined, objectId: number | undefined, parentId: number | undefined, departmentFlag: boolean | undefined, entityId: number | undefined, excludeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectCategoryNameFilter !== undefined && sycEntityObjectCategoryNameFilter !== null)
            url_ += "SycEntityObjectCategoryNameFilter=" + encodeURIComponent("" + sycEntityObjectCategoryNameFilter) + "&";
        if (eagger === null)
            throw new Error("The parameter 'eagger' cannot be null.");
        else if (eagger !== undefined)
            url_ += "Eagger=" + encodeURIComponent("" + eagger) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (departmentFlag === null)
            throw new Error("The parameter 'departmentFlag' cannot be null.");
        else if (departmentFlag !== undefined)
            url_ += "DepartmentFlag=" + encodeURIComponent("" + departmentFlag) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectCategoryNameFilter (optional) 
     * @param eagger (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param departmentFlag (optional) 
     * @param entityId (optional) 
     * @param excludeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithChildsForContactAsTreeViewWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectCategoryNameFilter: string | null | undefined, eagger: boolean | undefined, objectId: number | undefined, parentId: number | undefined, departmentFlag: boolean | undefined, entityId: number | undefined, excludeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeviewItem> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllWithChildsForContactAsTreeViewWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectCategoryNameFilter !== undefined && sycEntityObjectCategoryNameFilter !== null)
            url_ += "SycEntityObjectCategoryNameFilter=" + encodeURIComponent("" + sycEntityObjectCategoryNameFilter) + "&";
        if (eagger === null)
            throw new Error("The parameter 'eagger' cannot be null.");
        else if (eagger !== undefined)
            url_ += "Eagger=" + encodeURIComponent("" + eagger) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (departmentFlag === null)
            throw new Error("The parameter 'departmentFlag' cannot be null.");
        else if (departmentFlag !== undefined)
            url_ += "DepartmentFlag=" + encodeURIComponent("" + departmentFlag) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContactAsTreeViewWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContactAsTreeViewWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeviewItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeviewItem>;
        }));
    }

    protected processGetAllWithChildsForContactAsTreeViewWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeviewItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeviewItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllWithChildsForContactAsTreeView(): Observable<PagedResultDtoOfTreeviewItem> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllWithChildsForContactAsTreeView";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContactAsTreeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContactAsTreeView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeviewItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeviewItem>;
        }));
    }

    protected processGetAllWithChildsForContactAsTreeView(response: HttpResponseBase): Observable<PagedResultDtoOfTreeviewItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeviewItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllWithChildsForContact(): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllWithChildsForContact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetAllWithChildsForContact(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectCategoryNameFilter (optional) 
     * @param eagger (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param departmentFlag (optional) 
     * @param entityId (optional) 
     * @param excludeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithChildsForContactWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectCategoryNameFilter: string | null | undefined, eagger: boolean | undefined, objectId: number | undefined, parentId: number | undefined, departmentFlag: boolean | undefined, entityId: number | undefined, excludeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllWithChildsForContactWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectCategoryNameFilter !== undefined && sycEntityObjectCategoryNameFilter !== null)
            url_ += "SycEntityObjectCategoryNameFilter=" + encodeURIComponent("" + sycEntityObjectCategoryNameFilter) + "&";
        if (eagger === null)
            throw new Error("The parameter 'eagger' cannot be null.");
        else if (eagger !== undefined)
            url_ += "Eagger=" + encodeURIComponent("" + eagger) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (departmentFlag === null)
            throw new Error("The parameter 'departmentFlag' cannot be null.");
        else if (departmentFlag !== undefined)
            url_ += "DepartmentFlag=" + encodeURIComponent("" + departmentFlag) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContactWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContactWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetAllWithChildsForContactWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param departmentFlag (optional) 
     * @return Success
     */
    getAllWithChildsForProduct(departmentFlag: boolean | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllWithChildsForProduct?";
        if (departmentFlag === null)
            throw new Error("The parameter 'departmentFlag' cannot be null.");
        else if (departmentFlag !== undefined)
            url_ += "departmentFlag=" + encodeURIComponent("" + departmentFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetAllWithChildsForProduct(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectCategoryNameFilter (optional) 
     * @param eagger (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param departmentFlag (optional) 
     * @param entityId (optional) 
     * @param excludeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithChildsForProductWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectCategoryNameFilter: string | null | undefined, eagger: boolean | undefined, objectId: number | undefined, parentId: number | undefined, departmentFlag: boolean | undefined, entityId: number | undefined, excludeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllWithChildsForProductWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectCategoryNameFilter !== undefined && sycEntityObjectCategoryNameFilter !== null)
            url_ += "SycEntityObjectCategoryNameFilter=" + encodeURIComponent("" + sycEntityObjectCategoryNameFilter) + "&";
        if (eagger === null)
            throw new Error("The parameter 'eagger' cannot be null.");
        else if (eagger !== undefined)
            url_ += "Eagger=" + encodeURIComponent("" + eagger) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (departmentFlag === null)
            throw new Error("The parameter 'departmentFlag' cannot be null.");
        else if (departmentFlag !== undefined)
            url_ += "DepartmentFlag=" + encodeURIComponent("" + departmentFlag) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForProductWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForProductWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetAllWithChildsForProductWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllDepartmentsWithChildsForProduct(): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllDepartmentsWithChildsForProduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartmentsWithChildsForProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartmentsWithChildsForProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetAllDepartmentsWithChildsForProduct(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectCategoryNameFilter (optional) 
     * @param eagger (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param departmentFlag (optional) 
     * @param entityId (optional) 
     * @param excludeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllChildsWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectCategoryNameFilter: string | null | undefined, eagger: boolean | undefined, objectId: number | undefined, parentId: number | undefined, departmentFlag: boolean | undefined, entityId: number | undefined, excludeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllChildsWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectCategoryNameFilter !== undefined && sycEntityObjectCategoryNameFilter !== null)
            url_ += "SycEntityObjectCategoryNameFilter=" + encodeURIComponent("" + sycEntityObjectCategoryNameFilter) + "&";
        if (eagger === null)
            throw new Error("The parameter 'eagger' cannot be null.");
        else if (eagger !== undefined)
            url_ += "Eagger=" + encodeURIComponent("" + eagger) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (departmentFlag === null)
            throw new Error("The parameter 'departmentFlag' cannot be null.");
        else if (departmentFlag !== undefined)
            url_ += "DepartmentFlag=" + encodeURIComponent("" + departmentFlag) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChildsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChildsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetAllChildsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getAllChilds(parentId: number | undefined): Observable<TreeNodeOfGetSycEntityObjectCategoryForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllChilds?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChilds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChilds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfGetSycEntityObjectCategoryForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfGetSycEntityObjectCategoryForViewDto[]>;
        }));
    }

    protected processGetAllChilds(response: HttpResponseBase): Observable<TreeNodeOfGetSycEntityObjectCategoryForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectCategoryForView(id: number | undefined): Observable<GetSycEntityObjectCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetSycEntityObjectCategoryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectCategoryForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectCategoryForViewDto>;
        }));
    }

    protected processGetSycEntityObjectCategoryForView(response: HttpResponseBase): Observable<GetSycEntityObjectCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectCategoryForEdit(id: number | undefined): Observable<GetSycEntityObjectCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetSycEntityObjectCategoryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectCategoryForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectCategoryForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectCategoryForEditOutput>;
        }));
    }

    protected processGetSycEntityObjectCategoryForEdit(response: HttpResponseBase): Observable<GetSycEntityObjectCategoryForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectCategoryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycEntityObjectCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryName (optional) 
     * @return Success
     */
    categoryNameIsExisting(categoryName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/CategoryNameIsExisting?";
        if (categoryName !== undefined && categoryName !== null)
            url_ += "categoryName=" + encodeURIComponent("" + categoryName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryNameIsExisting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryNameIsExisting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCategoryNameIsExisting(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditForObjectProduct(body: CreateOrEditSycEntityObjectCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/CreateOrEditForObjectProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditForObjectProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditForObjectProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditForObjectProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectCategoryNameFilter (optional) 
     * @return Success
     */
    getSycEntityObjectCategoriesToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectCategoryNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetSycEntityObjectCategoriesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectCategoryNameFilter !== undefined && sycEntityObjectCategoryNameFilter !== null)
            url_ += "SycEntityObjectCategoryNameFilter=" + encodeURIComponent("" + sycEntityObjectCategoryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectCategoriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectCategoriesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycEntityObjectCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSydObjectForTableDropdown(): Observable<SycEntityObjectCategorySydObjectLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllSydObjectForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSydObjectForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSydObjectForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectCategorySydObjectLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectCategorySydObjectLookupTableDto[]>;
        }));
    }

    protected processGetAllSydObjectForTableDropdown(response: HttpResponseBase): Observable<SycEntityObjectCategorySydObjectLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityObjectCategorySydObjectLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycEntityObjectCategoryForTableDropdown(): Observable<SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectCategories/GetAllSycEntityObjectCategoryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycEntityObjectCategoryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycEntityObjectCategoryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto[]>;
        }));
    }

    protected processGetAllSycEntityObjectCategoryForTableDropdown(response: HttpResponseBase): Observable<SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycEntityObjectClassificationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectClassificationNameFilter (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param excludeIds (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectClassificationNameFilter: string | null | undefined, objectId: number | undefined, parentId: number | undefined, excludeIds: number[] | null | undefined, entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectClassificationNameFilter !== undefined && sycEntityObjectClassificationNameFilter !== null)
            url_ += "SycEntityObjectClassificationNameFilter=" + encodeURIComponent("" + sycEntityObjectClassificationNameFilter) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param classificationName (optional) 
     * @return Success
     */
    classificationNameIsExisting(classificationName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/ClassificationNameIsExisting?";
        if (classificationName !== undefined && classificationName !== null)
            url_ += "classificationName=" + encodeURIComponent("" + classificationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClassificationNameIsExisting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClassificationNameIsExisting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processClassificationNameIsExisting(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getAllChilds(parentId: number | undefined): Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllChilds?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChilds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChilds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]>;
        }));
    }

    protected processGetAllChilds(response: HttpResponseBase): Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectClassificationNameFilter (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param excludeIds (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllChildsWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectClassificationNameFilter: string | null | undefined, objectId: number | undefined, parentId: number | undefined, excludeIds: number[] | null | undefined, entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllChildsWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectClassificationNameFilter !== undefined && sycEntityObjectClassificationNameFilter !== null)
            url_ += "SycEntityObjectClassificationNameFilter=" + encodeURIComponent("" + sycEntityObjectClassificationNameFilter) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChildsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChildsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
        }));
    }

    protected processGetAllChildsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllChildsForLables(): Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllChildsForLables";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChildsForLables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChildsForLables(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]>;
        }));
    }

    protected processGetAllChildsForLables(response: HttpResponseBase): Observable<TreeNodeOfGetSycEntityObjectClassificationForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllWithChildsForContact(): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllWithChildsForContact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
        }));
    }

    protected processGetAllWithChildsForContact(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectClassificationNameFilter (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param excludeIds (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithChildsForContactWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectClassificationNameFilter: string | null | undefined, objectId: number | undefined, parentId: number | undefined, excludeIds: number[] | null | undefined, entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllWithChildsForContactWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectClassificationNameFilter !== undefined && sycEntityObjectClassificationNameFilter !== null)
            url_ += "SycEntityObjectClassificationNameFilter=" + encodeURIComponent("" + sycEntityObjectClassificationNameFilter) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContactWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContactWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
        }));
    }

    protected processGetAllWithChildsForContactWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllWithChildsForProduct(): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllWithChildsForProduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
        }));
    }

    protected processGetAllWithChildsForProduct(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectClassificationNameFilter (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param excludeIds (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithChildsForProductWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectClassificationNameFilter: string | null | undefined, objectId: number | undefined, parentId: number | undefined, excludeIds: number[] | null | undefined, entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllWithChildsForProductWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectClassificationNameFilter !== undefined && sycEntityObjectClassificationNameFilter !== null)
            url_ += "SycEntityObjectClassificationNameFilter=" + encodeURIComponent("" + sycEntityObjectClassificationNameFilter) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForProductWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForProductWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto>;
        }));
    }

    protected processGetAllWithChildsForProductWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectClassificationNameFilter (optional) 
     * @param objectId (optional) 
     * @param parentId (optional) 
     * @param excludeIds (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithChildsForContactAsTreeViewWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectClassificationNameFilter: string | null | undefined, objectId: number | undefined, parentId: number | undefined, excludeIds: number[] | null | undefined, entityId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeviewItem> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllWithChildsForContactAsTreeViewWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectClassificationNameFilter !== undefined && sycEntityObjectClassificationNameFilter !== null)
            url_ += "SycEntityObjectClassificationNameFilter=" + encodeURIComponent("" + sycEntityObjectClassificationNameFilter) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (excludeIds !== undefined && excludeIds !== null)
            excludeIds && excludeIds.forEach(item => { url_ += "ExcludeIds=" + encodeURIComponent("" + item) + "&"; });
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContactAsTreeViewWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContactAsTreeViewWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeviewItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeviewItem>;
        }));
    }

    protected processGetAllWithChildsForContactAsTreeViewWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeviewItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeviewItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllWithChildsForContactAsTreeView(): Observable<PagedResultDtoOfTreeviewItem> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllWithChildsForContactAsTreeView";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForContactAsTreeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForContactAsTreeView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeviewItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeviewItem>;
        }));
    }

    protected processGetAllWithChildsForContactAsTreeView(response: HttpResponseBase): Observable<PagedResultDtoOfTreeviewItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeviewItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectClassificationForView(id: number | undefined): Observable<GetSycEntityObjectClassificationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetSycEntityObjectClassificationForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectClassificationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectClassificationForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectClassificationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectClassificationForViewDto>;
        }));
    }

    protected processGetSycEntityObjectClassificationForView(response: HttpResponseBase): Observable<GetSycEntityObjectClassificationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectClassificationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectClassificationForEdit(id: number | undefined): Observable<GetSycEntityObjectClassificationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetSycEntityObjectClassificationForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectClassificationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectClassificationForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectClassificationForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectClassificationForEditOutput>;
        }));
    }

    protected processGetSycEntityObjectClassificationForEdit(response: HttpResponseBase): Observable<GetSycEntityObjectClassificationForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectClassificationForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycEntityObjectClassificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditForObjectProduct(body: CreateOrEditSycEntityObjectClassificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/CreateOrEditForObjectProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditForObjectProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditForObjectProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditForObjectProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectClassificationNameFilter (optional) 
     * @return Success
     */
    getSycEntityObjectClassificationsToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectClassificationNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetSycEntityObjectClassificationsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectClassificationNameFilter !== undefined && sycEntityObjectClassificationNameFilter !== null)
            url_ += "SycEntityObjectClassificationNameFilter=" + encodeURIComponent("" + sycEntityObjectClassificationNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectClassificationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectClassificationsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycEntityObjectClassificationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSydObjectForTableDropdown(): Observable<SycEntityObjectClassificationSydObjectLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllSydObjectForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSydObjectForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSydObjectForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectClassificationSydObjectLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectClassificationSydObjectLookupTableDto[]>;
        }));
    }

    protected processGetAllSydObjectForTableDropdown(response: HttpResponseBase): Observable<SycEntityObjectClassificationSydObjectLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityObjectClassificationSydObjectLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycEntityObjectClassificationForTableDropdown(): Observable<SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectClassifications/GetAllSycEntityObjectClassificationForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycEntityObjectClassificationForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycEntityObjectClassificationForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto[]>;
        }));
    }

    protected processGetAllSycEntityObjectClassificationForTableDropdown(response: HttpResponseBase): Observable<SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycEntityObjectStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sydObjectCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sydObjectCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycEntityObjectStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectStatuses/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sydObjectCodeFilter !== undefined && sydObjectCodeFilter !== null)
            url_ += "SydObjectCodeFilter=" + encodeURIComponent("" + sydObjectCodeFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycEntityObjectStatusForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycEntityObjectStatusForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycEntityObjectStatusForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycEntityObjectStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectStatusForView(id: number | undefined): Observable<GetSycEntityObjectStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectStatuses/GetSycEntityObjectStatusForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectStatusForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectStatusForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectStatusForViewDto>;
        }));
    }

    protected processGetSycEntityObjectStatusForView(response: HttpResponseBase): Observable<GetSycEntityObjectStatusForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectStatusForEdit(id: number | undefined): Observable<GetSycEntityObjectStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectStatuses/GetSycEntityObjectStatusForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectStatusForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectStatusForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectStatusForEditOutput>;
        }));
    }

    protected processGetSycEntityObjectStatusForEdit(response: HttpResponseBase): Observable<GetSycEntityObjectStatusForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycEntityObjectStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectStatuses/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @return Success
     */
    getSycEntityObjectStatusesToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectStatuses/GetSycEntityObjectStatusesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectStatusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectStatusesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycEntityObjectStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSydObjectForTableDropdown(): Observable<SycEntityObjectStatusSydObjectLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectStatuses/GetAllSydObjectForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSydObjectForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSydObjectForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectStatusSydObjectLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectStatusSydObjectLookupTableDto[]>;
        }));
    }

    protected processGetAllSydObjectForTableDropdown(response: HttpResponseBase): Observable<SycEntityObjectStatusSydObjectLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityObjectStatusSydObjectLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycEntityObjectTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDefaultLanguage(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetDefaultLanguage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllWithExtraAttributes(id: number | undefined): Observable<GetAllEntityObjectTypeOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllWithExtraAttributes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithExtraAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithExtraAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllEntityObjectTypeOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllEntityObjectTypeOutput[]>;
        }));
    }

    protected processGetAllWithExtraAttributes(response: HttpResponseBase): Observable<GetAllEntityObjectTypeOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllEntityObjectTypeOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getAllWithExtraAttributesByCode(code: string | null | undefined): Observable<GetAllEntityObjectTypeOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllWithExtraAttributesByCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithExtraAttributesByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithExtraAttributesByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllEntityObjectTypeOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllEntityObjectTypeOutput[]>;
        }));
    }

    protected processGetAllWithExtraAttributesByCode(response: HttpResponseBase): Observable<GetAllEntityObjectTypeOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllEntityObjectTypeOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sydObjectIdFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param hidden (optional) 
     * @param parentIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, extraDataFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sydObjectIdFilter: number | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, hidden: boolean | null | undefined, parentIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sydObjectIdFilter === null)
            throw new Error("The parameter 'sydObjectIdFilter' cannot be null.");
        else if (sydObjectIdFilter !== undefined)
            url_ += "SydObjectIdFilter=" + encodeURIComponent("" + sydObjectIdFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (hidden !== undefined && hidden !== null)
            url_ += "Hidden=" + encodeURIComponent("" + hidden) + "&";
        if (parentIds !== undefined && parentIds !== null)
            parentIds && parentIds.forEach(item => { url_ += "ParentIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllParentsIds(): Observable<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllParentsIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllParentsIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllParentsIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectItemDto[]>;
        }));
    }

    protected processGetAllParentsIds(response: HttpResponseBase): Observable<SelectItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllWithChildsForProduct(): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllWithChildsForProduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
        }));
    }

    protected processGetAllWithChildsForProduct(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sydObjectIdFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @param hidden (optional) 
     * @param parentIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithChildsForProductWithPaging(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, extraDataFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sydObjectIdFilter: number | undefined, sycEntityObjectTypeNameFilter: string | null | undefined, hidden: boolean | null | undefined, parentIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllWithChildsForProductWithPaging?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sydObjectIdFilter === null)
            throw new Error("The parameter 'sydObjectIdFilter' cannot be null.");
        else if (sydObjectIdFilter !== undefined)
            url_ += "SydObjectIdFilter=" + encodeURIComponent("" + sydObjectIdFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        if (hidden !== undefined && hidden !== null)
            url_ += "Hidden=" + encodeURIComponent("" + hidden) + "&";
        if (parentIds !== undefined && parentIds !== null)
            parentIds && parentIds.forEach(item => { url_ += "ParentIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithChildsForProductWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithChildsForProductWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
        }));
    }

    protected processGetAllWithChildsForProductWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getAllChilds(parentId: number | undefined): Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllChilds?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChilds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChilds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]>;
        }));
    }

    protected processGetAllChilds(response: HttpResponseBase): Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllChildsWithPaging(parentId: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllChildsWithPaging?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChildsWithPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChildsWithPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto>;
        }));
    }

    protected processGetAllChildsWithPaging(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getChilds(parentId: number | undefined): Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetChilds?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChilds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChilds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]>;
        }));
    }

    protected processGetChilds(response: HttpResponseBase): Observable<TreeNodeOfGetSycEntityObjectTypeForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectTypeForView(id: number | undefined): Observable<GetSycEntityObjectTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetSycEntityObjectTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectTypeForViewDto>;
        }));
    }

    protected processGetSycEntityObjectTypeForView(response: HttpResponseBase): Observable<GetSycEntityObjectTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycEntityObjectTypeForEdit(id: number | undefined): Observable<GetSycEntityObjectTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetSycEntityObjectTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycEntityObjectTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycEntityObjectTypeForEditOutput>;
        }));
    }

    protected processGetSycEntityObjectTypeForEdit(response: HttpResponseBase): Observable<GetSycEntityObjectTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycEntityObjectTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycEntityObjectTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param extraDataFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sycEntityObjectTypeNameFilter (optional) 
     * @return Success
     */
    getSycEntityObjectTypesToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, extraDataFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sycEntityObjectTypeNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetSycEntityObjectTypesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (extraDataFilter !== undefined && extraDataFilter !== null)
            url_ += "ExtraDataFilter=" + encodeURIComponent("" + extraDataFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sycEntityObjectTypeNameFilter !== undefined && sycEntityObjectTypeNameFilter !== null)
            url_ += "SycEntityObjectTypeNameFilter=" + encodeURIComponent("" + sycEntityObjectTypeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycEntityObjectTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycEntityObjectTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycEntityObjectTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSydObjectForTableDropdown(): Observable<SycEntityObjectTypeSydObjectLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllSydObjectForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSydObjectForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSydObjectForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectTypeSydObjectLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectTypeSydObjectLookupTableDto[]>;
        }));
    }

    protected processGetAllSydObjectForTableDropdown(response: HttpResponseBase): Observable<SycEntityObjectTypeSydObjectLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityObjectTypeSydObjectLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycEntityObjectTypeForTableDropdown(): Observable<SycEntityObjectTypeSycEntityObjectTypeLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllSycEntityObjectTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycEntityObjectTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycEntityObjectTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectTypeSycEntityObjectTypeLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectTypeSycEntityObjectTypeLookupTableDto[]>;
        }));
    }

    protected processGetAllSycEntityObjectTypeForTableDropdown(response: HttpResponseBase): Observable<SycEntityObjectTypeSycEntityObjectTypeLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycEntityObjectTypeSycEntityObjectTypeLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSycIdentifierDefinitionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SycEntityObjectTypes/GetAllSycIdentifierDefinitionForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycIdentifierDefinitionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycIdentifierDefinitionForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto>;
        }));
    }

    protected processGetAllSycIdentifierDefinitionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycIdentifierDefinitionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param isTenantLevelFilter (optional) 
     * @param maxNumberOfSegmentsFilter (optional) 
     * @param minNumberOfSegmentsFilter (optional) 
     * @param maxMaxLengthFilter (optional) 
     * @param minMaxLengthFilter (optional) 
     * @param maxMinSegmentLengthFilter (optional) 
     * @param minMinSegmentLengthFilter (optional) 
     * @param maxMaxSegmentLengthFilter (optional) 
     * @param minMaxSegmentLengthFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, isTenantLevelFilter: number | null | undefined, maxNumberOfSegmentsFilter: number | null | undefined, minNumberOfSegmentsFilter: number | null | undefined, maxMaxLengthFilter: number | null | undefined, minMaxLengthFilter: number | null | undefined, maxMinSegmentLengthFilter: number | null | undefined, minMinSegmentLengthFilter: number | null | undefined, maxMaxSegmentLengthFilter: number | null | undefined, minMaxSegmentLengthFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycIdentifierDefinitionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (isTenantLevelFilter !== undefined && isTenantLevelFilter !== null)
            url_ += "IsTenantLevelFilter=" + encodeURIComponent("" + isTenantLevelFilter) + "&";
        if (maxNumberOfSegmentsFilter !== undefined && maxNumberOfSegmentsFilter !== null)
            url_ += "MaxNumberOfSegmentsFilter=" + encodeURIComponent("" + maxNumberOfSegmentsFilter) + "&";
        if (minNumberOfSegmentsFilter !== undefined && minNumberOfSegmentsFilter !== null)
            url_ += "MinNumberOfSegmentsFilter=" + encodeURIComponent("" + minNumberOfSegmentsFilter) + "&";
        if (maxMaxLengthFilter !== undefined && maxMaxLengthFilter !== null)
            url_ += "MaxMaxLengthFilter=" + encodeURIComponent("" + maxMaxLengthFilter) + "&";
        if (minMaxLengthFilter !== undefined && minMaxLengthFilter !== null)
            url_ += "MinMaxLengthFilter=" + encodeURIComponent("" + minMaxLengthFilter) + "&";
        if (maxMinSegmentLengthFilter !== undefined && maxMinSegmentLengthFilter !== null)
            url_ += "MaxMinSegmentLengthFilter=" + encodeURIComponent("" + maxMinSegmentLengthFilter) + "&";
        if (minMinSegmentLengthFilter !== undefined && minMinSegmentLengthFilter !== null)
            url_ += "MinMinSegmentLengthFilter=" + encodeURIComponent("" + minMinSegmentLengthFilter) + "&";
        if (maxMaxSegmentLengthFilter !== undefined && maxMaxSegmentLengthFilter !== null)
            url_ += "MaxMaxSegmentLengthFilter=" + encodeURIComponent("" + maxMaxSegmentLengthFilter) + "&";
        if (minMaxSegmentLengthFilter !== undefined && minMaxSegmentLengthFilter !== null)
            url_ += "MinMaxSegmentLengthFilter=" + encodeURIComponent("" + minMaxSegmentLengthFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycIdentifierDefinitionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycIdentifierDefinitionForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycIdentifierDefinitionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycIdentifierDefinitionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycIdentifierDefinitionForView(id: number | undefined): Observable<GetSycIdentifierDefinitionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetSycIdentifierDefinitionForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycIdentifierDefinitionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycIdentifierDefinitionForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycIdentifierDefinitionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycIdentifierDefinitionForViewDto>;
        }));
    }

    protected processGetSycIdentifierDefinitionForView(response: HttpResponseBase): Observable<GetSycIdentifierDefinitionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycIdentifierDefinitionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getSycIdentifierDefinitionByCodeForCurrentTenant(code: string | null | undefined): Observable<SycIdentifierDefinition> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetSycIdentifierDefinitionByCodeForCurrentTenant?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycIdentifierDefinitionByCodeForCurrentTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycIdentifierDefinitionByCodeForCurrentTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycIdentifierDefinition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycIdentifierDefinition>;
        }));
    }

    protected processGetSycIdentifierDefinitionByCodeForCurrentTenant(response: HttpResponseBase): Observable<SycIdentifierDefinition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SycIdentifierDefinition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getSycIdentifierDefinitionByTypeForView(code: string | null | undefined): Observable<GetSycIdentifierDefinitionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetSycIdentifierDefinitionByTypeForView?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycIdentifierDefinitionByTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycIdentifierDefinitionByTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycIdentifierDefinitionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycIdentifierDefinitionForViewDto>;
        }));
    }

    protected processGetSycIdentifierDefinitionByTypeForView(response: HttpResponseBase): Observable<GetSycIdentifierDefinitionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycIdentifierDefinitionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getNextEntityCode(code: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetNextEntityCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextEntityCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextEntityCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetNextEntityCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycIdentifierDefinitionForEdit(id: number | undefined): Observable<GetSycIdentifierDefinitionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetSycIdentifierDefinitionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycIdentifierDefinitionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycIdentifierDefinitionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycIdentifierDefinitionForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycIdentifierDefinitionForEditOutput>;
        }));
    }

    protected processGetSycIdentifierDefinitionForEdit(response: HttpResponseBase): Observable<GetSycIdentifierDefinitionForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycIdentifierDefinitionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycIdentifierDefinitionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSycIdentifierDefinitionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetAllSycIdentifierDefinitionForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycIdentifierDefinitionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycIdentifierDefinitionForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto>;
        }));
    }

    protected processGetAllSycIdentifierDefinitionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param isTenantLevelFilter (optional) 
     * @param maxNumberOfSegmentsFilter (optional) 
     * @param minNumberOfSegmentsFilter (optional) 
     * @param maxMaxLengthFilter (optional) 
     * @param minMaxLengthFilter (optional) 
     * @param maxMinSegmentLengthFilter (optional) 
     * @param minMinSegmentLengthFilter (optional) 
     * @param maxMaxSegmentLengthFilter (optional) 
     * @param minMaxSegmentLengthFilter (optional) 
     * @return Success
     */
    getSycIdentifierDefinitionsToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, isTenantLevelFilter: number | null | undefined, maxNumberOfSegmentsFilter: number | null | undefined, minNumberOfSegmentsFilter: number | null | undefined, maxMaxLengthFilter: number | null | undefined, minMaxLengthFilter: number | null | undefined, maxMinSegmentLengthFilter: number | null | undefined, minMinSegmentLengthFilter: number | null | undefined, maxMaxSegmentLengthFilter: number | null | undefined, minMaxSegmentLengthFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycIdentifierDefinitions/GetSycIdentifierDefinitionsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (isTenantLevelFilter !== undefined && isTenantLevelFilter !== null)
            url_ += "IsTenantLevelFilter=" + encodeURIComponent("" + isTenantLevelFilter) + "&";
        if (maxNumberOfSegmentsFilter !== undefined && maxNumberOfSegmentsFilter !== null)
            url_ += "MaxNumberOfSegmentsFilter=" + encodeURIComponent("" + maxNumberOfSegmentsFilter) + "&";
        if (minNumberOfSegmentsFilter !== undefined && minNumberOfSegmentsFilter !== null)
            url_ += "MinNumberOfSegmentsFilter=" + encodeURIComponent("" + minNumberOfSegmentsFilter) + "&";
        if (maxMaxLengthFilter !== undefined && maxMaxLengthFilter !== null)
            url_ += "MaxMaxLengthFilter=" + encodeURIComponent("" + maxMaxLengthFilter) + "&";
        if (minMaxLengthFilter !== undefined && minMaxLengthFilter !== null)
            url_ += "MinMaxLengthFilter=" + encodeURIComponent("" + minMaxLengthFilter) + "&";
        if (maxMinSegmentLengthFilter !== undefined && maxMinSegmentLengthFilter !== null)
            url_ += "MaxMinSegmentLengthFilter=" + encodeURIComponent("" + maxMinSegmentLengthFilter) + "&";
        if (minMinSegmentLengthFilter !== undefined && minMinSegmentLengthFilter !== null)
            url_ += "MinMinSegmentLengthFilter=" + encodeURIComponent("" + minMinSegmentLengthFilter) + "&";
        if (maxMaxSegmentLengthFilter !== undefined && maxMaxSegmentLengthFilter !== null)
            url_ += "MaxMaxSegmentLengthFilter=" + encodeURIComponent("" + maxMaxSegmentLengthFilter) + "&";
        if (minMaxSegmentLengthFilter !== undefined && minMaxSegmentLengthFilter !== null)
            url_ += "MinMaxSegmentLengthFilter=" + encodeURIComponent("" + minMaxSegmentLengthFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycIdentifierDefinitionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycIdentifierDefinitionsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycIdentifierDefinitionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycPlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param notesFilter (optional) 
     * @param sycApplicationNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, notesFilter: string | null | undefined, sycApplicationNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycPlanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycPlans/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (notesFilter !== undefined && notesFilter !== null)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (sycApplicationNameFilter !== undefined && sycApplicationNameFilter !== null)
            url_ += "SycApplicationNameFilter=" + encodeURIComponent("" + sycApplicationNameFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycPlanForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycPlanForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycPlanForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycPlanForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycPlanForView(id: number | undefined): Observable<GetSycPlanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycPlans/GetSycPlanForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycPlanForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycPlanForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycPlanForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycPlanForViewDto>;
        }));
    }

    protected processGetSycPlanForView(response: HttpResponseBase): Observable<GetSycPlanForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycPlanForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycPlanForEdit(id: number | undefined): Observable<GetSycPlanForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycPlans/GetSycPlanForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycPlanForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycPlanForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycPlanForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycPlanForEditOutput>;
        }));
    }

    protected processGetSycPlanForEdit(response: HttpResponseBase): Observable<GetSycPlanForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycPlanForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycPlanDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycPlans/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycPlans/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param notesFilter (optional) 
     * @param sycApplicationNameFilter (optional) 
     * @return Success
     */
    getSycPlansToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, notesFilter: string | null | undefined, sycApplicationNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycPlans/GetSycPlansToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (notesFilter !== undefined && notesFilter !== null)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (sycApplicationNameFilter !== undefined && sycApplicationNameFilter !== null)
            url_ += "SycApplicationNameFilter=" + encodeURIComponent("" + sycApplicationNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycPlansToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycPlansToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycPlansToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycApplicationForTableDropdown(): Observable<SycPlanSycApplicationLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycPlans/GetAllSycApplicationForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycApplicationForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycApplicationForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycPlanSycApplicationLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycPlanSycApplicationLookupTableDto[]>;
        }));
    }

    protected processGetAllSycApplicationForTableDropdown(response: HttpResponseBase): Observable<SycPlanSycApplicationLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycPlanSycApplicationLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycPlanServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param unitOfMeasureFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxUnitsFilter (optional) 
     * @param minUnitsFilter (optional) 
     * @param billingFrequencyFilter (optional) 
     * @param maxMinimumUnitsFilter (optional) 
     * @param minMinimumUnitsFilter (optional) 
     * @param sycApplicationNameFilter (optional) 
     * @param sycPlanNameFilter (optional) 
     * @param sycServiceCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, unitOfMeasureFilter: string | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxUnitsFilter: number | null | undefined, minUnitsFilter: number | null | undefined, billingFrequencyFilter: string | null | undefined, maxMinimumUnitsFilter: number | null | undefined, minMinimumUnitsFilter: number | null | undefined, sycApplicationNameFilter: string | null | undefined, sycPlanNameFilter: string | null | undefined, sycServiceCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycPlanServiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (unitOfMeasureFilter !== undefined && unitOfMeasureFilter !== null)
            url_ += "UnitOfMeasureFilter=" + encodeURIComponent("" + unitOfMeasureFilter) + "&";
        if (maxUnitPriceFilter !== undefined && maxUnitPriceFilter !== null)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter !== undefined && minUnitPriceFilter !== null)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxUnitsFilter !== undefined && maxUnitsFilter !== null)
            url_ += "MaxUnitsFilter=" + encodeURIComponent("" + maxUnitsFilter) + "&";
        if (minUnitsFilter !== undefined && minUnitsFilter !== null)
            url_ += "MinUnitsFilter=" + encodeURIComponent("" + minUnitsFilter) + "&";
        if (billingFrequencyFilter !== undefined && billingFrequencyFilter !== null)
            url_ += "BillingFrequencyFilter=" + encodeURIComponent("" + billingFrequencyFilter) + "&";
        if (maxMinimumUnitsFilter !== undefined && maxMinimumUnitsFilter !== null)
            url_ += "MaxMinimumUnitsFilter=" + encodeURIComponent("" + maxMinimumUnitsFilter) + "&";
        if (minMinimumUnitsFilter !== undefined && minMinimumUnitsFilter !== null)
            url_ += "MinMinimumUnitsFilter=" + encodeURIComponent("" + minMinimumUnitsFilter) + "&";
        if (sycApplicationNameFilter !== undefined && sycApplicationNameFilter !== null)
            url_ += "SycApplicationNameFilter=" + encodeURIComponent("" + sycApplicationNameFilter) + "&";
        if (sycPlanNameFilter !== undefined && sycPlanNameFilter !== null)
            url_ += "SycPlanNameFilter=" + encodeURIComponent("" + sycPlanNameFilter) + "&";
        if (sycServiceCodeFilter !== undefined && sycServiceCodeFilter !== null)
            url_ += "SycServiceCodeFilter=" + encodeURIComponent("" + sycServiceCodeFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycPlanServiceForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycPlanServiceForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycPlanServiceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycPlanServiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycPlanServiceForView(id: number | undefined): Observable<GetSycPlanServiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/GetSycPlanServiceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycPlanServiceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycPlanServiceForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycPlanServiceForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycPlanServiceForViewDto>;
        }));
    }

    protected processGetSycPlanServiceForView(response: HttpResponseBase): Observable<GetSycPlanServiceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycPlanServiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycPlanServiceForEdit(id: number | undefined): Observable<GetSycPlanServiceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/GetSycPlanServiceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycPlanServiceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycPlanServiceForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycPlanServiceForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycPlanServiceForEditOutput>;
        }));
    }

    protected processGetSycPlanServiceForEdit(response: HttpResponseBase): Observable<GetSycPlanServiceForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycPlanServiceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycPlanServiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param unitOfMeasureFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxUnitsFilter (optional) 
     * @param minUnitsFilter (optional) 
     * @param billingFrequencyFilter (optional) 
     * @param maxMinimumUnitsFilter (optional) 
     * @param minMinimumUnitsFilter (optional) 
     * @param sycApplicationNameFilter (optional) 
     * @param sycPlanNameFilter (optional) 
     * @param sycServiceCodeFilter (optional) 
     * @return Success
     */
    getSycPlanServicesToExcel(filter: string | null | undefined, unitOfMeasureFilter: string | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxUnitsFilter: number | null | undefined, minUnitsFilter: number | null | undefined, billingFrequencyFilter: string | null | undefined, maxMinimumUnitsFilter: number | null | undefined, minMinimumUnitsFilter: number | null | undefined, sycApplicationNameFilter: string | null | undefined, sycPlanNameFilter: string | null | undefined, sycServiceCodeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/GetSycPlanServicesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (unitOfMeasureFilter !== undefined && unitOfMeasureFilter !== null)
            url_ += "UnitOfMeasureFilter=" + encodeURIComponent("" + unitOfMeasureFilter) + "&";
        if (maxUnitPriceFilter !== undefined && maxUnitPriceFilter !== null)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter !== undefined && minUnitPriceFilter !== null)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxUnitsFilter !== undefined && maxUnitsFilter !== null)
            url_ += "MaxUnitsFilter=" + encodeURIComponent("" + maxUnitsFilter) + "&";
        if (minUnitsFilter !== undefined && minUnitsFilter !== null)
            url_ += "MinUnitsFilter=" + encodeURIComponent("" + minUnitsFilter) + "&";
        if (billingFrequencyFilter !== undefined && billingFrequencyFilter !== null)
            url_ += "BillingFrequencyFilter=" + encodeURIComponent("" + billingFrequencyFilter) + "&";
        if (maxMinimumUnitsFilter !== undefined && maxMinimumUnitsFilter !== null)
            url_ += "MaxMinimumUnitsFilter=" + encodeURIComponent("" + maxMinimumUnitsFilter) + "&";
        if (minMinimumUnitsFilter !== undefined && minMinimumUnitsFilter !== null)
            url_ += "MinMinimumUnitsFilter=" + encodeURIComponent("" + minMinimumUnitsFilter) + "&";
        if (sycApplicationNameFilter !== undefined && sycApplicationNameFilter !== null)
            url_ += "SycApplicationNameFilter=" + encodeURIComponent("" + sycApplicationNameFilter) + "&";
        if (sycPlanNameFilter !== undefined && sycPlanNameFilter !== null)
            url_ += "SycPlanNameFilter=" + encodeURIComponent("" + sycPlanNameFilter) + "&";
        if (sycServiceCodeFilter !== undefined && sycServiceCodeFilter !== null)
            url_ += "SycServiceCodeFilter=" + encodeURIComponent("" + sycServiceCodeFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycPlanServicesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycPlanServicesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycPlanServicesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycApplicationForTableDropdown(): Observable<SycPlanServiceSycApplicationLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/GetAllSycApplicationForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycApplicationForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycApplicationForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycPlanServiceSycApplicationLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycPlanServiceSycApplicationLookupTableDto[]>;
        }));
    }

    protected processGetAllSycApplicationForTableDropdown(response: HttpResponseBase): Observable<SycPlanServiceSycApplicationLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycPlanServiceSycApplicationLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycPlanForTableDropdown(): Observable<SycPlanServiceSycPlanLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/GetAllSycPlanForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycPlanForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycPlanForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycPlanServiceSycPlanLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycPlanServiceSycPlanLookupTableDto[]>;
        }));
    }

    protected processGetAllSycPlanForTableDropdown(response: HttpResponseBase): Observable<SycPlanServiceSycPlanLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycPlanServiceSycPlanLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSycServiceForTableDropdown(): Observable<SycPlanServiceSycServiceLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SycPlanServices/GetAllSycServiceForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycServiceForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycServiceForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycPlanServiceSycServiceLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycPlanServiceSycServiceLookupTableDto[]>;
        }));
    }

    protected processGetAllSycServiceForTableDropdown(response: HttpResponseBase): Observable<SycPlanServiceSycServiceLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SycPlanServiceSycServiceLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param entityObjectTypeCode (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, entityObjectTypeCode: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycReportForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycReports/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (entityObjectTypeCode !== undefined && entityObjectTypeCode !== null)
            url_ += "EntityObjectTypeCode=" + encodeURIComponent("" + entityObjectTypeCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycReportForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycReportForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycReportForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycReportForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycSegmentIdentifierDefinitionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param maxSegmentNumberFilter (optional) 
     * @param minSegmentNumberFilter (optional) 
     * @param segmentHeaderFilter (optional) 
     * @param segmentMaskFilter (optional) 
     * @param maxSegmentLengthFilter (optional) 
     * @param minSegmentLengthFilter (optional) 
     * @param segmentTypeFilter (optional) 
     * @param isAutoGeneratedFilter (optional) 
     * @param isEditableFilter (optional) 
     * @param isVisibleFilter (optional) 
     * @param maxCodeStartingValueFilter (optional) 
     * @param minCodeStartingValueFilter (optional) 
     * @param lookOrFieldNameFilter (optional) 
     * @param sycIdentifierDefinitionCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, maxSegmentNumberFilter: number | null | undefined, minSegmentNumberFilter: number | null | undefined, segmentHeaderFilter: string | null | undefined, segmentMaskFilter: string | null | undefined, maxSegmentLengthFilter: number | null | undefined, minSegmentLengthFilter: number | null | undefined, segmentTypeFilter: string | null | undefined, isAutoGeneratedFilter: number | null | undefined, isEditableFilter: number | null | undefined, isVisibleFilter: number | null | undefined, maxCodeStartingValueFilter: number | null | undefined, minCodeStartingValueFilter: number | null | undefined, lookOrFieldNameFilter: string | null | undefined, sycIdentifierDefinitionCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycSegmentIdentifierDefinitions/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (maxSegmentNumberFilter !== undefined && maxSegmentNumberFilter !== null)
            url_ += "MaxSegmentNumberFilter=" + encodeURIComponent("" + maxSegmentNumberFilter) + "&";
        if (minSegmentNumberFilter !== undefined && minSegmentNumberFilter !== null)
            url_ += "MinSegmentNumberFilter=" + encodeURIComponent("" + minSegmentNumberFilter) + "&";
        if (segmentHeaderFilter !== undefined && segmentHeaderFilter !== null)
            url_ += "SegmentHeaderFilter=" + encodeURIComponent("" + segmentHeaderFilter) + "&";
        if (segmentMaskFilter !== undefined && segmentMaskFilter !== null)
            url_ += "SegmentMaskFilter=" + encodeURIComponent("" + segmentMaskFilter) + "&";
        if (maxSegmentLengthFilter !== undefined && maxSegmentLengthFilter !== null)
            url_ += "MaxSegmentLengthFilter=" + encodeURIComponent("" + maxSegmentLengthFilter) + "&";
        if (minSegmentLengthFilter !== undefined && minSegmentLengthFilter !== null)
            url_ += "MinSegmentLengthFilter=" + encodeURIComponent("" + minSegmentLengthFilter) + "&";
        if (segmentTypeFilter !== undefined && segmentTypeFilter !== null)
            url_ += "SegmentTypeFilter=" + encodeURIComponent("" + segmentTypeFilter) + "&";
        if (isAutoGeneratedFilter !== undefined && isAutoGeneratedFilter !== null)
            url_ += "IsAutoGeneratedFilter=" + encodeURIComponent("" + isAutoGeneratedFilter) + "&";
        if (isEditableFilter !== undefined && isEditableFilter !== null)
            url_ += "IsEditableFilter=" + encodeURIComponent("" + isEditableFilter) + "&";
        if (isVisibleFilter !== undefined && isVisibleFilter !== null)
            url_ += "IsVisibleFilter=" + encodeURIComponent("" + isVisibleFilter) + "&";
        if (maxCodeStartingValueFilter !== undefined && maxCodeStartingValueFilter !== null)
            url_ += "MaxCodeStartingValueFilter=" + encodeURIComponent("" + maxCodeStartingValueFilter) + "&";
        if (minCodeStartingValueFilter !== undefined && minCodeStartingValueFilter !== null)
            url_ += "MinCodeStartingValueFilter=" + encodeURIComponent("" + minCodeStartingValueFilter) + "&";
        if (lookOrFieldNameFilter !== undefined && lookOrFieldNameFilter !== null)
            url_ += "LookOrFieldNameFilter=" + encodeURIComponent("" + lookOrFieldNameFilter) + "&";
        if (sycIdentifierDefinitionCodeFilter !== undefined && sycIdentifierDefinitionCodeFilter !== null)
            url_ += "SycIdentifierDefinitionCodeFilter=" + encodeURIComponent("" + sycIdentifierDefinitionCodeFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycSegmentIdentifierDefinitionForView(id: number | undefined): Observable<GetSycSegmentIdentifierDefinitionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycSegmentIdentifierDefinitions/GetSycSegmentIdentifierDefinitionForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycSegmentIdentifierDefinitionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycSegmentIdentifierDefinitionForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycSegmentIdentifierDefinitionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycSegmentIdentifierDefinitionForViewDto>;
        }));
    }

    protected processGetSycSegmentIdentifierDefinitionForView(response: HttpResponseBase): Observable<GetSycSegmentIdentifierDefinitionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycSegmentIdentifierDefinitionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycSegmentIdentifierDefinitionForEdit(id: number | undefined): Observable<GetSycSegmentIdentifierDefinitionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycSegmentIdentifierDefinitions/GetSycSegmentIdentifierDefinitionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycSegmentIdentifierDefinitionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycSegmentIdentifierDefinitionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycSegmentIdentifierDefinitionForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycSegmentIdentifierDefinitionForEditOutput>;
        }));
    }

    protected processGetSycSegmentIdentifierDefinitionForEdit(response: HttpResponseBase): Observable<GetSycSegmentIdentifierDefinitionForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycSegmentIdentifierDefinitionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycSegmentIdentifierDefinitionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycSegmentIdentifierDefinitions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycSegmentIdentifierDefinitions/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param maxSegmentNumberFilter (optional) 
     * @param minSegmentNumberFilter (optional) 
     * @param segmentHeaderFilter (optional) 
     * @param segmentMaskFilter (optional) 
     * @param maxSegmentLengthFilter (optional) 
     * @param minSegmentLengthFilter (optional) 
     * @param segmentTypeFilter (optional) 
     * @param isAutoGeneratedFilter (optional) 
     * @param isEditableFilter (optional) 
     * @param isVisibleFilter (optional) 
     * @param maxCodeStartingValueFilter (optional) 
     * @param minCodeStartingValueFilter (optional) 
     * @param lookOrFieldNameFilter (optional) 
     * @param sycIdentifierDefinitionCodeFilter (optional) 
     * @return Success
     */
    getSycSegmentIdentifierDefinitionsToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, maxSegmentNumberFilter: number | null | undefined, minSegmentNumberFilter: number | null | undefined, segmentHeaderFilter: string | null | undefined, segmentMaskFilter: string | null | undefined, maxSegmentLengthFilter: number | null | undefined, minSegmentLengthFilter: number | null | undefined, segmentTypeFilter: string | null | undefined, isAutoGeneratedFilter: number | null | undefined, isEditableFilter: number | null | undefined, isVisibleFilter: number | null | undefined, maxCodeStartingValueFilter: number | null | undefined, minCodeStartingValueFilter: number | null | undefined, lookOrFieldNameFilter: string | null | undefined, sycIdentifierDefinitionCodeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycSegmentIdentifierDefinitions/GetSycSegmentIdentifierDefinitionsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (nameFilter !== undefined && nameFilter !== null)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (maxSegmentNumberFilter !== undefined && maxSegmentNumberFilter !== null)
            url_ += "MaxSegmentNumberFilter=" + encodeURIComponent("" + maxSegmentNumberFilter) + "&";
        if (minSegmentNumberFilter !== undefined && minSegmentNumberFilter !== null)
            url_ += "MinSegmentNumberFilter=" + encodeURIComponent("" + minSegmentNumberFilter) + "&";
        if (segmentHeaderFilter !== undefined && segmentHeaderFilter !== null)
            url_ += "SegmentHeaderFilter=" + encodeURIComponent("" + segmentHeaderFilter) + "&";
        if (segmentMaskFilter !== undefined && segmentMaskFilter !== null)
            url_ += "SegmentMaskFilter=" + encodeURIComponent("" + segmentMaskFilter) + "&";
        if (maxSegmentLengthFilter !== undefined && maxSegmentLengthFilter !== null)
            url_ += "MaxSegmentLengthFilter=" + encodeURIComponent("" + maxSegmentLengthFilter) + "&";
        if (minSegmentLengthFilter !== undefined && minSegmentLengthFilter !== null)
            url_ += "MinSegmentLengthFilter=" + encodeURIComponent("" + minSegmentLengthFilter) + "&";
        if (segmentTypeFilter !== undefined && segmentTypeFilter !== null)
            url_ += "SegmentTypeFilter=" + encodeURIComponent("" + segmentTypeFilter) + "&";
        if (isAutoGeneratedFilter !== undefined && isAutoGeneratedFilter !== null)
            url_ += "IsAutoGeneratedFilter=" + encodeURIComponent("" + isAutoGeneratedFilter) + "&";
        if (isEditableFilter !== undefined && isEditableFilter !== null)
            url_ += "IsEditableFilter=" + encodeURIComponent("" + isEditableFilter) + "&";
        if (isVisibleFilter !== undefined && isVisibleFilter !== null)
            url_ += "IsVisibleFilter=" + encodeURIComponent("" + isVisibleFilter) + "&";
        if (maxCodeStartingValueFilter !== undefined && maxCodeStartingValueFilter !== null)
            url_ += "MaxCodeStartingValueFilter=" + encodeURIComponent("" + maxCodeStartingValueFilter) + "&";
        if (minCodeStartingValueFilter !== undefined && minCodeStartingValueFilter !== null)
            url_ += "MinCodeStartingValueFilter=" + encodeURIComponent("" + minCodeStartingValueFilter) + "&";
        if (lookOrFieldNameFilter !== undefined && lookOrFieldNameFilter !== null)
            url_ += "LookOrFieldNameFilter=" + encodeURIComponent("" + lookOrFieldNameFilter) + "&";
        if (sycIdentifierDefinitionCodeFilter !== undefined && sycIdentifierDefinitionCodeFilter !== null)
            url_ += "SycIdentifierDefinitionCodeFilter=" + encodeURIComponent("" + sycIdentifierDefinitionCodeFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycSegmentIdentifierDefinitionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycSegmentIdentifierDefinitionsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycSegmentIdentifierDefinitionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSycIdentifierDefinitionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SycSegmentIdentifierDefinitions/GetAllSycIdentifierDefinitionForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSycIdentifierDefinitionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSycIdentifierDefinitionForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto>;
        }));
    }

    protected processGetAllSycIdentifierDefinitionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param unitOfMeasureFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param notesFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, unitOfMeasureFilter: string | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, notesFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycServiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycServices/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (unitOfMeasureFilter !== undefined && unitOfMeasureFilter !== null)
            url_ += "UnitOfMeasureFilter=" + encodeURIComponent("" + unitOfMeasureFilter) + "&";
        if (maxUnitPriceFilter !== undefined && maxUnitPriceFilter !== null)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter !== undefined && minUnitPriceFilter !== null)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (notesFilter !== undefined && notesFilter !== null)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycServiceForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycServiceForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycServiceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycServiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycServiceForView(id: number | undefined): Observable<GetSycServiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycServices/GetSycServiceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycServiceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycServiceForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycServiceForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycServiceForViewDto>;
        }));
    }

    protected processGetSycServiceForView(response: HttpResponseBase): Observable<GetSycServiceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycServiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycServiceForEdit(id: number | undefined): Observable<GetSycServiceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycServices/GetSycServiceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycServiceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycServiceForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycServiceForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycServiceForEditOutput>;
        }));
    }

    protected processGetSycServiceForEdit(response: HttpResponseBase): Observable<GetSycServiceForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycServiceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycServiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycServices/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycServices/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param unitOfMeasureFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param notesFilter (optional) 
     * @return Success
     */
    getSycServicesToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, descriptionFilter: string | null | undefined, unitOfMeasureFilter: string | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, notesFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SycServices/GetSycServicesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (codeFilter !== undefined && codeFilter !== null)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (unitOfMeasureFilter !== undefined && unitOfMeasureFilter !== null)
            url_ += "UnitOfMeasureFilter=" + encodeURIComponent("" + unitOfMeasureFilter) + "&";
        if (maxUnitPriceFilter !== undefined && maxUnitPriceFilter !== null)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter !== undefined && minUnitPriceFilter !== null)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (notesFilter !== undefined && notesFilter !== null)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycServicesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycServicesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSycServicesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SycTenantInvitatiosServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSycTenantInvitatiosForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycTenantInvitatios/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSycTenantInvitatiosForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSycTenantInvitatiosForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSycTenantInvitatiosForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSycTenantInvitatiosForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycTenantInvitatiosForView(id: number | undefined): Observable<GetSycTenantInvitatiosForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SycTenantInvitatios/GetSycTenantInvitatiosForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycTenantInvitatiosForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycTenantInvitatiosForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycTenantInvitatiosForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycTenantInvitatiosForViewDto>;
        }));
    }

    protected processGetSycTenantInvitatiosForView(response: HttpResponseBase): Observable<GetSycTenantInvitatiosForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycTenantInvitatiosForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSycTenantInvitatiosForEdit(id: number | undefined): Observable<GetSycTenantInvitatiosForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SycTenantInvitatios/GetSycTenantInvitatiosForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSycTenantInvitatiosForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSycTenantInvitatiosForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSycTenantInvitatiosForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSycTenantInvitatiosForEditOutput>;
        }));
    }

    protected processGetSycTenantInvitatiosForEdit(response: HttpResponseBase): Observable<GetSycTenantInvitatiosForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSycTenantInvitatiosForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSycTenantInvitatiosDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycTenantInvitatios/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SycTenantInvitatios/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SydObjectsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sysObjectTypeNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sysObjectTypeNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sysObjectTypeNameFilter !== undefined && sysObjectTypeNameFilter !== null)
            url_ += "SysObjectTypeNameFilter=" + encodeURIComponent("" + sysObjectTypeNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getAllChilds(parentId: number | undefined): Observable<TreeNodeOfGetSydObjectForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetAllChilds?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChilds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChilds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfGetSydObjectForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfGetSydObjectForViewDto[]>;
        }));
    }

    protected processGetAllChilds(response: HttpResponseBase): Observable<TreeNodeOfGetSydObjectForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfGetSydObjectForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllLookups(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetAllLookups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetAllLookups(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSydObjectForView(id: number | undefined): Observable<GetSydObjectForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetSydObjectForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSydObjectForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSydObjectForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSydObjectForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSydObjectForViewDto>;
        }));
    }

    protected processGetSydObjectForView(response: HttpResponseBase): Observable<GetSydObjectForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSydObjectForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSydObjectForEdit(id: number | undefined): Observable<GetSydObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetSydObjectForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSydObjectForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSydObjectForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSydObjectForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSydObjectForEditOutput>;
        }));
    }

    protected processGetSydObjectForEdit(response: HttpResponseBase): Observable<GetSydObjectForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSydObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSydObjectDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sysObjectTypeNameFilter (optional) 
     * @param sydObjectNameFilter (optional) 
     * @return Success
     */
    getSydObjectsToExcel(filter: string | null | undefined, sysObjectTypeNameFilter: string | null | undefined, sydObjectNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetSydObjectsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sysObjectTypeNameFilter !== undefined && sysObjectTypeNameFilter !== null)
            url_ += "SysObjectTypeNameFilter=" + encodeURIComponent("" + sysObjectTypeNameFilter) + "&";
        if (sydObjectNameFilter !== undefined && sydObjectNameFilter !== null)
            url_ += "SydObjectNameFilter=" + encodeURIComponent("" + sydObjectNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSydObjectsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSydObjectsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSydObjectsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSysObjectTypeForTableDropdown(): Observable<SydObjectSysObjectTypeLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetAllSysObjectTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysObjectTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysObjectTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SydObjectSysObjectTypeLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SydObjectSysObjectTypeLookupTableDto[]>;
        }));
    }

    protected processGetAllSysObjectTypeForTableDropdown(response: HttpResponseBase): Observable<SydObjectSysObjectTypeLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SydObjectSysObjectTypeLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSydObjectForTableDropdown(): Observable<SydObjectSydObjectLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetAllSydObjectForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSydObjectForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSydObjectForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SydObjectSydObjectLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SydObjectSydObjectLookupTableDto[]>;
        }));
    }

    protected processGetAllSydObjectForTableDropdown(response: HttpResponseBase): Observable<SydObjectSydObjectLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SydObjectSydObjectLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sliderCode (optional) 
     * @return Success
     */
    getAllSliderSettings(sliderType: SliderEnum, sliderCode: string | null | undefined): Observable<PageSettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SydObjects/GetAllSliderSettings?";
        if (sliderType === undefined || sliderType === null)
            throw new Error("The parameter 'sliderType' must be defined and cannot be null.");
        else
            url_ += "sliderType=" + encodeURIComponent("" + sliderType) + "&";
        if (sliderCode !== undefined && sliderCode !== null)
            url_ += "sliderCode=" + encodeURIComponent("" + sliderCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSliderSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSliderSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageSettingDto[]>;
        }));
    }

    protected processGetAllSliderSettings(response: HttpResponseBase): Observable<PageSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageSettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SysObjectTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sysObjectTypeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sysObjectTypeNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sysObjectTypeNameFilter !== undefined && sysObjectTypeNameFilter !== null)
            url_ += "SysObjectTypeNameFilter=" + encodeURIComponent("" + sysObjectTypeNameFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    getAllChilds(parentId: number | undefined): Observable<TreeNodeOfGetSysObjectTypeForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/GetAllChilds?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChilds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChilds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeOfGetSysObjectTypeForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeOfGetSysObjectTypeForViewDto[]>;
        }));
    }

    protected processGetAllChilds(response: HttpResponseBase): Observable<TreeNodeOfGetSysObjectTypeForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeOfGetSysObjectTypeForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSysObjectTypeForView(id: number | undefined): Observable<GetSysObjectTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/GetSysObjectTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysObjectTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysObjectTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSysObjectTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSysObjectTypeForViewDto>;
        }));
    }

    protected processGetSysObjectTypeForView(response: HttpResponseBase): Observable<GetSysObjectTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSysObjectTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSysObjectTypeForEdit(id: number | undefined): Observable<GetSysObjectTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/GetSysObjectTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysObjectTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysObjectTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSysObjectTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSysObjectTypeForEditOutput>;
        }));
    }

    protected processGetSysObjectTypeForEdit(response: HttpResponseBase): Observable<GetSysObjectTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSysObjectTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSysObjectTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sysObjectTypeNameFilter (optional) 
     * @return Success
     */
    getSysObjectTypesToExcel(filter: string | null | undefined, sysObjectTypeNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/GetSysObjectTypesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sysObjectTypeNameFilter !== undefined && sysObjectTypeNameFilter !== null)
            url_ += "SysObjectTypeNameFilter=" + encodeURIComponent("" + sysObjectTypeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysObjectTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysObjectTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSysObjectTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSysObjectTypeForTableDropdown(): Observable<SysObjectTypeSysObjectTypeLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SysObjectTypes/GetAllSysObjectTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysObjectTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysObjectTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysObjectTypeSysObjectTypeLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysObjectTypeSysObjectTypeLookupTableDto[]>;
        }));
    }

    protected processGetAllSysObjectTypeForTableDropdown(response: HttpResponseBase): Observable<SysObjectTypeSysObjectTypeLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysObjectTypeSysObjectTypeLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SystemTablesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getObjectContactId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectContactId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectContactId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectContactId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectContactId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectAdvertisementId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectAdvertisementId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectAdvertisementId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectAdvertisementId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectAdvertisementId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectUserId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectUserId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectUserId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectEventId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectEventId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectEventId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectEventId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectEventId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectEventGuestId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectEventGuestId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectEventGuestId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectEventGuestId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectEventGuestId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectPostId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectPostId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectPostId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectPostId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectPostId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectItemId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectItemId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectItemId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectItemId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectItemId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectListingId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectListingId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectListingId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectListingId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectListingId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectItemDataId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectItemDataId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectItemDataId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectItemDataId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectItemDataId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeParetnerId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeParetnerId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeParetnerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeParetnerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeParetnerId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeParetner(): Observable<SycEntityObjectType> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeParetner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeParetner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeParetner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SycEntityObjectType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SycEntityObjectType>;
        }));
    }

    protected processGetEntityObjectTypeParetner(response: HttpResponseBase): Observable<SycEntityObjectType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SycEntityObjectType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeAdvertisementId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeAdvertisementId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeAdvertisementId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeAdvertisementId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeAdvertisementId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypePersonId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypePersonId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypePersonId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypePersonId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypePersonId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypePostId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypePostId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypePostId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypePostId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypePostId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeUserId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeUserId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeUserId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getEntityObjectTypePostTypeId(type: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypePostTypeId?";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypePostTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypePostTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypePostTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param type (optional) 
     * @param parnet (optional) 
     * @return Success
     */
    getEntityObjectTypeId(type: string | null | undefined, parnet: boolean | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeId?";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (parnet === null)
            throw new Error("The parameter 'parnet' cannot be null.");
        else if (parnet !== undefined)
            url_ += "parnet=" + encodeURIComponent("" + parnet) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypePersonCode(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypePersonCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypePersonCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypePersonCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetEntityObjectTypePersonCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypePersonName(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypePersonName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypePersonName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypePersonName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetEntityObjectTypePersonName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeItemIds(): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeItemIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeItemIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeItemIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetEntityObjectTypeItemIds(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeProductId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeProductId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeProductId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeProductId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypePhoneId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypePhoneId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypePhoneId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypePhoneId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypePhoneId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeCurrencyId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeCurrencyId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeCurrencyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeCurrencyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeCurrencyId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeTitleId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeTitleId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeTitleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeTitleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeTitleId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeCountryId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeCountryId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeCountryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeCountryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeCountryId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeAccountTypeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeAccountTypeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeAccountTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeAccountTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeAccountTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLanguageId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLanguageId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLanguageId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLanguageId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLanguageId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectLookupId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectLookupId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectLookupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectLookupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectLookupId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAttachmentCategoryLogoId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetAttachmentCategoryLogoId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentCategoryLogoId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentCategoryLogoId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetAttachmentCategoryLogoId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getAttachmentCategoryId(code: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetAttachmentCategoryId?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetAttachmentCategoryId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAttachmentCategoryCoverId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetAttachmentCategoryCoverId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentCategoryCoverId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentCategoryCoverId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetAttachmentCategoryCoverId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectClassificationsLableID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectClassificationsLableID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectClassificationsLableID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectClassificationsLableID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectClassificationsLableID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getsydObjectMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetsydObjectMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsydObjectMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsydObjectMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetsydObjectMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeComment(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeComment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeComment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusUnreadMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusUnreadMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusUnreadMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusUnreadMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusUnreadMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusReadMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusReadMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusReadMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusReadMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusReadMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusSentMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusSentMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusSentMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusSentMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusSentMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectClassificationStarredMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectClassificationStarredMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectClassificationStarredMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectClassificationStarredMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectClassificationStarredMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusArchivedMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusArchivedMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusArchivedMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusArchivedMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusArchivedMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusDeletedMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusDeletedMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusDeletedMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusDeletedMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusDeletedMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusDraftMessageID(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusDraftMessageID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusDraftMessageID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusDraftMessageID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusDraftMessageID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusItemActive(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusItemActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusItemActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusItemActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusItemActive(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusContactCancelled(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusContactCancelled";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusContactCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusContactCancelled(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusContactCancelled(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusEventDefault(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusEventDefault";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusEventDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusEventDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusEventDefault(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusItemDraft(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusItemDraft";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusItemDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusItemDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusItemDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeAddressTypeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeAddressTypeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeAddressTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeAddressTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeAddressTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageTypeAttributeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageTypeAttributeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageTypeAttributeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageTypeAttributeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageTypeAttributeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageCodeAttributeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageCodeAttributeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageCodeAttributeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageCodeAttributeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageCodeAttributeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageTitleAttributeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageTitleAttributeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageTitleAttributeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageTitleAttributeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageTitleAttributeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageDescriptionAttributeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageDescriptionAttributeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageDescriptionAttributeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageDescriptionAttributeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageDescriptionAttributeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageOrderAttributeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageOrderAttributeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageOrderAttributeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageOrderAttributeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageOrderAttributeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageLinkUrlAttributeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageLinkUrlAttributeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageLinkUrlAttributeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageLinkUrlAttributeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageLinkUrlAttributeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageTypeId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageTypeId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeLandingPageSettings(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeLandingPageSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeLandingPageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeLandingPageSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeLandingPageSettings(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeSizeScale(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeSizeScale";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeSizeScale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeSizeScale(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeSizeScale(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectScaleId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectScaleId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectScaleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectScaleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectScaleId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param objectTypeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    generateSSIN(objectTypeId: number | undefined, body: AppEntityDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GenerateSSIN?";
        if (objectTypeId === null)
            throw new Error("The parameter 'objectTypeId' cannot be null.");
        else if (objectTypeId !== undefined)
            url_ += "objectTypeId=" + encodeURIComponent("" + objectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateSSIN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateSSIN(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateSSIN(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectStatusDraftTransaction(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectStatusDraftTransaction";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectStatusDraftTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectStatusDraftTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectStatusDraftTransaction(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypeSalesOrder(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypeSalesOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypeSalesOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypeSalesOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypeSalesOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityObjectTypePurchaseOrder(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetEntityObjectTypePurchaseOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityObjectTypePurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityObjectTypePurchaseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetEntityObjectTypePurchaseOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getObjectTransactionId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SystemTables/GetObjectTransactionId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObjectTransactionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObjectTransactionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetObjectTransactionId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subscriptionEndDateStart !== undefined && subscriptionEndDateStart !== null)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toISOString() : "") + "&";
        if (subscriptionEndDateEnd !== undefined && subscriptionEndDateEnd !== null)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toISOString() : "") + "&";
        if (creationDateStart !== undefined && creationDateStart !== null)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toISOString() : "") + "&";
        if (creationDateEnd !== undefined && creationDateEnd !== null)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toISOString() : "") + "&";
        if (editionId !== undefined && editionId !== null)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTenantListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTenantListDto>;
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantEditDto>;
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTenantFeaturesEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTenantFeaturesEditOutput>;
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    getTenantIdByUserName(userName: string | null | undefined): Observable<TenantInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantIdByUserName?";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantIdByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantIdByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantInfoDto>;
        }));
    }

    protected processGetTenantIdByUserName(response: HttpResponseBase): Observable<TenantInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberActivityOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberActivityOutput>;
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDashboardDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDashboardDataOutput>;
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTopStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTopStatsOutput>;
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTopStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfitShareOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfitShareOutput>;
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfitShareOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDailySalesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDailySalesOutput>;
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailySalesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSalesSummaryOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSalesSummaryOutput>;
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRegionalStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRegionalStatsOutput>;
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralStatsOutput>;
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAccountTypesForTableDropdown(): Observable<LookupLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetAllAccountTypesForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountTypesForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountTypesForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupLabelDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupLabelDto[]>;
        }));
    }

    protected processGetAllAccountTypesForTableDropdown(response: HttpResponseBase): Observable<LookupLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupLabelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterTenantOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterTenantOutput>;
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionsSelectOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionsSelectOutput>;
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionSelectDto>;
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TicketNotesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param ticketTicketNumberFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, titleFilter: string | null | undefined, descriptionFilter: string | null | undefined, ticketTicketNumberFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTicketNoteForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketNotes/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter !== undefined && titleFilter !== null)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (ticketTicketNumberFilter !== undefined && ticketTicketNumberFilter !== null)
            url_ += "TicketTicketNumberFilter=" + encodeURIComponent("" + ticketTicketNumberFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTicketNoteForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTicketNoteForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTicketNoteForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTicketNoteForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTicketNoteForView(id: number | undefined): Observable<GetTicketNoteForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketNotes/GetTicketNoteForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketNoteForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketNoteForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTicketNoteForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTicketNoteForViewDto>;
        }));
    }

    protected processGetTicketNoteForView(response: HttpResponseBase): Observable<GetTicketNoteForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketNoteForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTicketNoteForEdit(id: number | undefined): Observable<GetTicketNoteForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketNotes/GetTicketNoteForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketNoteForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketNoteForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTicketNoteForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTicketNoteForEditOutput>;
        }));
    }

    protected processGetTicketNoteForEdit(response: HttpResponseBase): Observable<GetTicketNoteForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketNoteForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTicketNoteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketNotes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketNotes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param ticketTicketNumberFilter (optional) 
     * @return Success
     */
    getTicketNotesToExcel(filter: string | null | undefined, titleFilter: string | null | undefined, descriptionFilter: string | null | undefined, ticketTicketNumberFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketNotes/GetTicketNotesToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter !== undefined && titleFilter !== null)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (ticketTicketNumberFilter !== undefined && ticketTicketNumberFilter !== null)
            url_ += "TicketTicketNumberFilter=" + encodeURIComponent("" + ticketTicketNumberFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketNotesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketNotesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTicketNotesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTicketForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTicketNoteTicketLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketNotes/GetAllTicketForLookupTable?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTicketForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTicketForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTicketNoteTicketLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTicketNoteTicketLookupTableDto>;
        }));
    }

    protected processGetAllTicketForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTicketNoteTicketLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTicketNoteTicketLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TicketsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param ticketNumberFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, titleFilter: string | null | undefined, ticketNumberFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTicketForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Tickets/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter !== undefined && titleFilter !== null)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (ticketNumberFilter !== undefined && ticketNumberFilter !== null)
            url_ += "TicketNumberFilter=" + encodeURIComponent("" + ticketNumberFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTicketForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTicketForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTicketForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTicketForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTicketForView(id: number | undefined): Observable<GetTicketForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Tickets/GetTicketForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTicketForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTicketForViewDto>;
        }));
    }

    protected processGetTicketForView(response: HttpResponseBase): Observable<GetTicketForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTicketForEdit(id: number | undefined): Observable<GetTicketForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tickets/GetTicketForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTicketForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTicketForEditOutput>;
        }));
    }

    protected processGetTicketForEdit(response: HttpResponseBase): Observable<GetTicketForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTicketDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tickets/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tickets/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param ticketNumberFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getTicketsToExcel(filter: string | null | undefined, titleFilter: string | null | undefined, ticketNumberFilter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Tickets/GetTicketsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter !== undefined && titleFilter !== null)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (ticketNumberFilter !== undefined && ticketNumberFilter !== null)
            url_ += "TicketNumberFilter=" + encodeURIComponent("" + ticketNumberFilter) + "&";
        if (descriptionFilter !== undefined && descriptionFilter !== null)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTicketsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TimeZoneInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dateTime (optional) 
     * @param timeZone (optional) 
     * @return Success
     */
    getUTCDatetimeValue(dateTime: moment.Moment | undefined, timeZone: string | null | undefined): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/services/app/TimeZoneInfo/GetUTCDatetimeValue?";
        if (dateTime === null)
            throw new Error("The parameter 'dateTime' cannot be null.");
        else if (dateTime !== undefined)
            url_ += "dateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toISOString() : "") + "&";
        if (timeZone !== undefined && timeZone !== null)
            url_ += "timeZone=" + encodeURIComponent("" + timeZone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUTCDatetimeValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUTCDatetimeValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<moment.Moment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<moment.Moment>;
        }));
    }

    protected processGetUTCDatetimeValue(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dateTime (optional) 
     * @param timeZone (optional) 
     * @return Success
     */
    getDatetimeValueFromUTC(dateTime: moment.Moment | undefined, timeZone: string | null | undefined): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/services/app/TimeZoneInfo/GetDatetimeValueFromUTC?";
        if (dateTime === null)
            throw new Error("The parameter 'dateTime' cannot be null.");
        else if (dateTime !== undefined)
            url_ += "dateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toISOString() : "") + "&";
        if (timeZone !== undefined && timeZone !== null)
            url_ += "timeZone=" + encodeURIComponent("" + timeZone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatetimeValueFromUTC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatetimeValueFromUTC(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<moment.Moment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<moment.Moment>;
        }));
    }

    protected processGetDatetimeValueFromUTC(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTimeZonesList(): Observable<DisplayNameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TimeZoneInfo/GetTimeZonesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimeZonesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimeZonesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DisplayNameValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DisplayNameValueDto[]>;
        }));
    }

    protected processGetTimeZonesList(response: HttpResponseBase): Observable<DisplayNameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DisplayNameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfNameValueDto>;
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined && selectedTimezoneId !== null)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshTokenResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshTokenResult>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userDelegationId (optional) 
     * @param impersonationToken (optional) 
     * @return Success
     */
    delegatedImpersonatedAuthenticate(userDelegationId: number | undefined, impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/DelegatedImpersonatedAuthenticate?";
        if (userDelegationId === null)
            throw new Error("The parameter 'userDelegationId' cannot be null.");
        else if (userDelegationId !== undefined)
            url_ += "userDelegationId=" + encodeURIComponent("" + userDelegationId) + "&";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined && switchAccountToken !== null)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchedAccountAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchedAccountAuthenticateResultModel>;
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity !== undefined && severity !== null)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThemeSettingsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThemeSettingsDto[]>;
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined && themeName !== null)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserListDto>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getAllUsersNames(searchTerm: string | null | undefined): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllUsersNames?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsersNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsersNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetAllUsersNames(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserForEditOutput>;
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserPermissionsForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserPermissionsForEditOutput>;
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserDelegationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getDelegatedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfUserDelegationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetDelegatedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDelegatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDelegatedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserDelegationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserDelegationDto>;
        }));
    }

    protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/DelegateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegateNewUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeDelegation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/RemoveDelegation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDelegation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDelegation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getActiveUserDelegations(): Observable<UserDelegationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetActiveUserDelegations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveUserDelegations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveUserDelegations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDelegationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDelegationDto[]>;
        }));
    }

    protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDelegationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookEvent>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WebhookEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookSendAttemptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
        }));
    }

    protected processGetAllSendAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllSendAttemptsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | null | undefined): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttemptsOfWebhookEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
        }));
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId !== undefined && sendAttemptId !== null)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    publishTestWebhook(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishTestWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishTestWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPublishTestWebhook(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | null | undefined): Observable<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookSubscription>;
        }));
    }

    protected processGetSubscription(response: HttpResponseBase): Observable<WebhookSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateWebhookSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateWebhookSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateWebhookSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSubscribed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSubscribed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsSubscribed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | null | undefined): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptionsIfFeaturesGranted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWebhooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWebhooks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
        }));
    }

    protected processGetAllAvailableWebhooks(response: HttpResponseBase): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllAvailableWebhooksOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLatestWebLogsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLatestWebLogsOutput>;
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    [key: string]: any;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;

    [key: string]: any;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    [key: string]: any;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.serverRootAddress = _data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;

    [key: string]: any;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    [key: string]: any;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["c"] = this.c;
        return data;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;

    [key: string]: any;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    [key: string]: any;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    [key: string]: any;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    [key: string]: any;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["canLogin"] = this.canLogin;
        return data;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;

    [key: string]: any;
}

export class SendUserResetPasswordCodeInput implements ISendUserResetPasswordCodeInput {
    userName!: string;

    [key: string]: any;

    constructor(data?: ISendUserResetPasswordCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): SendUserResetPasswordCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendUserResetPasswordCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userName"] = this.userName;
        return data;
    }
}

export interface ISendUserResetPasswordCodeInput {
    userName: string;

    [key: string]: any;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    [key: string]: any;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data;
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;

    [key: string]: any;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    [key: string]: any;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;

    [key: string]: any;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    [key: string]: any;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;

    [key: string]: any;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    [key: string]: any;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;

    [key: string]: any;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number;

    [key: string]: any;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;

    [key: string]: any;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    [key: string]: any;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;

    [key: string]: any;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
    userDelegationId!: number;

    [key: string]: any;

    constructor(data?: IDelegatedImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userDelegationId = _data["userDelegationId"];
        }
    }

    static fromJS(data: any): DelegatedImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DelegatedImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userDelegationId"] = this.userDelegationId;
        return data;
    }
}

export interface IDelegatedImpersonateInput {
    userDelegationId: number;

    [key: string]: any;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    [key: string]: any;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;

    [key: string]: any;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    [key: string]: any;
}

export enum AccountLevelEnum {
    Profile = 0,
    Manual = 1,
    External = 2,
}

export class AppEntityCategoryDto implements IAppEntityCategoryDto {
    entityObjectCategoryId!: number;
    entityObjectCategoryCode!: string | undefined;
    entityObjectCategoryName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityObjectCategoryId = _data["entityObjectCategoryId"];
            this.entityObjectCategoryCode = _data["entityObjectCategoryCode"];
            this.entityObjectCategoryName = _data["entityObjectCategoryName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityObjectCategoryId"] = this.entityObjectCategoryId;
        data["entityObjectCategoryCode"] = this.entityObjectCategoryCode;
        data["entityObjectCategoryName"] = this.entityObjectCategoryName;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityCategoryDto {
    entityObjectCategoryId: number;
    entityObjectCategoryCode: string | undefined;
    entityObjectCategoryName: string | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntityClassificationDto implements IAppEntityClassificationDto {
    entityObjectClassificationId!: number;
    entityObjectClassificationCode!: string | undefined;
    entityObjectClassificationName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityObjectClassificationId = _data["entityObjectClassificationId"];
            this.entityObjectClassificationCode = _data["entityObjectClassificationCode"];
            this.entityObjectClassificationName = _data["entityObjectClassificationName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityObjectClassificationId"] = this.entityObjectClassificationId;
        data["entityObjectClassificationCode"] = this.entityObjectClassificationCode;
        data["entityObjectClassificationName"] = this.entityObjectClassificationName;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityClassificationDto {
    entityObjectClassificationId: number;
    entityObjectClassificationCode: string | undefined;
    entityObjectClassificationName: string | undefined;
    id: number;

    [key: string]: any;
}

export enum AttachmentsCategories {
    LOGO = 0,
    BANNER = 1,
    IMAGE = 2,
    FILE = 3,
    VIDEO = 4,
}

export class AppEntityAttachmentDto implements IAppEntityAttachmentDto {
    attachmentCategoryId!: number;
    attachmentCategoryEnum!: AttachmentsCategories;
    fileName!: string | undefined;
    displayName!: string | undefined;
    url!: string | undefined;
    guid!: string | undefined;
    attributes!: string | undefined;
    index!: number;
    isDefault!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.attachmentCategoryId = _data["attachmentCategoryId"];
            this.attachmentCategoryEnum = _data["attachmentCategoryEnum"];
            this.fileName = _data["fileName"];
            this.displayName = _data["displayName"];
            this.url = _data["url"];
            this.guid = _data["guid"];
            this.attributes = _data["attributes"];
            this.index = _data["index"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["attachmentCategoryId"] = this.attachmentCategoryId;
        data["attachmentCategoryEnum"] = this.attachmentCategoryEnum;
        data["fileName"] = this.fileName;
        data["displayName"] = this.displayName;
        data["url"] = this.url;
        data["guid"] = this.guid;
        data["attributes"] = this.attributes;
        data["index"] = this.index;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityAttachmentDto {
    attachmentCategoryId: number;
    attachmentCategoryEnum: AttachmentsCategories;
    fileName: string | undefined;
    displayName: string | undefined;
    url: string | undefined;
    guid: string | undefined;
    attributes: string | undefined;
    index: number;
    isDefault: boolean;
    id: number;

    [key: string]: any;
}

export class AppContactAddressDto implements IAppContactAddressDto {
    accountId!: number;
    contactId!: number;
    addressTypeId!: number;
    addressTypeIdName!: string | undefined;
    addressId!: number;
    code!: string | undefined;
    name!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number;
    countryIdName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppContactAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountId = _data["accountId"];
            this.contactId = _data["contactId"];
            this.addressTypeId = _data["addressTypeId"];
            this.addressTypeIdName = _data["addressTypeIdName"];
            this.addressId = _data["addressId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.countryIdName = _data["countryIdName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppContactAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppContactAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["contactId"] = this.contactId;
        data["addressTypeId"] = this.addressTypeId;
        data["addressTypeIdName"] = this.addressTypeIdName;
        data["addressId"] = this.addressId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["countryIdName"] = this.countryIdName;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppContactAddressDto {
    accountId: number;
    contactId: number;
    addressTypeId: number;
    addressTypeIdName: string | undefined;
    addressId: number;
    code: string | undefined;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number;
    countryIdName: string | undefined;
    id: number;

    [key: string]: any;
}

export class BranchDto implements IBranchDto {
    code!: string | undefined;
    name!: string | undefined;
    tradeName!: string | undefined;
    parentId!: number | undefined;
    website!: string | undefined;
    phone1CountryKey!: string | undefined;
    phone1Number!: string | undefined;
    phone1Ext!: string | undefined;
    phone2CountryKey!: string | undefined;
    phone2Number!: string | undefined;
    phone2Ext!: string | undefined;
    phone3CountryKey!: string | undefined;
    phone3Number!: string | undefined;
    phone3Ext!: string | undefined;
    eMailAddress!: string | undefined;
    phone1TypeId!: number | undefined;
    phone1TypeName!: string | undefined;
    phone2TypeId!: number | undefined;
    phone2TypeName!: string | undefined;
    phone3TypeId!: number | undefined;
    phone3TypeName!: string | undefined;
    currencyId!: number | undefined;
    currencyName!: string | undefined;
    languageId!: number | undefined;
    languageName!: string | undefined;
    attachmentSourceTenantId!: number | undefined;
    contactAddresses!: AppContactAddressDto[] | undefined;
    accountId!: number | undefined;
    tenantId!: number | undefined;
    useDTOTenant!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: IBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.tradeName = _data["tradeName"];
            this.parentId = _data["parentId"];
            this.website = _data["website"];
            this.phone1CountryKey = _data["phone1CountryKey"];
            this.phone1Number = _data["phone1Number"];
            this.phone1Ext = _data["phone1Ext"];
            this.phone2CountryKey = _data["phone2CountryKey"];
            this.phone2Number = _data["phone2Number"];
            this.phone2Ext = _data["phone2Ext"];
            this.phone3CountryKey = _data["phone3CountryKey"];
            this.phone3Number = _data["phone3Number"];
            this.phone3Ext = _data["phone3Ext"];
            this.eMailAddress = _data["eMailAddress"];
            this.phone1TypeId = _data["phone1TypeId"];
            this.phone1TypeName = _data["phone1TypeName"];
            this.phone2TypeId = _data["phone2TypeId"];
            this.phone2TypeName = _data["phone2TypeName"];
            this.phone3TypeId = _data["phone3TypeId"];
            this.phone3TypeName = _data["phone3TypeName"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.languageId = _data["languageId"];
            this.languageName = _data["languageName"];
            this.attachmentSourceTenantId = _data["attachmentSourceTenantId"];
            if (Array.isArray(_data["contactAddresses"])) {
                this.contactAddresses = [] as any;
                for (let item of _data["contactAddresses"])
                    this.contactAddresses!.push(AppContactAddressDto.fromJS(item));
            }
            this.accountId = _data["accountId"];
            this.tenantId = _data["tenantId"];
            this.useDTOTenant = _data["useDTOTenant"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["tradeName"] = this.tradeName;
        data["parentId"] = this.parentId;
        data["website"] = this.website;
        data["phone1CountryKey"] = this.phone1CountryKey;
        data["phone1Number"] = this.phone1Number;
        data["phone1Ext"] = this.phone1Ext;
        data["phone2CountryKey"] = this.phone2CountryKey;
        data["phone2Number"] = this.phone2Number;
        data["phone2Ext"] = this.phone2Ext;
        data["phone3CountryKey"] = this.phone3CountryKey;
        data["phone3Number"] = this.phone3Number;
        data["phone3Ext"] = this.phone3Ext;
        data["eMailAddress"] = this.eMailAddress;
        data["phone1TypeId"] = this.phone1TypeId;
        data["phone1TypeName"] = this.phone1TypeName;
        data["phone2TypeId"] = this.phone2TypeId;
        data["phone2TypeName"] = this.phone2TypeName;
        data["phone3TypeId"] = this.phone3TypeId;
        data["phone3TypeName"] = this.phone3TypeName;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["languageId"] = this.languageId;
        data["languageName"] = this.languageName;
        data["attachmentSourceTenantId"] = this.attachmentSourceTenantId;
        if (Array.isArray(this.contactAddresses)) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        data["accountId"] = this.accountId;
        data["tenantId"] = this.tenantId;
        data["useDTOTenant"] = this.useDTOTenant;
        data["id"] = this.id;
        return data;
    }
}

export interface IBranchDto {
    code: string | undefined;
    name: string | undefined;
    tradeName: string | undefined;
    parentId: number | undefined;
    website: string | undefined;
    phone1CountryKey: string | undefined;
    phone1Number: string | undefined;
    phone1Ext: string | undefined;
    phone2CountryKey: string | undefined;
    phone2Number: string | undefined;
    phone2Ext: string | undefined;
    phone3CountryKey: string | undefined;
    phone3Number: string | undefined;
    phone3Ext: string | undefined;
    eMailAddress: string | undefined;
    phone1TypeId: number | undefined;
    phone1TypeName: string | undefined;
    phone2TypeId: number | undefined;
    phone2TypeName: string | undefined;
    phone3TypeId: number | undefined;
    phone3TypeName: string | undefined;
    currencyId: number | undefined;
    currencyName: string | undefined;
    languageId: number | undefined;
    languageName: string | undefined;
    attachmentSourceTenantId: number | undefined;
    contactAddresses: AppContactAddressDto[] | undefined;
    accountId: number | undefined;
    tenantId: number | undefined;
    useDTOTenant: boolean;
    id: number;

    [key: string]: any;
}

export class BranchForViewDto implements IBranchForViewDto {
    branch!: BranchDto;
    subTotal!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IBranchForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.branch = _data["branch"] ? BranchDto.fromJS(_data["branch"]) : <any>undefined;
            this.subTotal = _data["subTotal"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BranchForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["subTotal"] = this.subTotal;
        data["id"] = this.id;
        return data;
    }
}

export interface IBranchForViewDto {
    branch: BranchDto;
    subTotal: number;
    id: number;

    [key: string]: any;
}

export class TreeNodeOfBranchForViewDto implements ITreeNodeOfBranchForViewDto {
    data!: BranchForViewDto;
    children!: TreeNodeOfBranchForViewDto[] | undefined;
    leaf!: boolean;
    expanded!: boolean;
    label!: string | undefined;
    totalChildrenCount!: number | undefined;

    [key: string]: any;

    constructor(data?: ITreeNodeOfBranchForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? BranchForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeNodeOfBranchForViewDto.fromJS(item));
            }
            this.leaf = _data["leaf"];
            this.expanded = _data["expanded"];
            this.label = _data["label"];
            this.totalChildrenCount = _data["totalChildrenCount"];
        }
    }

    static fromJS(data: any): TreeNodeOfBranchForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeOfBranchForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["leaf"] = this.leaf;
        data["expanded"] = this.expanded;
        data["label"] = this.label;
        data["totalChildrenCount"] = this.totalChildrenCount;
        return data;
    }
}

export interface ITreeNodeOfBranchForViewDto {
    data: BranchForViewDto;
    children: TreeNodeOfBranchForViewDto[] | undefined;
    leaf: boolean;
    expanded: boolean;
    label: string | undefined;
    totalChildrenCount: number | undefined;

    [key: string]: any;
}

export class AppContactPaymentMethodDto implements IAppContactPaymentMethodDto {
    description!: string | undefined;
    paymentType!: number;
    isDefault!: boolean;
    cardNumber!: string | undefined;
    cardType!: number | undefined;
    cardHolderName!: string | undefined;
    cardExpirationMonth!: string | undefined;
    cardExpirationYear!: string | undefined;
    securityCode!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppContactPaymentMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.paymentType = _data["paymentType"];
            this.isDefault = _data["isDefault"];
            this.cardNumber = _data["cardNumber"];
            this.cardType = _data["cardType"];
            this.cardHolderName = _data["cardHolderName"];
            this.cardExpirationMonth = _data["cardExpirationMonth"];
            this.cardExpirationYear = _data["cardExpirationYear"];
            this.securityCode = _data["securityCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppContactPaymentMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppContactPaymentMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["paymentType"] = this.paymentType;
        data["isDefault"] = this.isDefault;
        data["cardNumber"] = this.cardNumber;
        data["cardType"] = this.cardType;
        data["cardHolderName"] = this.cardHolderName;
        data["cardExpirationMonth"] = this.cardExpirationMonth;
        data["cardExpirationYear"] = this.cardExpirationYear;
        data["securityCode"] = this.securityCode;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppContactPaymentMethodDto {
    description: string | undefined;
    paymentType: number;
    isDefault: boolean;
    cardNumber: string | undefined;
    cardType: number | undefined;
    cardHolderName: string | undefined;
    cardExpirationMonth: string | undefined;
    cardExpirationYear: string | undefined;
    securityCode: string | undefined;
    id: number;

    [key: string]: any;
}

export class CreateOrEditAccountInfoDto implements ICreateOrEditAccountInfoDto {
    fileToken!: string | undefined;
    tradeName!: string;
    accountType!: string | undefined;
    accountTypeId!: number;
    ssin!: string | undefined;
    priceLevel!: string | undefined;
    notes!: string | undefined;
    website!: string | undefined;
    name!: string;
    code!: string | undefined;
    phone1Number!: string | undefined;
    phone1Ex!: string | undefined;
    phone2Number!: string | undefined;
    phone2Ex!: string | undefined;
    phone3Number!: string | undefined;
    phone3Ex!: string | undefined;
    eMailAddress!: string | undefined;
    phone1TypeId!: number | undefined;
    phone2TypeId!: number | undefined;
    phone3TypeId!: number | undefined;
    currencyId!: number | undefined;
    languageId!: number | undefined;
    entityId!: number | undefined;
    tenantId!: number | undefined;
    attachmentSourceTenantId!: number | undefined;
    useDTOTenant!: boolean;
    returnId!: boolean;
    accountLevel!: AccountLevelEnum;
    entityCategories!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    branches!: TreeNodeOfBranchForViewDto[] | undefined;
    contactAddresses!: AppContactAddressDto[] | undefined;
    contactPaymentMethods!: AppContactPaymentMethodDto[] | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fileToken = _data["fileToken"];
            this.tradeName = _data["tradeName"];
            this.accountType = _data["accountType"];
            this.accountTypeId = _data["accountTypeId"];
            this.ssin = _data["ssin"];
            this.priceLevel = _data["priceLevel"];
            this.notes = _data["notes"];
            this.website = _data["website"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.phone1Number = _data["phone1Number"];
            this.phone1Ex = _data["phone1Ex"];
            this.phone2Number = _data["phone2Number"];
            this.phone2Ex = _data["phone2Ex"];
            this.phone3Number = _data["phone3Number"];
            this.phone3Ex = _data["phone3Ex"];
            this.eMailAddress = _data["eMailAddress"];
            this.phone1TypeId = _data["phone1TypeId"];
            this.phone2TypeId = _data["phone2TypeId"];
            this.phone3TypeId = _data["phone3TypeId"];
            this.currencyId = _data["currencyId"];
            this.languageId = _data["languageId"];
            this.entityId = _data["entityId"];
            this.tenantId = _data["tenantId"];
            this.attachmentSourceTenantId = _data["attachmentSourceTenantId"];
            this.useDTOTenant = _data["useDTOTenant"];
            this.returnId = _data["returnId"];
            this.accountLevel = _data["accountLevel"];
            if (Array.isArray(_data["entityCategories"])) {
                this.entityCategories = [] as any;
                for (let item of _data["entityCategories"])
                    this.entityCategories!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassifications"])) {
                this.entityClassifications = [] as any;
                for (let item of _data["entityClassifications"])
                    this.entityClassifications!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["branches"])) {
                this.branches = [] as any;
                for (let item of _data["branches"])
                    this.branches!.push(TreeNodeOfBranchForViewDto.fromJS(item));
            }
            if (Array.isArray(_data["contactAddresses"])) {
                this.contactAddresses = [] as any;
                for (let item of _data["contactAddresses"])
                    this.contactAddresses!.push(AppContactAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["contactPaymentMethods"])) {
                this.contactPaymentMethods = [] as any;
                for (let item of _data["contactPaymentMethods"])
                    this.contactPaymentMethods!.push(AppContactPaymentMethodDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAccountInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fileToken"] = this.fileToken;
        data["tradeName"] = this.tradeName;
        data["accountType"] = this.accountType;
        data["accountTypeId"] = this.accountTypeId;
        data["ssin"] = this.ssin;
        data["priceLevel"] = this.priceLevel;
        data["notes"] = this.notes;
        data["website"] = this.website;
        data["name"] = this.name;
        data["code"] = this.code;
        data["phone1Number"] = this.phone1Number;
        data["phone1Ex"] = this.phone1Ex;
        data["phone2Number"] = this.phone2Number;
        data["phone2Ex"] = this.phone2Ex;
        data["phone3Number"] = this.phone3Number;
        data["phone3Ex"] = this.phone3Ex;
        data["eMailAddress"] = this.eMailAddress;
        data["phone1TypeId"] = this.phone1TypeId;
        data["phone2TypeId"] = this.phone2TypeId;
        data["phone3TypeId"] = this.phone3TypeId;
        data["currencyId"] = this.currencyId;
        data["languageId"] = this.languageId;
        data["entityId"] = this.entityId;
        data["tenantId"] = this.tenantId;
        data["attachmentSourceTenantId"] = this.attachmentSourceTenantId;
        data["useDTOTenant"] = this.useDTOTenant;
        data["returnId"] = this.returnId;
        data["accountLevel"] = this.accountLevel;
        if (Array.isArray(this.entityCategories)) {
            data["entityCategories"] = [];
            for (let item of this.entityCategories)
                data["entityCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassifications)) {
            data["entityClassifications"] = [];
            for (let item of this.entityClassifications)
                data["entityClassifications"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        if (Array.isArray(this.contactAddresses)) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.contactPaymentMethods)) {
            data["contactPaymentMethods"] = [];
            for (let item of this.contactPaymentMethods)
                data["contactPaymentMethods"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAccountInfoDto {
    fileToken: string | undefined;
    tradeName: string;
    accountType: string | undefined;
    accountTypeId: number;
    ssin: string | undefined;
    priceLevel: string | undefined;
    notes: string | undefined;
    website: string | undefined;
    name: string;
    code: string | undefined;
    phone1Number: string | undefined;
    phone1Ex: string | undefined;
    phone2Number: string | undefined;
    phone2Ex: string | undefined;
    phone3Number: string | undefined;
    phone3Ex: string | undefined;
    eMailAddress: string | undefined;
    phone1TypeId: number | undefined;
    phone2TypeId: number | undefined;
    phone3TypeId: number | undefined;
    currencyId: number | undefined;
    languageId: number | undefined;
    entityId: number | undefined;
    tenantId: number | undefined;
    attachmentSourceTenantId: number | undefined;
    useDTOTenant: boolean;
    returnId: boolean;
    accountLevel: AccountLevelEnum;
    entityCategories: AppEntityCategoryDto[] | undefined;
    entityClassifications: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    branches: TreeNodeOfBranchForViewDto[] | undefined;
    contactAddresses: AppContactAddressDto[] | undefined;
    contactPaymentMethods: AppContactPaymentMethodDto[] | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetAccountInfoForEditOutput implements IGetAccountInfoForEditOutput {
    accountInfo!: CreateOrEditAccountInfoDto;
    phone1TypeName!: string | undefined;
    phone2TypeName!: string | undefined;
    phone3TypeName!: string | undefined;
    currencyName!: string | undefined;
    languageName!: string | undefined;
    lastChangesIsPublished!: boolean;

    [key: string]: any;

    constructor(data?: IGetAccountInfoForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountInfo = _data["accountInfo"] ? CreateOrEditAccountInfoDto.fromJS(_data["accountInfo"]) : <any>undefined;
            this.phone1TypeName = _data["phone1TypeName"];
            this.phone2TypeName = _data["phone2TypeName"];
            this.phone3TypeName = _data["phone3TypeName"];
            this.currencyName = _data["currencyName"];
            this.languageName = _data["languageName"];
            this.lastChangesIsPublished = _data["lastChangesIsPublished"];
        }
    }

    static fromJS(data: any): GetAccountInfoForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountInfoForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountInfo"] = this.accountInfo ? this.accountInfo.toJSON() : <any>undefined;
        data["phone1TypeName"] = this.phone1TypeName;
        data["phone2TypeName"] = this.phone2TypeName;
        data["phone3TypeName"] = this.phone3TypeName;
        data["currencyName"] = this.currencyName;
        data["languageName"] = this.languageName;
        data["lastChangesIsPublished"] = this.lastChangesIsPublished;
        return data;
    }
}

export interface IGetAccountInfoForEditOutput {
    accountInfo: CreateOrEditAccountInfoDto;
    phone1TypeName: string | undefined;
    phone2TypeName: string | undefined;
    phone3TypeName: string | undefined;
    currencyName: string | undefined;
    languageName: string | undefined;
    lastChangesIsPublished: boolean;

    [key: string]: any;
}

export class AccountInfoAppEntityLookupTableDto implements IAccountInfoAppEntityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAccountInfoAppEntityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AccountInfoAppEntityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountInfoAppEntityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAccountInfoAppEntityLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AccountDto implements IAccountDto {
    name!: string | undefined;
    description!: string | undefined;
    connections!: number;
    website!: string | undefined;
    eMailAddress!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    zipCode!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    countryId!: number;
    countryName!: string | undefined;
    priceLevel!: string | undefined;
    ssin!: string | undefined;
    accountTypeId!: number;
    accountType!: string | undefined;
    accountTypeString!: string | undefined;
    status!: boolean;
    classfications!: string[] | undefined;
    categories!: string[] | undefined;
    logoUrl!: string | undefined;
    coverUrl!: string | undefined;
    imagesUrls!: string[] | undefined;
    phone1Number!: string | undefined;
    isManual!: boolean;
    isConnected!: boolean;
    branches!: TreeNodeOfBranchForViewDto[] | undefined;
    partnerId!: number | undefined;
    entityId!: number | undefined;
    classificationsTotalCount!: number | undefined;
    categoriesTotalCount!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.connections = _data["connections"];
            this.website = _data["website"];
            this.eMailAddress = _data["eMailAddress"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.priceLevel = _data["priceLevel"];
            this.ssin = _data["ssin"];
            this.accountTypeId = _data["accountTypeId"];
            this.accountType = _data["accountType"];
            this.accountTypeString = _data["accountTypeString"];
            this.status = _data["status"];
            if (Array.isArray(_data["classfications"])) {
                this.classfications = [] as any;
                for (let item of _data["classfications"])
                    this.classfications!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            this.logoUrl = _data["logoUrl"];
            this.coverUrl = _data["coverUrl"];
            if (Array.isArray(_data["imagesUrls"])) {
                this.imagesUrls = [] as any;
                for (let item of _data["imagesUrls"])
                    this.imagesUrls!.push(item);
            }
            this.phone1Number = _data["phone1Number"];
            this.isManual = _data["isManual"];
            this.isConnected = _data["isConnected"];
            if (Array.isArray(_data["branches"])) {
                this.branches = [] as any;
                for (let item of _data["branches"])
                    this.branches!.push(TreeNodeOfBranchForViewDto.fromJS(item));
            }
            this.partnerId = _data["partnerId"];
            this.entityId = _data["entityId"];
            this.classificationsTotalCount = _data["classificationsTotalCount"];
            this.categoriesTotalCount = _data["categoriesTotalCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["connections"] = this.connections;
        data["website"] = this.website;
        data["eMailAddress"] = this.eMailAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["priceLevel"] = this.priceLevel;
        data["ssin"] = this.ssin;
        data["accountTypeId"] = this.accountTypeId;
        data["accountType"] = this.accountType;
        data["accountTypeString"] = this.accountTypeString;
        data["status"] = this.status;
        if (Array.isArray(this.classfications)) {
            data["classfications"] = [];
            for (let item of this.classfications)
                data["classfications"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["logoUrl"] = this.logoUrl;
        data["coverUrl"] = this.coverUrl;
        if (Array.isArray(this.imagesUrls)) {
            data["imagesUrls"] = [];
            for (let item of this.imagesUrls)
                data["imagesUrls"].push(item);
        }
        data["phone1Number"] = this.phone1Number;
        data["isManual"] = this.isManual;
        data["isConnected"] = this.isConnected;
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        data["partnerId"] = this.partnerId;
        data["entityId"] = this.entityId;
        data["classificationsTotalCount"] = this.classificationsTotalCount;
        data["categoriesTotalCount"] = this.categoriesTotalCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IAccountDto {
    name: string | undefined;
    description: string | undefined;
    connections: number;
    website: string | undefined;
    eMailAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    countryId: number;
    countryName: string | undefined;
    priceLevel: string | undefined;
    ssin: string | undefined;
    accountTypeId: number;
    accountType: string | undefined;
    accountTypeString: string | undefined;
    status: boolean;
    classfications: string[] | undefined;
    categories: string[] | undefined;
    logoUrl: string | undefined;
    coverUrl: string | undefined;
    imagesUrls: string[] | undefined;
    phone1Number: string | undefined;
    isManual: boolean;
    isConnected: boolean;
    branches: TreeNodeOfBranchForViewDto[] | undefined;
    partnerId: number | undefined;
    entityId: number | undefined;
    classificationsTotalCount: number | undefined;
    categoriesTotalCount: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetAccountForViewDto implements IGetAccountForViewDto {
    account!: AccountDto;
    appEntityName!: string | undefined;
    isPublished!: boolean;

    [key: string]: any;

    constructor(data?: IGetAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.account = _data["account"] ? AccountDto.fromJS(_data["account"]) : <any>undefined;
            this.appEntityName = _data["appEntityName"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): GetAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["appEntityName"] = this.appEntityName;
        data["isPublished"] = this.isPublished;
        return data;
    }
}

export interface IGetAccountForViewDto {
    account: AccountDto;
    appEntityName: string | undefined;
    isPublished: boolean;

    [key: string]: any;
}

export class PagedResultDtoOfGetAccountForViewDto implements IPagedResultDtoOfGetAccountForViewDto {
    totalCount!: number;
    items!: GetAccountForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAccountForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAccountForViewDto {
    totalCount: number;
    items: GetAccountForViewDto[] | undefined;

    [key: string]: any;
}

export class LookupLabelDto implements ILookupLabelDto {
    value!: number;
    label!: string | undefined;
    code!: string | undefined;
    stockAvailability!: number | undefined;
    isHostRecord!: boolean | undefined;

    [key: string]: any;

    constructor(data?: ILookupLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.label = _data["label"];
            this.code = _data["code"];
            this.stockAvailability = _data["stockAvailability"];
            this.isHostRecord = _data["isHostRecord"];
        }
    }

    static fromJS(data: any): LookupLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["label"] = this.label;
        data["code"] = this.code;
        data["stockAvailability"] = this.stockAvailability;
        data["isHostRecord"] = this.isHostRecord;
        return data;
    }
}

export interface ILookupLabelDto {
    value: number;
    label: string | undefined;
    code: string | undefined;
    stockAvailability: number | undefined;
    isHostRecord: boolean | undefined;

    [key: string]: any;
}

export enum MemberFilterTypeEnum {
    Profile = 0,
    View = 1,
    MarketPlace = 2,
}

export class GetMemberForViewDto implements IGetMemberForViewDto {
    id!: number;
    firstName!: string | undefined;
    surName!: string | undefined;
    jobTitle!: string | undefined;
    eMailAddress!: string | undefined;
    joinDate!: moment.Moment;
    isActive!: boolean;
    userId!: number;
    imageUrl!: string | undefined;
    accountName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetMemberForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.surName = _data["surName"];
            this.jobTitle = _data["jobTitle"];
            this.eMailAddress = _data["eMailAddress"];
            this.joinDate = _data["joinDate"] ? moment(_data["joinDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.userId = _data["userId"];
            this.imageUrl = _data["imageUrl"];
            this.accountName = _data["accountName"];
        }
    }

    static fromJS(data: any): GetMemberForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["surName"] = this.surName;
        data["jobTitle"] = this.jobTitle;
        data["eMailAddress"] = this.eMailAddress;
        data["joinDate"] = this.joinDate ? this.joinDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["userId"] = this.userId;
        data["imageUrl"] = this.imageUrl;
        data["accountName"] = this.accountName;
        return data;
    }
}

export interface IGetMemberForViewDto {
    id: number;
    firstName: string | undefined;
    surName: string | undefined;
    jobTitle: string | undefined;
    eMailAddress: string | undefined;
    joinDate: moment.Moment;
    isActive: boolean;
    userId: number;
    imageUrl: string | undefined;
    accountName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetMemberForViewDto implements IPagedResultDtoOfGetMemberForViewDto {
    totalCount!: number;
    items!: GetMemberForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetMemberForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMemberForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMemberForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMemberForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMemberForViewDto {
    totalCount: number;
    items: GetMemberForViewDto[] | undefined;

    [key: string]: any;
}

export class AccountAppEntityLookupTableDto implements IAccountAppEntityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAccountAppEntityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AccountAppEntityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountAppEntityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAccountAppEntityLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SendMailDto implements ISendMailDto {
    to!: string;
    subject!: string;
    body!: string;
    isBodyHtml!: boolean;

    [key: string]: any;

    constructor(data?: ISendMailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.to = _data["to"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.isBodyHtml = _data["isBodyHtml"];
        }
    }

    static fromJS(data: any): SendMailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendMailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["to"] = this.to;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["isBodyHtml"] = this.isBodyHtml;
        return data;
    }
}

export interface ISendMailDto {
    to: string;
    subject: string;
    body: string;
    isBodyHtml: boolean;

    [key: string]: any;
}

export class AccountSummaryDto implements IAccountSummaryDto {
    name!: string | undefined;
    tradeName!: string | undefined;
    accountType!: string | undefined;
    notes!: string | undefined;
    website!: string | undefined;
    phoneNumber!: string | undefined;
    eMailAddress!: string | undefined;
    logoUrl!: string | undefined;

    [key: string]: any;

    constructor(data?: IAccountSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.tradeName = _data["tradeName"];
            this.accountType = _data["accountType"];
            this.notes = _data["notes"];
            this.website = _data["website"];
            this.phoneNumber = _data["phoneNumber"];
            this.eMailAddress = _data["eMailAddress"];
            this.logoUrl = _data["logoUrl"];
        }
    }

    static fromJS(data: any): AccountSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["tradeName"] = this.tradeName;
        data["accountType"] = this.accountType;
        data["notes"] = this.notes;
        data["website"] = this.website;
        data["phoneNumber"] = this.phoneNumber;
        data["eMailAddress"] = this.eMailAddress;
        data["logoUrl"] = this.logoUrl;
        return data;
    }
}

export interface IAccountSummaryDto {
    name: string | undefined;
    tradeName: string | undefined;
    accountType: string | undefined;
    notes: string | undefined;
    website: string | undefined;
    phoneNumber: string | undefined;
    eMailAddress: string | undefined;
    logoUrl: string | undefined;

    [key: string]: any;
}

export class GetAccountForDropdownDto implements IGetAccountForDropdownDto {
    name!: string | undefined;
    imgURL!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IGetAccountForDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.imgURL = _data["imgURL"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAccountForDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountForDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["imgURL"] = this.imgURL;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAccountForDropdownDto {
    name: string | undefined;
    imgURL: string | undefined;
    id: number;

    [key: string]: any;
}

export class EntityDto implements IEntityDto {
    id!: number;

    [key: string]: any;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDto {
    id: number;

    [key: string]: any;
}

export class ContactDto implements IContactDto {
    code!: string | undefined;
    name!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    titleId!: number | undefined;
    tradeName!: string | undefined;
    parentId!: number | undefined;
    website!: string | undefined;
    phone1CountryKey!: string | undefined;
    phone1Number!: string | undefined;
    phone1Ext!: string | undefined;
    phone2CountryKey!: string | undefined;
    phone2Number!: string | undefined;
    phone2Ext!: string | undefined;
    phone3CountryKey!: string | undefined;
    phone3Number!: string | undefined;
    phone3Ext!: string | undefined;
    eMailAddress!: string | undefined;
    phone1TypeId!: number | undefined;
    phone1TypeName!: string | undefined;
    phone2TypeId!: number | undefined;
    phone2TypeName!: string | undefined;
    phone3TypeId!: number | undefined;
    phone3TypeName!: string | undefined;
    currencyId!: number | undefined;
    currencyName!: string | undefined;
    languageId!: number | undefined;
    languageName!: string | undefined;
    contactAddresses!: AppContactAddressDto[] | undefined;
    userId!: number | undefined;
    accountId!: number;
    jobTitle!: string | undefined;
    joinDate!: moment.Moment;
    languageIsPublic!: boolean;
    emailAddressIsPublic!: boolean;
    phone1IsPublic!: boolean;
    phone2IsPublic!: boolean;
    phone3IsPublic!: boolean;
    joinDateIsPublic!: boolean;
    userName!: string | undefined;
    userNameIsPublic!: boolean;
    notes!: string | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    tenantId!: number | undefined;
    attachmentSourceTenantId!: number | undefined;
    useDTOTenant!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.titleId = _data["titleId"];
            this.tradeName = _data["tradeName"];
            this.parentId = _data["parentId"];
            this.website = _data["website"];
            this.phone1CountryKey = _data["phone1CountryKey"];
            this.phone1Number = _data["phone1Number"];
            this.phone1Ext = _data["phone1Ext"];
            this.phone2CountryKey = _data["phone2CountryKey"];
            this.phone2Number = _data["phone2Number"];
            this.phone2Ext = _data["phone2Ext"];
            this.phone3CountryKey = _data["phone3CountryKey"];
            this.phone3Number = _data["phone3Number"];
            this.phone3Ext = _data["phone3Ext"];
            this.eMailAddress = _data["eMailAddress"];
            this.phone1TypeId = _data["phone1TypeId"];
            this.phone1TypeName = _data["phone1TypeName"];
            this.phone2TypeId = _data["phone2TypeId"];
            this.phone2TypeName = _data["phone2TypeName"];
            this.phone3TypeId = _data["phone3TypeId"];
            this.phone3TypeName = _data["phone3TypeName"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.languageId = _data["languageId"];
            this.languageName = _data["languageName"];
            if (Array.isArray(_data["contactAddresses"])) {
                this.contactAddresses = [] as any;
                for (let item of _data["contactAddresses"])
                    this.contactAddresses!.push(AppContactAddressDto.fromJS(item));
            }
            this.userId = _data["userId"];
            this.accountId = _data["accountId"];
            this.jobTitle = _data["jobTitle"];
            this.joinDate = _data["joinDate"] ? moment(_data["joinDate"].toString()) : <any>undefined;
            this.languageIsPublic = _data["languageIsPublic"];
            this.emailAddressIsPublic = _data["emailAddressIsPublic"];
            this.phone1IsPublic = _data["phone1IsPublic"];
            this.phone2IsPublic = _data["phone2IsPublic"];
            this.phone3IsPublic = _data["phone3IsPublic"];
            this.joinDateIsPublic = _data["joinDateIsPublic"];
            this.userName = _data["userName"];
            this.userNameIsPublic = _data["userNameIsPublic"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.attachmentSourceTenantId = _data["attachmentSourceTenantId"];
            this.useDTOTenant = _data["useDTOTenant"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["titleId"] = this.titleId;
        data["tradeName"] = this.tradeName;
        data["parentId"] = this.parentId;
        data["website"] = this.website;
        data["phone1CountryKey"] = this.phone1CountryKey;
        data["phone1Number"] = this.phone1Number;
        data["phone1Ext"] = this.phone1Ext;
        data["phone2CountryKey"] = this.phone2CountryKey;
        data["phone2Number"] = this.phone2Number;
        data["phone2Ext"] = this.phone2Ext;
        data["phone3CountryKey"] = this.phone3CountryKey;
        data["phone3Number"] = this.phone3Number;
        data["phone3Ext"] = this.phone3Ext;
        data["eMailAddress"] = this.eMailAddress;
        data["phone1TypeId"] = this.phone1TypeId;
        data["phone1TypeName"] = this.phone1TypeName;
        data["phone2TypeId"] = this.phone2TypeId;
        data["phone2TypeName"] = this.phone2TypeName;
        data["phone3TypeId"] = this.phone3TypeId;
        data["phone3TypeName"] = this.phone3TypeName;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["languageId"] = this.languageId;
        data["languageName"] = this.languageName;
        if (Array.isArray(this.contactAddresses)) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        data["userId"] = this.userId;
        data["accountId"] = this.accountId;
        data["jobTitle"] = this.jobTitle;
        data["joinDate"] = this.joinDate ? this.joinDate.toISOString() : <any>undefined;
        data["languageIsPublic"] = this.languageIsPublic;
        data["emailAddressIsPublic"] = this.emailAddressIsPublic;
        data["phone1IsPublic"] = this.phone1IsPublic;
        data["phone2IsPublic"] = this.phone2IsPublic;
        data["phone3IsPublic"] = this.phone3IsPublic;
        data["joinDateIsPublic"] = this.joinDateIsPublic;
        data["userName"] = this.userName;
        data["userNameIsPublic"] = this.userNameIsPublic;
        data["notes"] = this.notes;
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["attachmentSourceTenantId"] = this.attachmentSourceTenantId;
        data["useDTOTenant"] = this.useDTOTenant;
        data["id"] = this.id;
        return data;
    }
}

export interface IContactDto {
    code: string | undefined;
    name: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    titleId: number | undefined;
    tradeName: string | undefined;
    parentId: number | undefined;
    website: string | undefined;
    phone1CountryKey: string | undefined;
    phone1Number: string | undefined;
    phone1Ext: string | undefined;
    phone2CountryKey: string | undefined;
    phone2Number: string | undefined;
    phone2Ext: string | undefined;
    phone3CountryKey: string | undefined;
    phone3Number: string | undefined;
    phone3Ext: string | undefined;
    eMailAddress: string | undefined;
    phone1TypeId: number | undefined;
    phone1TypeName: string | undefined;
    phone2TypeId: number | undefined;
    phone2TypeName: string | undefined;
    phone3TypeId: number | undefined;
    phone3TypeName: string | undefined;
    currencyId: number | undefined;
    currencyName: string | undefined;
    languageId: number | undefined;
    languageName: string | undefined;
    contactAddresses: AppContactAddressDto[] | undefined;
    userId: number | undefined;
    accountId: number;
    jobTitle: string | undefined;
    joinDate: moment.Moment;
    languageIsPublic: boolean;
    emailAddressIsPublic: boolean;
    phone1IsPublic: boolean;
    phone2IsPublic: boolean;
    phone3IsPublic: boolean;
    joinDateIsPublic: boolean;
    userName: string | undefined;
    userNameIsPublic: boolean;
    notes: string | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    tenantId: number | undefined;
    attachmentSourceTenantId: number | undefined;
    useDTOTenant: boolean;
    id: number;

    [key: string]: any;
}

export class ContactForEditDto implements IContactForEditDto {
    contact!: ContactDto;
    branchName!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    zipCode!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    countryId!: number;
    countryName!: string | undefined;
    imageUrl!: string | undefined;
    coverUrl!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IContactForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contact = _data["contact"] ? ContactDto.fromJS(_data["contact"]) : <any>undefined;
            this.branchName = _data["branchName"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.imageUrl = _data["imageUrl"];
            this.coverUrl = _data["coverUrl"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContactForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["branchName"] = this.branchName;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["imageUrl"] = this.imageUrl;
        data["coverUrl"] = this.coverUrl;
        data["id"] = this.id;
        return data;
    }
}

export interface IContactForEditDto {
    contact: ContactDto;
    branchName: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    countryId: number;
    countryName: string | undefined;
    imageUrl: string | undefined;
    coverUrl: string | undefined;
    id: number;

    [key: string]: any;
}

export class AppAddressDto implements IAppAddressDto {
    code!: string | undefined;
    tenantId!: number | undefined;
    accountId!: number;
    name!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number;
    countryCode!: string | undefined;
    countryIdName!: string | undefined;
    useDTOTenant!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.tenantId = _data["tenantId"];
            this.accountId = _data["accountId"];
            this.name = _data["name"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.countryCode = _data["countryCode"];
            this.countryIdName = _data["countryIdName"];
            this.useDTOTenant = _data["useDTOTenant"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["tenantId"] = this.tenantId;
        data["accountId"] = this.accountId;
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["countryCode"] = this.countryCode;
        data["countryIdName"] = this.countryIdName;
        data["useDTOTenant"] = this.useDTOTenant;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppAddressDto {
    code: string | undefined;
    tenantId: number | undefined;
    accountId: number;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number;
    countryCode: string | undefined;
    countryIdName: string | undefined;
    useDTOTenant: boolean;
    id: number;

    [key: string]: any;
}

export class SycEntityObjectClassificationDto implements ISycEntityObjectClassificationDto {
    code!: string | undefined;
    name!: string | undefined;
    objectId!: number | undefined;
    parentId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectClassificationDto {
    code: string | undefined;
    name: string | undefined;
    objectId: number | undefined;
    parentId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycEntityObjectClassificationForViewDto implements IGetSycEntityObjectClassificationForViewDto {
    sycEntityObjectClassification!: SycEntityObjectClassificationDto;
    sydObjectName!: string | undefined;
    sycEntityObjectClassificationName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectClassificationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectClassification = _data["sycEntityObjectClassification"] ? SycEntityObjectClassificationDto.fromJS(_data["sycEntityObjectClassification"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
            this.sycEntityObjectClassificationName = _data["sycEntityObjectClassificationName"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectClassificationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectClassificationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectClassification"] = this.sycEntityObjectClassification ? this.sycEntityObjectClassification.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        data["sycEntityObjectClassificationName"] = this.sycEntityObjectClassificationName;
        return data;
    }
}

export interface IGetSycEntityObjectClassificationForViewDto {
    sycEntityObjectClassification: SycEntityObjectClassificationDto;
    sydObjectName: string | undefined;
    sycEntityObjectClassificationName: string | undefined;

    [key: string]: any;
}

export class TreeNodeOfGetSycEntityObjectClassificationForViewDto implements ITreeNodeOfGetSycEntityObjectClassificationForViewDto {
    data!: GetSycEntityObjectClassificationForViewDto;
    children!: TreeNodeOfGetSycEntityObjectClassificationForViewDto[] | undefined;
    leaf!: boolean;
    expanded!: boolean;
    label!: string | undefined;
    totalChildrenCount!: number | undefined;

    [key: string]: any;

    constructor(data?: ITreeNodeOfGetSycEntityObjectClassificationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? GetSycEntityObjectClassificationForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(item));
            }
            this.leaf = _data["leaf"];
            this.expanded = _data["expanded"];
            this.label = _data["label"];
            this.totalChildrenCount = _data["totalChildrenCount"];
        }
    }

    static fromJS(data: any): TreeNodeOfGetSycEntityObjectClassificationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeOfGetSycEntityObjectClassificationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["leaf"] = this.leaf;
        data["expanded"] = this.expanded;
        data["label"] = this.label;
        data["totalChildrenCount"] = this.totalChildrenCount;
        return data;
    }
}

export interface ITreeNodeOfGetSycEntityObjectClassificationForViewDto {
    data: GetSycEntityObjectClassificationForViewDto;
    children: TreeNodeOfGetSycEntityObjectClassificationForViewDto[] | undefined;
    leaf: boolean;
    expanded: boolean;
    label: string | undefined;
    totalChildrenCount: number | undefined;

    [key: string]: any;
}

export class SycEntityObjectCategoryDto implements ISycEntityObjectCategoryDto {
    code!: string | undefined;
    name!: string | undefined;
    objectId!: number;
    parentId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectCategoryDto {
    code: string | undefined;
    name: string | undefined;
    objectId: number;
    parentId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycEntityObjectCategoryForViewDto implements IGetSycEntityObjectCategoryForViewDto {
    sycEntityObjectCategory!: SycEntityObjectCategoryDto;
    sydObjectName!: string | undefined;
    sycEntityObjectCategoryName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectCategory = _data["sycEntityObjectCategory"] ? SycEntityObjectCategoryDto.fromJS(_data["sycEntityObjectCategory"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
            this.sycEntityObjectCategoryName = _data["sycEntityObjectCategoryName"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectCategory"] = this.sycEntityObjectCategory ? this.sycEntityObjectCategory.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        data["sycEntityObjectCategoryName"] = this.sycEntityObjectCategoryName;
        return data;
    }
}

export interface IGetSycEntityObjectCategoryForViewDto {
    sycEntityObjectCategory: SycEntityObjectCategoryDto;
    sydObjectName: string | undefined;
    sycEntityObjectCategoryName: string | undefined;

    [key: string]: any;
}

export class TreeNodeOfGetSycEntityObjectCategoryForViewDto implements ITreeNodeOfGetSycEntityObjectCategoryForViewDto {
    data!: GetSycEntityObjectCategoryForViewDto;
    children!: TreeNodeOfGetSycEntityObjectCategoryForViewDto[] | undefined;
    leaf!: boolean;
    expanded!: boolean;
    label!: string | undefined;
    totalChildrenCount!: number | undefined;

    [key: string]: any;

    constructor(data?: ITreeNodeOfGetSycEntityObjectCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? GetSycEntityObjectCategoryForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(item));
            }
            this.leaf = _data["leaf"];
            this.expanded = _data["expanded"];
            this.label = _data["label"];
            this.totalChildrenCount = _data["totalChildrenCount"];
        }
    }

    static fromJS(data: any): TreeNodeOfGetSycEntityObjectCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeOfGetSycEntityObjectCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["leaf"] = this.leaf;
        data["expanded"] = this.expanded;
        data["label"] = this.label;
        data["totalChildrenCount"] = this.totalChildrenCount;
        return data;
    }
}

export interface ITreeNodeOfGetSycEntityObjectCategoryForViewDto {
    data: GetSycEntityObjectCategoryForViewDto;
    children: TreeNodeOfGetSycEntityObjectCategoryForViewDto[] | undefined;
    leaf: boolean;
    expanded: boolean;
    label: string | undefined;
    totalChildrenCount: number | undefined;

    [key: string]: any;
}

export class ExcelLogDto implements IExcelLogDto {
    excelLogPath!: string | undefined;
    excelLogFileName!: string | undefined;

    [key: string]: any;

    constructor(data?: IExcelLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.excelLogPath = _data["excelLogPath"];
            this.excelLogFileName = _data["excelLogFileName"];
        }
    }

    static fromJS(data: any): ExcelLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["excelLogPath"] = this.excelLogPath;
        data["excelLogFileName"] = this.excelLogFileName;
        return data;
    }
}

export interface IExcelLogDto {
    excelLogPath: string | undefined;
    excelLogFileName: string | undefined;

    [key: string]: any;
}

export enum ExcelRecordRepeateHandler {
    IgnoreDuplicatedRecords = 0,
    ReplaceDuplicatedRecords = 1,
    CreateACopy = 2,
}

export class AccountExcelDto implements IAccountExcelDto {
    rowNumber!: number;
    priceLevel!: string | undefined;
    recordType!: string | undefined;
    parentCode!: string | undefined;
    parentId!: number | undefined;
    accountId!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    language!: string | undefined;
    emailAddress!: string | undefined;
    phone1Type!: string | undefined;
    phone1Code!: string | undefined;
    phone1Number!: string | undefined;
    phone1Ext!: string | undefined;
    phone2Type!: string | undefined;
    phone2Code!: string | undefined;
    phone2Number!: string | undefined;
    phone2Ext!: string | undefined;
    phone3Type!: string | undefined;
    phone3Code!: string | undefined;
    phone3Number!: string | undefined;
    phone3Ext!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    title!: string | undefined;
    tradeName!: string | undefined;
    accountType!: string | undefined;
    aboutus!: string | undefined;
    currency!: string | undefined;
    website!: string | undefined;
    businessClassification1!: string | undefined;
    businessClassification2!: string | undefined;
    businessClassification3!: string | undefined;
    department1!: string | undefined;
    department2!: string | undefined;
    department3!: string | undefined;
    address1Type!: string | undefined;
    address1Code!: string | undefined;
    address1Name!: string | undefined;
    address1Line1!: string | undefined;
    address1Line2!: string | undefined;
    address1City!: string | undefined;
    address1State!: string | undefined;
    address1PostalCode!: string | undefined;
    address1Country!: string | undefined;
    address2Type!: string | undefined;
    address2Code!: string | undefined;
    address2Name!: string | undefined;
    address2Line1!: string | undefined;
    address2Line2!: string | undefined;
    address2City!: string | undefined;
    address2State!: string | undefined;
    address2PostalCode!: string | undefined;
    address2Country!: string | undefined;
    address3Type!: string | undefined;
    address3Code!: string | undefined;
    address3Name!: string | undefined;
    address3Line1!: string | undefined;
    address3Line2!: string | undefined;
    address3City!: string | undefined;
    address3State!: string | undefined;
    address3PostalCode!: string | undefined;
    address3Country!: string | undefined;
    address4Type!: string | undefined;
    address4Code!: string | undefined;
    address4Name!: string | undefined;
    address4Line1!: string | undefined;
    address4Line2!: string | undefined;
    address4City!: string | undefined;
    address4State!: string | undefined;
    address4PostalCode!: string | undefined;
    address4Country!: string | undefined;
    image1Type!: string | undefined;
    image1FileName!: string | undefined;
    image1Guid!: string | undefined;
    image2Type!: string | undefined;
    image2FileName!: string | undefined;
    image2Guid!: string | undefined;
    image3Type!: string | undefined;
    image3FileName!: string | undefined;
    image3Guid!: string | undefined;
    image4Type!: string | undefined;
    image4FileName!: string | undefined;
    image4Guid!: string | undefined;
    image5Type!: string | undefined;
    image5FileName!: string | undefined;
    image5Guid!: string | undefined;

    [key: string]: any;

    constructor(data?: IAccountExcelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.rowNumber = _data["rowNumber"];
            this.priceLevel = _data["priceLevel"];
            this.recordType = _data["recordType"];
            this.parentCode = _data["parentCode"];
            this.parentId = _data["parentId"];
            this.accountId = _data["accountId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.emailAddress = _data["emailAddress"];
            this.phone1Type = _data["phone1Type"];
            this.phone1Code = _data["phone1Code"];
            this.phone1Number = _data["phone1Number"];
            this.phone1Ext = _data["phone1Ext"];
            this.phone2Type = _data["phone2Type"];
            this.phone2Code = _data["phone2Code"];
            this.phone2Number = _data["phone2Number"];
            this.phone2Ext = _data["phone2Ext"];
            this.phone3Type = _data["phone3Type"];
            this.phone3Code = _data["phone3Code"];
            this.phone3Number = _data["phone3Number"];
            this.phone3Ext = _data["phone3Ext"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.title = _data["title"];
            this.tradeName = _data["tradeName"];
            this.accountType = _data["accountType"];
            this.aboutus = _data["aboutus"];
            this.currency = _data["currency"];
            this.website = _data["website"];
            this.businessClassification1 = _data["businessClassification1"];
            this.businessClassification2 = _data["businessClassification2"];
            this.businessClassification3 = _data["businessClassification3"];
            this.department1 = _data["department1"];
            this.department2 = _data["department2"];
            this.department3 = _data["department3"];
            this.address1Type = _data["address1Type"];
            this.address1Code = _data["address1Code"];
            this.address1Name = _data["address1Name"];
            this.address1Line1 = _data["address1Line1"];
            this.address1Line2 = _data["address1Line2"];
            this.address1City = _data["address1City"];
            this.address1State = _data["address1State"];
            this.address1PostalCode = _data["address1PostalCode"];
            this.address1Country = _data["address1Country"];
            this.address2Type = _data["address2Type"];
            this.address2Code = _data["address2Code"];
            this.address2Name = _data["address2Name"];
            this.address2Line1 = _data["address2Line1"];
            this.address2Line2 = _data["address2Line2"];
            this.address2City = _data["address2City"];
            this.address2State = _data["address2State"];
            this.address2PostalCode = _data["address2PostalCode"];
            this.address2Country = _data["address2Country"];
            this.address3Type = _data["address3Type"];
            this.address3Code = _data["address3Code"];
            this.address3Name = _data["address3Name"];
            this.address3Line1 = _data["address3Line1"];
            this.address3Line2 = _data["address3Line2"];
            this.address3City = _data["address3City"];
            this.address3State = _data["address3State"];
            this.address3PostalCode = _data["address3PostalCode"];
            this.address3Country = _data["address3Country"];
            this.address4Type = _data["address4Type"];
            this.address4Code = _data["address4Code"];
            this.address4Name = _data["address4Name"];
            this.address4Line1 = _data["address4Line1"];
            this.address4Line2 = _data["address4Line2"];
            this.address4City = _data["address4City"];
            this.address4State = _data["address4State"];
            this.address4PostalCode = _data["address4PostalCode"];
            this.address4Country = _data["address4Country"];
            this.image1Type = _data["image1Type"];
            this.image1FileName = _data["image1FileName"];
            this.image1Guid = _data["image1Guid"];
            this.image2Type = _data["image2Type"];
            this.image2FileName = _data["image2FileName"];
            this.image2Guid = _data["image2Guid"];
            this.image3Type = _data["image3Type"];
            this.image3FileName = _data["image3FileName"];
            this.image3Guid = _data["image3Guid"];
            this.image4Type = _data["image4Type"];
            this.image4FileName = _data["image4FileName"];
            this.image4Guid = _data["image4Guid"];
            this.image5Type = _data["image5Type"];
            this.image5FileName = _data["image5FileName"];
            this.image5Guid = _data["image5Guid"];
        }
    }

    static fromJS(data: any): AccountExcelDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountExcelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["rowNumber"] = this.rowNumber;
        data["priceLevel"] = this.priceLevel;
        data["recordType"] = this.recordType;
        data["parentCode"] = this.parentCode;
        data["parentId"] = this.parentId;
        data["accountId"] = this.accountId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["language"] = this.language;
        data["emailAddress"] = this.emailAddress;
        data["phone1Type"] = this.phone1Type;
        data["phone1Code"] = this.phone1Code;
        data["phone1Number"] = this.phone1Number;
        data["phone1Ext"] = this.phone1Ext;
        data["phone2Type"] = this.phone2Type;
        data["phone2Code"] = this.phone2Code;
        data["phone2Number"] = this.phone2Number;
        data["phone2Ext"] = this.phone2Ext;
        data["phone3Type"] = this.phone3Type;
        data["phone3Code"] = this.phone3Code;
        data["phone3Number"] = this.phone3Number;
        data["phone3Ext"] = this.phone3Ext;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["tradeName"] = this.tradeName;
        data["accountType"] = this.accountType;
        data["aboutus"] = this.aboutus;
        data["currency"] = this.currency;
        data["website"] = this.website;
        data["businessClassification1"] = this.businessClassification1;
        data["businessClassification2"] = this.businessClassification2;
        data["businessClassification3"] = this.businessClassification3;
        data["department1"] = this.department1;
        data["department2"] = this.department2;
        data["department3"] = this.department3;
        data["address1Type"] = this.address1Type;
        data["address1Code"] = this.address1Code;
        data["address1Name"] = this.address1Name;
        data["address1Line1"] = this.address1Line1;
        data["address1Line2"] = this.address1Line2;
        data["address1City"] = this.address1City;
        data["address1State"] = this.address1State;
        data["address1PostalCode"] = this.address1PostalCode;
        data["address1Country"] = this.address1Country;
        data["address2Type"] = this.address2Type;
        data["address2Code"] = this.address2Code;
        data["address2Name"] = this.address2Name;
        data["address2Line1"] = this.address2Line1;
        data["address2Line2"] = this.address2Line2;
        data["address2City"] = this.address2City;
        data["address2State"] = this.address2State;
        data["address2PostalCode"] = this.address2PostalCode;
        data["address2Country"] = this.address2Country;
        data["address3Type"] = this.address3Type;
        data["address3Code"] = this.address3Code;
        data["address3Name"] = this.address3Name;
        data["address3Line1"] = this.address3Line1;
        data["address3Line2"] = this.address3Line2;
        data["address3City"] = this.address3City;
        data["address3State"] = this.address3State;
        data["address3PostalCode"] = this.address3PostalCode;
        data["address3Country"] = this.address3Country;
        data["address4Type"] = this.address4Type;
        data["address4Code"] = this.address4Code;
        data["address4Name"] = this.address4Name;
        data["address4Line1"] = this.address4Line1;
        data["address4Line2"] = this.address4Line2;
        data["address4City"] = this.address4City;
        data["address4State"] = this.address4State;
        data["address4PostalCode"] = this.address4PostalCode;
        data["address4Country"] = this.address4Country;
        data["image1Type"] = this.image1Type;
        data["image1FileName"] = this.image1FileName;
        data["image1Guid"] = this.image1Guid;
        data["image2Type"] = this.image2Type;
        data["image2FileName"] = this.image2FileName;
        data["image2Guid"] = this.image2Guid;
        data["image3Type"] = this.image3Type;
        data["image3FileName"] = this.image3FileName;
        data["image3Guid"] = this.image3Guid;
        data["image4Type"] = this.image4Type;
        data["image4FileName"] = this.image4FileName;
        data["image4Guid"] = this.image4Guid;
        data["image5Type"] = this.image5Type;
        data["image5FileName"] = this.image5FileName;
        data["image5Guid"] = this.image5Guid;
        return data;
    }
}

export interface IAccountExcelDto {
    rowNumber: number;
    priceLevel: string | undefined;
    recordType: string | undefined;
    parentCode: string | undefined;
    parentId: number | undefined;
    accountId: number | undefined;
    code: string | undefined;
    name: string | undefined;
    language: string | undefined;
    emailAddress: string | undefined;
    phone1Type: string | undefined;
    phone1Code: string | undefined;
    phone1Number: string | undefined;
    phone1Ext: string | undefined;
    phone2Type: string | undefined;
    phone2Code: string | undefined;
    phone2Number: string | undefined;
    phone2Ext: string | undefined;
    phone3Type: string | undefined;
    phone3Code: string | undefined;
    phone3Number: string | undefined;
    phone3Ext: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    tradeName: string | undefined;
    accountType: string | undefined;
    aboutus: string | undefined;
    currency: string | undefined;
    website: string | undefined;
    businessClassification1: string | undefined;
    businessClassification2: string | undefined;
    businessClassification3: string | undefined;
    department1: string | undefined;
    department2: string | undefined;
    department3: string | undefined;
    address1Type: string | undefined;
    address1Code: string | undefined;
    address1Name: string | undefined;
    address1Line1: string | undefined;
    address1Line2: string | undefined;
    address1City: string | undefined;
    address1State: string | undefined;
    address1PostalCode: string | undefined;
    address1Country: string | undefined;
    address2Type: string | undefined;
    address2Code: string | undefined;
    address2Name: string | undefined;
    address2Line1: string | undefined;
    address2Line2: string | undefined;
    address2City: string | undefined;
    address2State: string | undefined;
    address2PostalCode: string | undefined;
    address2Country: string | undefined;
    address3Type: string | undefined;
    address3Code: string | undefined;
    address3Name: string | undefined;
    address3Line1: string | undefined;
    address3Line2: string | undefined;
    address3City: string | undefined;
    address3State: string | undefined;
    address3PostalCode: string | undefined;
    address3Country: string | undefined;
    address4Type: string | undefined;
    address4Code: string | undefined;
    address4Name: string | undefined;
    address4Line1: string | undefined;
    address4Line2: string | undefined;
    address4City: string | undefined;
    address4State: string | undefined;
    address4PostalCode: string | undefined;
    address4Country: string | undefined;
    image1Type: string | undefined;
    image1FileName: string | undefined;
    image1Guid: string | undefined;
    image2Type: string | undefined;
    image2FileName: string | undefined;
    image2Guid: string | undefined;
    image3Type: string | undefined;
    image3FileName: string | undefined;
    image3Guid: string | undefined;
    image4Type: string | undefined;
    image4FileName: string | undefined;
    image4Guid: string | undefined;
    image5Type: string | undefined;
    image5FileName: string | undefined;
    image5Guid: string | undefined;

    [key: string]: any;
}

export class AccountExcelRecordDTO implements IAccountExcelRecordDTO {
    recordType!: string | undefined;
    parentCode!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    fieldsErrors!: string[] | undefined;
    excelDto!: AccountExcelDto;
    status!: string | undefined;
    errorMessage!: string | undefined;
    image1Type!: string | undefined;
    image1!: string | undefined;
    image2Type!: string | undefined;
    image2!: string | undefined;
    image3Type!: string | undefined;
    image3!: string | undefined;
    image4Type!: string | undefined;
    image4!: string | undefined;
    image5Type!: string | undefined;
    image5!: string | undefined;

    [key: string]: any;

    constructor(data?: IAccountExcelRecordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.recordType = _data["recordType"];
            this.parentCode = _data["parentCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            if (Array.isArray(_data["fieldsErrors"])) {
                this.fieldsErrors = [] as any;
                for (let item of _data["fieldsErrors"])
                    this.fieldsErrors!.push(item);
            }
            this.excelDto = _data["excelDto"] ? AccountExcelDto.fromJS(_data["excelDto"]) : <any>undefined;
            this.status = _data["status"];
            this.errorMessage = _data["errorMessage"];
            this.image1Type = _data["image1Type"];
            this.image1 = _data["image1"];
            this.image2Type = _data["image2Type"];
            this.image2 = _data["image2"];
            this.image3Type = _data["image3Type"];
            this.image3 = _data["image3"];
            this.image4Type = _data["image4Type"];
            this.image4 = _data["image4"];
            this.image5Type = _data["image5Type"];
            this.image5 = _data["image5"];
        }
    }

    static fromJS(data: any): AccountExcelRecordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AccountExcelRecordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["recordType"] = this.recordType;
        data["parentCode"] = this.parentCode;
        data["code"] = this.code;
        data["name"] = this.name;
        if (Array.isArray(this.fieldsErrors)) {
            data["fieldsErrors"] = [];
            for (let item of this.fieldsErrors)
                data["fieldsErrors"].push(item);
        }
        data["excelDto"] = this.excelDto ? this.excelDto.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["errorMessage"] = this.errorMessage;
        data["image1Type"] = this.image1Type;
        data["image1"] = this.image1;
        data["image2Type"] = this.image2Type;
        data["image2"] = this.image2;
        data["image3Type"] = this.image3Type;
        data["image3"] = this.image3;
        data["image4Type"] = this.image4Type;
        data["image4"] = this.image4;
        data["image5Type"] = this.image5Type;
        data["image5"] = this.image5;
        return data;
    }
}

export interface IAccountExcelRecordDTO {
    recordType: string | undefined;
    parentCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
    fieldsErrors: string[] | undefined;
    excelDto: AccountExcelDto;
    status: string | undefined;
    errorMessage: string | undefined;
    image1Type: string | undefined;
    image1: string | undefined;
    image2Type: string | undefined;
    image2: string | undefined;
    image3Type: string | undefined;
    image3: string | undefined;
    image4Type: string | undefined;
    image4: string | undefined;
    image5Type: string | undefined;
    image5: string | undefined;

    [key: string]: any;
}

export class AccountExcelResultsDTO implements IAccountExcelResultsDTO {
    excelLogDTO!: ExcelLogDto;
    totalRecords!: number;
    codesFromList!: string[] | undefined;
    fromList!: number[] | undefined;
    from!: number;
    toList!: number[] | undefined;
    to!: number;
    totalPassedRecords!: number;
    totalFailedRecords!: number;
    repreateHandler!: ExcelRecordRepeateHandler;
    excelRecords!: AccountExcelRecordDTO[] | undefined;
    filePath!: string | undefined;
    errorMessage!: string | undefined;
    hasDuplication!: boolean;

    [key: string]: any;

    constructor(data?: IAccountExcelResultsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.excelLogDTO = _data["excelLogDTO"] ? ExcelLogDto.fromJS(_data["excelLogDTO"]) : <any>undefined;
            this.totalRecords = _data["totalRecords"];
            if (Array.isArray(_data["codesFromList"])) {
                this.codesFromList = [] as any;
                for (let item of _data["codesFromList"])
                    this.codesFromList!.push(item);
            }
            if (Array.isArray(_data["fromList"])) {
                this.fromList = [] as any;
                for (let item of _data["fromList"])
                    this.fromList!.push(item);
            }
            this.from = _data["from"];
            if (Array.isArray(_data["toList"])) {
                this.toList = [] as any;
                for (let item of _data["toList"])
                    this.toList!.push(item);
            }
            this.to = _data["to"];
            this.totalPassedRecords = _data["totalPassedRecords"];
            this.totalFailedRecords = _data["totalFailedRecords"];
            this.repreateHandler = _data["repreateHandler"];
            if (Array.isArray(_data["excelRecords"])) {
                this.excelRecords = [] as any;
                for (let item of _data["excelRecords"])
                    this.excelRecords!.push(AccountExcelRecordDTO.fromJS(item));
            }
            this.filePath = _data["filePath"];
            this.errorMessage = _data["errorMessage"];
            this.hasDuplication = _data["hasDuplication"];
        }
    }

    static fromJS(data: any): AccountExcelResultsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AccountExcelResultsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["excelLogDTO"] = this.excelLogDTO ? this.excelLogDTO.toJSON() : <any>undefined;
        data["totalRecords"] = this.totalRecords;
        if (Array.isArray(this.codesFromList)) {
            data["codesFromList"] = [];
            for (let item of this.codesFromList)
                data["codesFromList"].push(item);
        }
        if (Array.isArray(this.fromList)) {
            data["fromList"] = [];
            for (let item of this.fromList)
                data["fromList"].push(item);
        }
        data["from"] = this.from;
        if (Array.isArray(this.toList)) {
            data["toList"] = [];
            for (let item of this.toList)
                data["toList"].push(item);
        }
        data["to"] = this.to;
        data["totalPassedRecords"] = this.totalPassedRecords;
        data["totalFailedRecords"] = this.totalFailedRecords;
        data["repreateHandler"] = this.repreateHandler;
        if (Array.isArray(this.excelRecords)) {
            data["excelRecords"] = [];
            for (let item of this.excelRecords)
                data["excelRecords"].push(item.toJSON());
        }
        data["filePath"] = this.filePath;
        data["errorMessage"] = this.errorMessage;
        data["hasDuplication"] = this.hasDuplication;
        return data;
    }
}

export interface IAccountExcelResultsDTO {
    excelLogDTO: ExcelLogDto;
    totalRecords: number;
    codesFromList: string[] | undefined;
    fromList: number[] | undefined;
    from: number;
    toList: number[] | undefined;
    to: number;
    totalPassedRecords: number;
    totalFailedRecords: number;
    repreateHandler: ExcelRecordRepeateHandler;
    excelRecords: AccountExcelRecordDTO[] | undefined;
    filePath: string | undefined;
    errorMessage: string | undefined;
    hasDuplication: boolean;

    [key: string]: any;
}

export class ExcelTemplateDto implements IExcelTemplateDto {
    excelTemplatePath!: string | undefined;
    excelTemplateFile!: string | undefined;
    excelTemplateFullPath!: string | undefined;
    excelTemplateDate!: string | undefined;
    excelTemplateVersion!: string | undefined;

    [key: string]: any;

    constructor(data?: IExcelTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.excelTemplatePath = _data["excelTemplatePath"];
            this.excelTemplateFile = _data["excelTemplateFile"];
            this.excelTemplateFullPath = _data["excelTemplateFullPath"];
            this.excelTemplateDate = _data["excelTemplateDate"];
            this.excelTemplateVersion = _data["excelTemplateVersion"];
        }
    }

    static fromJS(data: any): ExcelTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["excelTemplatePath"] = this.excelTemplatePath;
        data["excelTemplateFile"] = this.excelTemplateFile;
        data["excelTemplateFullPath"] = this.excelTemplateFullPath;
        data["excelTemplateDate"] = this.excelTemplateDate;
        data["excelTemplateVersion"] = this.excelTemplateVersion;
        return data;
    }
}

export interface IExcelTemplateDto {
    excelTemplatePath: string | undefined;
    excelTemplateFile: string | undefined;
    excelTemplateFullPath: string | undefined;
    excelTemplateDate: string | undefined;
    excelTemplateVersion: string | undefined;

    [key: string]: any;
}

export class LookupAccountOrTenantDto implements ILookupAccountOrTenantDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ILookupAccountOrTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): LookupAccountOrTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupAccountOrTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ILookupAccountOrTenantDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfLookupAccountOrTenantDto implements IPagedResultDtoOfLookupAccountOrTenantDto {
    totalCount!: number;
    items!: LookupAccountOrTenantDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfLookupAccountOrTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupAccountOrTenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupAccountOrTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupAccountOrTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLookupAccountOrTenantDto {
    totalCount: number;
    items: LookupAccountOrTenantDto[] | undefined;

    [key: string]: any;
}

export enum SourceAccountEnum {
    Manual = 0,
    External = 1,
}

export enum TargetAccountEnum {
    Manual = 0,
    External = 1,
    NewTenant = 2,
}

export class CreateAccountsInputDto implements ICreateAccountsInputDto {
    sourceAccountType!: SourceAccountEnum;
    targetAccountType!: TargetAccountEnum;
    sourceAccountId!: number;
    targetAccountId!: number;
    sourceTenantId!: number | undefined;
    targetTenantId!: number | undefined;
    deleteSourceAccount!: boolean;
    deleteTargetAccount!: boolean;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    [key: string]: any;

    constructor(data?: ICreateAccountsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sourceAccountType = _data["sourceAccountType"];
            this.targetAccountType = _data["targetAccountType"];
            this.sourceAccountId = _data["sourceAccountId"];
            this.targetAccountId = _data["targetAccountId"];
            this.sourceTenantId = _data["sourceTenantId"];
            this.targetTenantId = _data["targetTenantId"];
            this.deleteSourceAccount = _data["deleteSourceAccount"];
            this.deleteTargetAccount = _data["deleteTargetAccount"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): CreateAccountsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sourceAccountType"] = this.sourceAccountType;
        data["targetAccountType"] = this.targetAccountType;
        data["sourceAccountId"] = this.sourceAccountId;
        data["targetAccountId"] = this.targetAccountId;
        data["sourceTenantId"] = this.sourceTenantId;
        data["targetTenantId"] = this.targetTenantId;
        data["deleteSourceAccount"] = this.deleteSourceAccount;
        data["deleteTargetAccount"] = this.deleteTargetAccount;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ICreateAccountsInputDto {
    sourceAccountType: SourceAccountEnum;
    targetAccountType: TargetAccountEnum;
    sourceAccountId: number;
    targetAccountId: number;
    sourceTenantId: number | undefined;
    targetTenantId: number | undefined;
    deleteSourceAccount: boolean;
    deleteTargetAccount: boolean;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    [key: string]: any;
}

export class SysObjectType implements ISysObjectType {
    name!: string;
    code!: string;
    parentId!: number | undefined;
    parentFk!: SysObjectType;
    parentCode!: string | undefined;
    sysObjectTypes!: SysObjectType[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISysObjectType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.parentFk = _data["parentFk"] ? SysObjectType.fromJS(_data["parentFk"]) : <any>undefined;
            this.parentCode = _data["parentCode"];
            if (Array.isArray(_data["sysObjectTypes"])) {
                this.sysObjectTypes = [] as any;
                for (let item of _data["sysObjectTypes"])
                    this.sysObjectTypes!.push(SysObjectType.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SysObjectType {
        data = typeof data === 'object' ? data : {};
        let result = new SysObjectType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["parentFk"] = this.parentFk ? this.parentFk.toJSON() : <any>undefined;
        data["parentCode"] = this.parentCode;
        if (Array.isArray(this.sysObjectTypes)) {
            data["sysObjectTypes"] = [];
            for (let item of this.sysObjectTypes)
                data["sysObjectTypes"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISysObjectType {
    name: string;
    code: string;
    parentId: number | undefined;
    parentFk: SysObjectType;
    parentCode: string | undefined;
    sysObjectTypes: SysObjectType[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class SycIdentifierDefinition implements ISycIdentifierDefinition {
    tenantId!: number | undefined;
    code!: string | undefined;
    isTenantLevel!: boolean;
    numberOfSegments!: number;
    maxLength!: number;
    minSegmentLength!: number;
    maxSegmentLength!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycIdentifierDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.isTenantLevel = _data["isTenantLevel"];
            this.numberOfSegments = _data["numberOfSegments"];
            this.maxLength = _data["maxLength"];
            this.minSegmentLength = _data["minSegmentLength"];
            this.maxSegmentLength = _data["maxSegmentLength"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycIdentifierDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new SycIdentifierDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["isTenantLevel"] = this.isTenantLevel;
        data["numberOfSegments"] = this.numberOfSegments;
        data["maxLength"] = this.maxLength;
        data["minSegmentLength"] = this.minSegmentLength;
        data["maxSegmentLength"] = this.maxSegmentLength;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycIdentifierDefinition {
    tenantId: number | undefined;
    code: string | undefined;
    isTenantLevel: boolean;
    numberOfSegments: number;
    maxLength: number;
    minSegmentLength: number;
    maxSegmentLength: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class SydObject implements ISydObject {
    name!: string;
    code!: string;
    objectTypeId!: number;
    objectTypeFk!: SysObjectType;
    objectTypeCode!: string | undefined;
    parentId!: number | undefined;
    parentFk!: SydObject;
    parentCode!: string | undefined;
    sydObjects!: SydObject[] | undefined;
    ssinIdentifierId!: number | undefined;
    ssinIdentifierCode!: string | undefined;
    sycDefaultIdentifierId!: number | undefined;
    sycDefaultIdentifierCode!: string | undefined;
    ssinIdentifierIdFk!: SycIdentifierDefinition;
    sycDefaultIdentifierIdFk!: SycIdentifierDefinition;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISydObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.objectTypeId = _data["objectTypeId"];
            this.objectTypeFk = _data["objectTypeFk"] ? SysObjectType.fromJS(_data["objectTypeFk"]) : <any>undefined;
            this.objectTypeCode = _data["objectTypeCode"];
            this.parentId = _data["parentId"];
            this.parentFk = _data["parentFk"] ? SydObject.fromJS(_data["parentFk"]) : <any>undefined;
            this.parentCode = _data["parentCode"];
            if (Array.isArray(_data["sydObjects"])) {
                this.sydObjects = [] as any;
                for (let item of _data["sydObjects"])
                    this.sydObjects!.push(SydObject.fromJS(item));
            }
            this.ssinIdentifierId = _data["ssinIdentifierId"];
            this.ssinIdentifierCode = _data["ssinIdentifierCode"];
            this.sycDefaultIdentifierId = _data["sycDefaultIdentifierId"];
            this.sycDefaultIdentifierCode = _data["sycDefaultIdentifierCode"];
            this.ssinIdentifierIdFk = _data["ssinIdentifierIdFk"] ? SycIdentifierDefinition.fromJS(_data["ssinIdentifierIdFk"]) : <any>undefined;
            this.sycDefaultIdentifierIdFk = _data["sycDefaultIdentifierIdFk"] ? SycIdentifierDefinition.fromJS(_data["sycDefaultIdentifierIdFk"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SydObject {
        data = typeof data === 'object' ? data : {};
        let result = new SydObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["objectTypeId"] = this.objectTypeId;
        data["objectTypeFk"] = this.objectTypeFk ? this.objectTypeFk.toJSON() : <any>undefined;
        data["objectTypeCode"] = this.objectTypeCode;
        data["parentId"] = this.parentId;
        data["parentFk"] = this.parentFk ? this.parentFk.toJSON() : <any>undefined;
        data["parentCode"] = this.parentCode;
        if (Array.isArray(this.sydObjects)) {
            data["sydObjects"] = [];
            for (let item of this.sydObjects)
                data["sydObjects"].push(item.toJSON());
        }
        data["ssinIdentifierId"] = this.ssinIdentifierId;
        data["ssinIdentifierCode"] = this.ssinIdentifierCode;
        data["sycDefaultIdentifierId"] = this.sycDefaultIdentifierId;
        data["sycDefaultIdentifierCode"] = this.sycDefaultIdentifierCode;
        data["ssinIdentifierIdFk"] = this.ssinIdentifierIdFk ? this.ssinIdentifierIdFk.toJSON() : <any>undefined;
        data["sycDefaultIdentifierIdFk"] = this.sycDefaultIdentifierIdFk ? this.sycDefaultIdentifierIdFk.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISydObject {
    name: string;
    code: string;
    objectTypeId: number;
    objectTypeFk: SysObjectType;
    objectTypeCode: string | undefined;
    parentId: number | undefined;
    parentFk: SydObject;
    parentCode: string | undefined;
    sydObjects: SydObject[] | undefined;
    ssinIdentifierId: number | undefined;
    ssinIdentifierCode: string | undefined;
    sycDefaultIdentifierId: number | undefined;
    sycDefaultIdentifierCode: string | undefined;
    ssinIdentifierIdFk: SycIdentifierDefinition;
    sycDefaultIdentifierIdFk: SycIdentifierDefinition;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class SycEntityObjectType implements ISycEntityObjectType {
    code!: string;
    name!: string;
    extraAttributes!: string | undefined;
    objectId!: number;
    objectFk!: SydObject;
    objectCode!: string | undefined;
    parentId!: number | undefined;
    parentFk!: SycEntityObjectType;
    parentCode!: string | undefined;
    sycIdentifierDefinitionId!: number | undefined;
    sycIdentifierDefinitionFK!: SycIdentifierDefinition;
    sycEntityObjectTypes!: SycEntityObjectType[] | undefined;
    hidden!: boolean | undefined;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.extraAttributes = _data["extraAttributes"];
            this.objectId = _data["objectId"];
            this.objectFk = _data["objectFk"] ? SydObject.fromJS(_data["objectFk"]) : <any>undefined;
            this.objectCode = _data["objectCode"];
            this.parentId = _data["parentId"];
            this.parentFk = _data["parentFk"] ? SycEntityObjectType.fromJS(_data["parentFk"]) : <any>undefined;
            this.parentCode = _data["parentCode"];
            this.sycIdentifierDefinitionId = _data["sycIdentifierDefinitionId"];
            this.sycIdentifierDefinitionFK = _data["sycIdentifierDefinitionFK"] ? SycIdentifierDefinition.fromJS(_data["sycIdentifierDefinitionFK"]) : <any>undefined;
            if (Array.isArray(_data["sycEntityObjectTypes"])) {
                this.sycEntityObjectTypes = [] as any;
                for (let item of _data["sycEntityObjectTypes"])
                    this.sycEntityObjectTypes!.push(SycEntityObjectType.fromJS(item));
            }
            this.hidden = _data["hidden"];
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectType {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["extraAttributes"] = this.extraAttributes;
        data["objectId"] = this.objectId;
        data["objectFk"] = this.objectFk ? this.objectFk.toJSON() : <any>undefined;
        data["objectCode"] = this.objectCode;
        data["parentId"] = this.parentId;
        data["parentFk"] = this.parentFk ? this.parentFk.toJSON() : <any>undefined;
        data["parentCode"] = this.parentCode;
        data["sycIdentifierDefinitionId"] = this.sycIdentifierDefinitionId;
        data["sycIdentifierDefinitionFK"] = this.sycIdentifierDefinitionFK ? this.sycIdentifierDefinitionFK.toJSON() : <any>undefined;
        if (Array.isArray(this.sycEntityObjectTypes)) {
            data["sycEntityObjectTypes"] = [];
            for (let item of this.sycEntityObjectTypes)
                data["sycEntityObjectTypes"].push(item.toJSON());
        }
        data["hidden"] = this.hidden;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectType {
    code: string;
    name: string;
    extraAttributes: string | undefined;
    objectId: number;
    objectFk: SydObject;
    objectCode: string | undefined;
    parentId: number | undefined;
    parentFk: SycEntityObjectType;
    parentCode: string | undefined;
    sycIdentifierDefinitionId: number | undefined;
    sycIdentifierDefinitionFK: SycIdentifierDefinition;
    sycEntityObjectTypes: SycEntityObjectType[] | undefined;
    hidden: boolean | undefined;
    tenantId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class UserLogin implements IUserLogin {
    tenantId!: number | undefined;
    userId!: number;
    loginProvider!: string;
    providerKey!: string;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;

    [key: string]: any;
}

export class UserRole implements IUserRole {
    tenantId!: number | undefined;
    userId!: number;
    roleId!: number;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class UserClaim implements IUserClaim {
    tenantId!: number | undefined;
    userId!: number;
    claimType!: string | undefined;
    claimValue!: string | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId!: number;
    tenantId!: number | undefined;
    name!: string;
    isGranted!: boolean;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class Setting implements ISetting {
    tenantId!: number | undefined;
    userId!: number | undefined;
    name!: string;
    value!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AbpUserBase implements IAbpUserBase {
    authenticationSource!: string | undefined;
    userName!: string;
    tenantId!: number | undefined;
    emailAddress!: string;
    name!: string;
    surname!: string;
    readonly fullName!: string | undefined;
    password!: string;
    emailConfirmationCode!: string | undefined;
    passwordResetCode!: string | undefined;
    lockoutEndDateUtc!: moment.Moment | undefined;
    accessFailedCount!: number;
    isLockoutEnabled!: boolean;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    securityStamp!: string | undefined;
    isTwoFactorEnabled!: boolean;
    logins!: UserLogin[] | undefined;
    roles!: UserRole[] | undefined;
    claims!: UserClaim[] | undefined;
    permissions!: UserPermissionSetting[] | undefined;
    settings!: Setting[] | undefined;
    isEmailConfirmed!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAbpUserBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AbpUserBase {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAbpUserBase {
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class SycEntityObjectStatus implements ISycEntityObjectStatus {
    code!: string | undefined;
    name!: string;
    objectId!: number;
    objectFk!: SydObject;
    objectCode!: string | undefined;
    tenantId!: number | undefined;
    userFk!: AbpUserBase;
    isDefault!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDefault = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.objectFk = _data["objectFk"] ? SydObject.fromJS(_data["objectFk"]) : <any>undefined;
            this.objectCode = _data["objectCode"];
            this.tenantId = _data["tenantId"];
            this.userFk = _data["userFk"] ? AbpUserBase.fromJS(_data["userFk"]) : <any>undefined;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : false;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["objectFk"] = this.objectFk ? this.objectFk.toJSON() : <any>undefined;
        data["objectCode"] = this.objectCode;
        data["tenantId"] = this.tenantId;
        data["userFk"] = this.userFk ? this.userFk.toJSON() : <any>undefined;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectStatus {
    code: string | undefined;
    name: string;
    objectId: number;
    objectFk: SydObject;
    objectCode: string | undefined;
    tenantId: number | undefined;
    userFk: AbpUserBase;
    isDefault: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class SycEntityObjectCategory implements ISycEntityObjectCategory {
    code!: string;
    name!: string;
    objectId!: number;
    objectFk!: SydObject;
    objectCode!: string | undefined;
    parentId!: number | undefined;
    parentFk!: SycEntityObjectCategory;
    parentCode!: string | undefined;
    sycEntityObjectCategories!: SycEntityObjectCategory[] | undefined;
    tenantId!: number | undefined;
    userId!: number | undefined;
    userFk!: AbpUserBase;
    isDefault!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDefault = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.objectFk = _data["objectFk"] ? SydObject.fromJS(_data["objectFk"]) : <any>undefined;
            this.objectCode = _data["objectCode"];
            this.parentId = _data["parentId"];
            this.parentFk = _data["parentFk"] ? SycEntityObjectCategory.fromJS(_data["parentFk"]) : <any>undefined;
            this.parentCode = _data["parentCode"];
            if (Array.isArray(_data["sycEntityObjectCategories"])) {
                this.sycEntityObjectCategories = [] as any;
                for (let item of _data["sycEntityObjectCategories"])
                    this.sycEntityObjectCategories!.push(SycEntityObjectCategory.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.userFk = _data["userFk"] ? AbpUserBase.fromJS(_data["userFk"]) : <any>undefined;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : false;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["objectFk"] = this.objectFk ? this.objectFk.toJSON() : <any>undefined;
        data["objectCode"] = this.objectCode;
        data["parentId"] = this.parentId;
        data["parentFk"] = this.parentFk ? this.parentFk.toJSON() : <any>undefined;
        data["parentCode"] = this.parentCode;
        if (Array.isArray(this.sycEntityObjectCategories)) {
            data["sycEntityObjectCategories"] = [];
            for (let item of this.sycEntityObjectCategories)
                data["sycEntityObjectCategories"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["userFk"] = this.userFk ? this.userFk.toJSON() : <any>undefined;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectCategory {
    code: string;
    name: string;
    objectId: number;
    objectFk: SydObject;
    objectCode: string | undefined;
    parentId: number | undefined;
    parentFk: SycEntityObjectCategory;
    parentCode: string | undefined;
    sycEntityObjectCategories: SycEntityObjectCategory[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    userFk: AbpUserBase;
    isDefault: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntityCategory implements IAppEntityCategory {
    entityId!: number;
    entityCode!: string | undefined;
    entityObjectCategoryId!: number;
    entityObjectCategoryCode!: string | undefined;
    entityFk!: AppEntity;
    entityObjectCategoryFk!: SycEntityObjectCategory;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.entityObjectCategoryId = _data["entityObjectCategoryId"];
            this.entityObjectCategoryCode = _data["entityObjectCategoryCode"];
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.entityObjectCategoryFk = _data["entityObjectCategoryFk"] ? SycEntityObjectCategory.fromJS(_data["entityObjectCategoryFk"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityCategory {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["entityObjectCategoryId"] = this.entityObjectCategoryId;
        data["entityObjectCategoryCode"] = this.entityObjectCategoryCode;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["entityObjectCategoryFk"] = this.entityObjectCategoryFk ? this.entityObjectCategoryFk.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityCategory {
    entityId: number;
    entityCode: string | undefined;
    entityObjectCategoryId: number;
    entityObjectCategoryCode: string | undefined;
    entityFk: AppEntity;
    entityObjectCategoryFk: SycEntityObjectCategory;
    id: number;

    [key: string]: any;
}

export class SycEntityObjectClassification implements ISycEntityObjectClassification {
    code!: string;
    name!: string;
    objectId!: number | undefined;
    objectFk!: SydObject;
    objectCode!: string | undefined;
    parentId!: number | undefined;
    parentFk!: SycEntityObjectClassification;
    parentCode!: string | undefined;
    sycEntityObjectClassifications!: SycEntityObjectClassification[] | undefined;
    tenantId!: number | undefined;
    userFk!: AbpUserBase;
    isDefault!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDefault = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.objectFk = _data["objectFk"] ? SydObject.fromJS(_data["objectFk"]) : <any>undefined;
            this.objectCode = _data["objectCode"];
            this.parentId = _data["parentId"];
            this.parentFk = _data["parentFk"] ? SycEntityObjectClassification.fromJS(_data["parentFk"]) : <any>undefined;
            this.parentCode = _data["parentCode"];
            if (Array.isArray(_data["sycEntityObjectClassifications"])) {
                this.sycEntityObjectClassifications = [] as any;
                for (let item of _data["sycEntityObjectClassifications"])
                    this.sycEntityObjectClassifications!.push(SycEntityObjectClassification.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.userFk = _data["userFk"] ? AbpUserBase.fromJS(_data["userFk"]) : <any>undefined;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : false;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectClassification {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["objectFk"] = this.objectFk ? this.objectFk.toJSON() : <any>undefined;
        data["objectCode"] = this.objectCode;
        data["parentId"] = this.parentId;
        data["parentFk"] = this.parentFk ? this.parentFk.toJSON() : <any>undefined;
        data["parentCode"] = this.parentCode;
        if (Array.isArray(this.sycEntityObjectClassifications)) {
            data["sycEntityObjectClassifications"] = [];
            for (let item of this.sycEntityObjectClassifications)
                data["sycEntityObjectClassifications"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userFk"] = this.userFk ? this.userFk.toJSON() : <any>undefined;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectClassification {
    code: string;
    name: string;
    objectId: number | undefined;
    objectFk: SydObject;
    objectCode: string | undefined;
    parentId: number | undefined;
    parentFk: SycEntityObjectClassification;
    parentCode: string | undefined;
    sycEntityObjectClassifications: SycEntityObjectClassification[] | undefined;
    tenantId: number | undefined;
    userFk: AbpUserBase;
    isDefault: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntityClassification implements IAppEntityClassification {
    entityId!: number;
    entityCode!: string | undefined;
    entityObjectClassificationId!: number;
    entityObjectClassificationCode!: string | undefined;
    entityFk!: AppEntity;
    entityObjectClassificationFk!: SycEntityObjectClassification;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.entityObjectClassificationId = _data["entityObjectClassificationId"];
            this.entityObjectClassificationCode = _data["entityObjectClassificationCode"];
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.entityObjectClassificationFk = _data["entityObjectClassificationFk"] ? SycEntityObjectClassification.fromJS(_data["entityObjectClassificationFk"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityClassification {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["entityObjectClassificationId"] = this.entityObjectClassificationId;
        data["entityObjectClassificationCode"] = this.entityObjectClassificationCode;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["entityObjectClassificationFk"] = this.entityObjectClassificationFk ? this.entityObjectClassificationFk.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityClassification {
    entityId: number;
    entityCode: string | undefined;
    entityObjectClassificationId: number;
    entityObjectClassificationCode: string | undefined;
    entityFk: AppEntity;
    entityObjectClassificationFk: SycEntityObjectClassification;
    id: number;

    [key: string]: any;
}

export class AppAttachment implements IAppAttachment {
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    attachment!: string | undefined;
    attributes!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.attachment = _data["attachment"];
            this.attributes = _data["attributes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new AppAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["attachment"] = this.attachment;
        data["attributes"] = this.attributes;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppAttachment {
    tenantId: number | undefined;
    code: string | undefined;
    name: string | undefined;
    attachment: string | undefined;
    attributes: string | undefined;
    id: number;

    [key: string]: any;
}

export enum AttachmentType {
    Image = 1,
    Video = 2,
    Document = 3,
}

export class SycAttachmentCategory implements ISycAttachmentCategory {
    code!: string;
    name!: string;
    attributes!: string | undefined;
    parentId!: number | undefined;
    parentFk!: SycAttachmentCategory;
    parentCode!: string | undefined;
    entityObjectTypeId!: number | undefined;
    entityObjectTypeFk!: SycEntityObjectType;
    entityObjectTypeCode!: string | undefined;
    aspectRatio!: string | undefined;
    message!: string | undefined;
    maxFileSize!: number | undefined;
    type!: AttachmentType;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycAttachmentCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.attributes = _data["attributes"];
            this.parentId = _data["parentId"];
            this.parentFk = _data["parentFk"] ? SycAttachmentCategory.fromJS(_data["parentFk"]) : <any>undefined;
            this.parentCode = _data["parentCode"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeFk = _data["entityObjectTypeFk"] ? SycEntityObjectType.fromJS(_data["entityObjectTypeFk"]) : <any>undefined;
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.aspectRatio = _data["aspectRatio"];
            this.message = _data["message"];
            this.maxFileSize = _data["maxFileSize"];
            this.type = _data["type"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycAttachmentCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SycAttachmentCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["attributes"] = this.attributes;
        data["parentId"] = this.parentId;
        data["parentFk"] = this.parentFk ? this.parentFk.toJSON() : <any>undefined;
        data["parentCode"] = this.parentCode;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeFk"] = this.entityObjectTypeFk ? this.entityObjectTypeFk.toJSON() : <any>undefined;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["aspectRatio"] = this.aspectRatio;
        data["message"] = this.message;
        data["maxFileSize"] = this.maxFileSize;
        data["type"] = this.type;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycAttachmentCategory {
    code: string;
    name: string;
    attributes: string | undefined;
    parentId: number | undefined;
    parentFk: SycAttachmentCategory;
    parentCode: string | undefined;
    entityObjectTypeId: number | undefined;
    entityObjectTypeFk: SycEntityObjectType;
    entityObjectTypeCode: string | undefined;
    aspectRatio: string | undefined;
    message: string | undefined;
    maxFileSize: number | undefined;
    type: AttachmentType;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntityAttachment implements IAppEntityAttachment {
    entityId!: number;
    entityCode!: string | undefined;
    attachmentId!: number;
    attachmentCode!: string | undefined;
    attachmentCategoryId!: number;
    attachmentCategoryCode!: string | undefined;
    entityFk!: AppEntity;
    attachmentFk!: AppAttachment;
    attachmentCategoryFk!: SycAttachmentCategory;
    attributes!: string | undefined;
    isDefault!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.attachmentId = _data["attachmentId"];
            this.attachmentCode = _data["attachmentCode"];
            this.attachmentCategoryId = _data["attachmentCategoryId"];
            this.attachmentCategoryCode = _data["attachmentCategoryCode"];
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.attachmentFk = _data["attachmentFk"] ? AppAttachment.fromJS(_data["attachmentFk"]) : <any>undefined;
            this.attachmentCategoryFk = _data["attachmentCategoryFk"] ? SycAttachmentCategory.fromJS(_data["attachmentCategoryFk"]) : <any>undefined;
            this.attributes = _data["attributes"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["attachmentId"] = this.attachmentId;
        data["attachmentCode"] = this.attachmentCode;
        data["attachmentCategoryId"] = this.attachmentCategoryId;
        data["attachmentCategoryCode"] = this.attachmentCategoryCode;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["attachmentFk"] = this.attachmentFk ? this.attachmentFk.toJSON() : <any>undefined;
        data["attachmentCategoryFk"] = this.attachmentCategoryFk ? this.attachmentCategoryFk.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityAttachment {
    entityId: number;
    entityCode: string | undefined;
    attachmentId: number;
    attachmentCode: string | undefined;
    attachmentCategoryId: number;
    attachmentCategoryCode: string | undefined;
    entityFk: AppEntity;
    attachmentFk: AppAttachment;
    attachmentCategoryFk: SycAttachmentCategory;
    attributes: string | undefined;
    isDefault: boolean;
    id: number;

    [key: string]: any;
}

export class AppAddress implements IAppAddress {
    accountId!: number;
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number;
    countryCode!: string | undefined;
    countryFk!: AppEntity;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountId = _data["accountId"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.countryCode = _data["countryCode"];
            this.countryFk = _data["countryFk"] ? AppEntity.fromJS(_data["countryFk"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppAddress {
        data = typeof data === 'object' ? data : {};
        let result = new AppAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["countryCode"] = this.countryCode;
        data["countryFk"] = this.countryFk ? this.countryFk.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppAddress {
    accountId: number;
    tenantId: number | undefined;
    code: string | undefined;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number;
    countryCode: string | undefined;
    countryFk: AppEntity;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntityAddress implements IAppEntityAddress {
    entityId!: number;
    entityCode!: string | undefined;
    addressTypeId!: number;
    addressTypeCode!: string | undefined;
    addressId!: number;
    addressCode!: string | undefined;
    addressTypeFk!: AppEntity;
    addressFk!: AppAddress;
    entityFk!: AppEntity;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.addressTypeId = _data["addressTypeId"];
            this.addressTypeCode = _data["addressTypeCode"];
            this.addressId = _data["addressId"];
            this.addressCode = _data["addressCode"];
            this.addressTypeFk = _data["addressTypeFk"] ? AppEntity.fromJS(_data["addressTypeFk"]) : <any>undefined;
            this.addressFk = _data["addressFk"] ? AppAddress.fromJS(_data["addressFk"]) : <any>undefined;
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityAddress {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["addressTypeId"] = this.addressTypeId;
        data["addressTypeCode"] = this.addressTypeCode;
        data["addressId"] = this.addressId;
        data["addressCode"] = this.addressCode;
        data["addressTypeFk"] = this.addressTypeFk ? this.addressTypeFk.toJSON() : <any>undefined;
        data["addressFk"] = this.addressFk ? this.addressFk.toJSON() : <any>undefined;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityAddress {
    entityId: number;
    entityCode: string | undefined;
    addressTypeId: number;
    addressTypeCode: string | undefined;
    addressId: number;
    addressCode: string | undefined;
    addressTypeFk: AppEntity;
    addressFk: AppAddress;
    entityFk: AppEntity;
    id: number;

    [key: string]: any;
}

export class AppEntityExtraData implements IAppEntityExtraData {
    entityId!: number;
    entityFk!: AppEntity;
    entityCode!: string | undefined;
    entityObjectTypeId!: number | undefined;
    entityObjectTypeFk!: SycEntityObjectType;
    entityObjectTypeCode!: string | undefined;
    entityObjectTypeName!: string | undefined;
    attributeId!: number;
    attributeCode!: string | undefined;
    attributeValueId!: number | undefined;
    attributeValueFk!: AppEntity;
    attributeValue!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityExtraData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.entityCode = _data["entityCode"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeFk = _data["entityObjectTypeFk"] ? SycEntityObjectType.fromJS(_data["entityObjectTypeFk"]) : <any>undefined;
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.entityObjectTypeName = _data["entityObjectTypeName"];
            this.attributeId = _data["attributeId"];
            this.attributeCode = _data["attributeCode"];
            this.attributeValueId = _data["attributeValueId"];
            this.attributeValueFk = _data["attributeValueFk"] ? AppEntity.fromJS(_data["attributeValueFk"]) : <any>undefined;
            this.attributeValue = _data["attributeValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityExtraData {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityExtraData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["entityCode"] = this.entityCode;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeFk"] = this.entityObjectTypeFk ? this.entityObjectTypeFk.toJSON() : <any>undefined;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["entityObjectTypeName"] = this.entityObjectTypeName;
        data["attributeId"] = this.attributeId;
        data["attributeCode"] = this.attributeCode;
        data["attributeValueId"] = this.attributeValueId;
        data["attributeValueFk"] = this.attributeValueFk ? this.attributeValueFk.toJSON() : <any>undefined;
        data["attributeValue"] = this.attributeValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityExtraData {
    entityId: number;
    entityFk: AppEntity;
    entityCode: string | undefined;
    entityObjectTypeId: number | undefined;
    entityObjectTypeFk: SycEntityObjectType;
    entityObjectTypeCode: string | undefined;
    entityObjectTypeName: string | undefined;
    attributeId: number;
    attributeCode: string | undefined;
    attributeValueId: number | undefined;
    attributeValueFk: AppEntity;
    attributeValue: string | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntitiesRelationship implements IAppEntitiesRelationship {
    entityId!: number;
    entityFk!: AppEntity;
    entityCode!: string | undefined;
    entityTypeCode!: string | undefined;
    entityTable!: string | undefined;
    tenantId!: number | undefined;
    contactId!: number | undefined;
    contactFk!: AppContact;
    relatedEntityId!: number;
    relatedEntityFk!: AppEntity;
    relatedEntityCode!: string | undefined;
    relatedEntityTypeCode!: string | undefined;
    relatedEntityTable!: string | undefined;
    relatedTenantId!: number | undefined;
    relatedContactId!: number | undefined;
    relatedContactFk!: AppContact;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntitiesRelationship) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.entityCode = _data["entityCode"];
            this.entityTypeCode = _data["entityTypeCode"];
            this.entityTable = _data["entityTable"];
            this.tenantId = _data["tenantId"];
            this.contactId = _data["contactId"];
            this.contactFk = _data["contactFk"] ? AppContact.fromJS(_data["contactFk"]) : <any>undefined;
            this.relatedEntityId = _data["relatedEntityId"];
            this.relatedEntityFk = _data["relatedEntityFk"] ? AppEntity.fromJS(_data["relatedEntityFk"]) : <any>undefined;
            this.relatedEntityCode = _data["relatedEntityCode"];
            this.relatedEntityTypeCode = _data["relatedEntityTypeCode"];
            this.relatedEntityTable = _data["relatedEntityTable"];
            this.relatedTenantId = _data["relatedTenantId"];
            this.relatedContactId = _data["relatedContactId"];
            this.relatedContactFk = _data["relatedContactFk"] ? AppContact.fromJS(_data["relatedContactFk"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntitiesRelationship {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntitiesRelationship();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["entityCode"] = this.entityCode;
        data["entityTypeCode"] = this.entityTypeCode;
        data["entityTable"] = this.entityTable;
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["contactFk"] = this.contactFk ? this.contactFk.toJSON() : <any>undefined;
        data["relatedEntityId"] = this.relatedEntityId;
        data["relatedEntityFk"] = this.relatedEntityFk ? this.relatedEntityFk.toJSON() : <any>undefined;
        data["relatedEntityCode"] = this.relatedEntityCode;
        data["relatedEntityTypeCode"] = this.relatedEntityTypeCode;
        data["relatedEntityTable"] = this.relatedEntityTable;
        data["relatedTenantId"] = this.relatedTenantId;
        data["relatedContactId"] = this.relatedContactId;
        data["relatedContactFk"] = this.relatedContactFk ? this.relatedContactFk.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntitiesRelationship {
    entityId: number;
    entityFk: AppEntity;
    entityCode: string | undefined;
    entityTypeCode: string | undefined;
    entityTable: string | undefined;
    tenantId: number | undefined;
    contactId: number | undefined;
    contactFk: AppContact;
    relatedEntityId: number;
    relatedEntityFk: AppEntity;
    relatedEntityCode: string | undefined;
    relatedEntityTypeCode: string | undefined;
    relatedEntityTable: string | undefined;
    relatedTenantId: number | undefined;
    relatedContactId: number | undefined;
    relatedContactFk: AppContact;
    id: number;

    [key: string]: any;
}

export class AppEntityReactionsCount implements IAppEntityReactionsCount {
    entityId!: number;
    entityFk!: AppEntity;
    reactionsCount!: number;
    entityCommentsCount!: number;
    viewersCount!: number;
    likeCount!: number;
    celebrateCount!: number;
    loverCount!: number;
    insightfulCount!: number;
    curiousCount!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityReactionsCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.reactionsCount = _data["reactionsCount"];
            this.entityCommentsCount = _data["entityCommentsCount"];
            this.viewersCount = _data["viewersCount"];
            this.likeCount = _data["likeCount"];
            this.celebrateCount = _data["celebrateCount"];
            this.loverCount = _data["loverCount"];
            this.insightfulCount = _data["insightfulCount"];
            this.curiousCount = _data["curiousCount"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityReactionsCount {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityReactionsCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["reactionsCount"] = this.reactionsCount;
        data["entityCommentsCount"] = this.entityCommentsCount;
        data["viewersCount"] = this.viewersCount;
        data["likeCount"] = this.likeCount;
        data["celebrateCount"] = this.celebrateCount;
        data["loverCount"] = this.loverCount;
        data["insightfulCount"] = this.insightfulCount;
        data["curiousCount"] = this.curiousCount;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityReactionsCount {
    entityId: number;
    entityFk: AppEntity;
    reactionsCount: number;
    entityCommentsCount: number;
    viewersCount: number;
    likeCount: number;
    celebrateCount: number;
    loverCount: number;
    insightfulCount: number;
    curiousCount: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntity implements IAppEntity {
    tenantId!: number | undefined;
    name!: string;
    code!: string | undefined;
    notes!: string | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeFk!: SycEntityObjectType;
    entityObjectTypeCode!: string | undefined;
    entityObjectStatusId!: number | undefined;
    entityObjectStatusFk!: SycEntityObjectStatus;
    entityObjectStatusCode!: string | undefined;
    objectId!: number;
    objectFk!: SydObject;
    objectCode!: string | undefined;
    entityCategories!: AppEntityCategory[] | undefined;
    entityClassifications!: AppEntityClassification[] | undefined;
    entityAttachments!: AppEntityAttachment[] | undefined;
    entityAddresses!: AppEntityAddress[] | undefined;
    entityExtraData!: AppEntityExtraData[] | undefined;
    entitiesRelationships!: AppEntitiesRelationship[] | undefined;
    relatedEntitiesRelationships!: AppEntitiesRelationship[] | undefined;
    appEntityReactionsCount!: AppEntityReactionsCount;
    tenantOwner!: number;
    ssin!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.notes = _data["notes"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeFk = _data["entityObjectTypeFk"] ? SycEntityObjectType.fromJS(_data["entityObjectTypeFk"]) : <any>undefined;
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.entityObjectStatusId = _data["entityObjectStatusId"];
            this.entityObjectStatusFk = _data["entityObjectStatusFk"] ? SycEntityObjectStatus.fromJS(_data["entityObjectStatusFk"]) : <any>undefined;
            this.entityObjectStatusCode = _data["entityObjectStatusCode"];
            this.objectId = _data["objectId"];
            this.objectFk = _data["objectFk"] ? SydObject.fromJS(_data["objectFk"]) : <any>undefined;
            this.objectCode = _data["objectCode"];
            if (Array.isArray(_data["entityCategories"])) {
                this.entityCategories = [] as any;
                for (let item of _data["entityCategories"])
                    this.entityCategories!.push(AppEntityCategory.fromJS(item));
            }
            if (Array.isArray(_data["entityClassifications"])) {
                this.entityClassifications = [] as any;
                for (let item of _data["entityClassifications"])
                    this.entityClassifications!.push(AppEntityClassification.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachment.fromJS(item));
            }
            if (Array.isArray(_data["entityAddresses"])) {
                this.entityAddresses = [] as any;
                for (let item of _data["entityAddresses"])
                    this.entityAddresses!.push(AppEntityAddress.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraData.fromJS(item));
            }
            if (Array.isArray(_data["entitiesRelationships"])) {
                this.entitiesRelationships = [] as any;
                for (let item of _data["entitiesRelationships"])
                    this.entitiesRelationships!.push(AppEntitiesRelationship.fromJS(item));
            }
            if (Array.isArray(_data["relatedEntitiesRelationships"])) {
                this.relatedEntitiesRelationships = [] as any;
                for (let item of _data["relatedEntitiesRelationships"])
                    this.relatedEntitiesRelationships!.push(AppEntitiesRelationship.fromJS(item));
            }
            this.appEntityReactionsCount = _data["appEntityReactionsCount"] ? AppEntityReactionsCount.fromJS(_data["appEntityReactionsCount"]) : <any>undefined;
            this.tenantOwner = _data["tenantOwner"];
            this.ssin = _data["ssin"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["notes"] = this.notes;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeFk"] = this.entityObjectTypeFk ? this.entityObjectTypeFk.toJSON() : <any>undefined;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["entityObjectStatusId"] = this.entityObjectStatusId;
        data["entityObjectStatusFk"] = this.entityObjectStatusFk ? this.entityObjectStatusFk.toJSON() : <any>undefined;
        data["entityObjectStatusCode"] = this.entityObjectStatusCode;
        data["objectId"] = this.objectId;
        data["objectFk"] = this.objectFk ? this.objectFk.toJSON() : <any>undefined;
        data["objectCode"] = this.objectCode;
        if (Array.isArray(this.entityCategories)) {
            data["entityCategories"] = [];
            for (let item of this.entityCategories)
                data["entityCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassifications)) {
            data["entityClassifications"] = [];
            for (let item of this.entityClassifications)
                data["entityClassifications"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAddresses)) {
            data["entityAddresses"] = [];
            for (let item of this.entityAddresses)
                data["entityAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.entitiesRelationships)) {
            data["entitiesRelationships"] = [];
            for (let item of this.entitiesRelationships)
                data["entitiesRelationships"].push(item.toJSON());
        }
        if (Array.isArray(this.relatedEntitiesRelationships)) {
            data["relatedEntitiesRelationships"] = [];
            for (let item of this.relatedEntitiesRelationships)
                data["relatedEntitiesRelationships"].push(item.toJSON());
        }
        data["appEntityReactionsCount"] = this.appEntityReactionsCount ? this.appEntityReactionsCount.toJSON() : <any>undefined;
        data["tenantOwner"] = this.tenantOwner;
        data["ssin"] = this.ssin;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntity {
    tenantId: number | undefined;
    name: string;
    code: string | undefined;
    notes: string | undefined;
    entityObjectTypeId: number;
    entityObjectTypeFk: SycEntityObjectType;
    entityObjectTypeCode: string | undefined;
    entityObjectStatusId: number | undefined;
    entityObjectStatusFk: SycEntityObjectStatus;
    entityObjectStatusCode: string | undefined;
    objectId: number;
    objectFk: SydObject;
    objectCode: string | undefined;
    entityCategories: AppEntityCategory[] | undefined;
    entityClassifications: AppEntityClassification[] | undefined;
    entityAttachments: AppEntityAttachment[] | undefined;
    entityAddresses: AppEntityAddress[] | undefined;
    entityExtraData: AppEntityExtraData[] | undefined;
    entitiesRelationships: AppEntitiesRelationship[] | undefined;
    relatedEntitiesRelationships: AppEntitiesRelationship[] | undefined;
    appEntityReactionsCount: AppEntityReactionsCount;
    tenantOwner: number;
    ssin: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppContactAddress implements IAppContactAddress {
    contactId!: number;
    contactCode!: string | undefined;
    addressTypeId!: number;
    addressTypeCode!: string | undefined;
    addressId!: number;
    addressCode!: string | undefined;
    addressTypeFk!: AppEntity;
    addressFk!: AppAddress;
    contactFk!: AppContact;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppContactAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contactId = _data["contactId"];
            this.contactCode = _data["contactCode"];
            this.addressTypeId = _data["addressTypeId"];
            this.addressTypeCode = _data["addressTypeCode"];
            this.addressId = _data["addressId"];
            this.addressCode = _data["addressCode"];
            this.addressTypeFk = _data["addressTypeFk"] ? AppEntity.fromJS(_data["addressTypeFk"]) : <any>undefined;
            this.addressFk = _data["addressFk"] ? AppAddress.fromJS(_data["addressFk"]) : <any>undefined;
            this.contactFk = _data["contactFk"] ? AppContact.fromJS(_data["contactFk"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppContactAddress {
        data = typeof data === 'object' ? data : {};
        let result = new AppContactAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contactId"] = this.contactId;
        data["contactCode"] = this.contactCode;
        data["addressTypeId"] = this.addressTypeId;
        data["addressTypeCode"] = this.addressTypeCode;
        data["addressId"] = this.addressId;
        data["addressCode"] = this.addressCode;
        data["addressTypeFk"] = this.addressTypeFk ? this.addressTypeFk.toJSON() : <any>undefined;
        data["addressFk"] = this.addressFk ? this.addressFk.toJSON() : <any>undefined;
        data["contactFk"] = this.contactFk ? this.contactFk.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppContactAddress {
    contactId: number;
    contactCode: string | undefined;
    addressTypeId: number;
    addressTypeCode: string | undefined;
    addressId: number;
    addressCode: string | undefined;
    addressTypeFk: AppEntity;
    addressFk: AppAddress;
    contactFk: AppContact;
    id: number;

    [key: string]: any;
}

export class AppContactPaymentMethod implements IAppContactPaymentMethod {
    tenantId!: number;
    contactId!: number;
    contactCode!: string | undefined;
    description!: string | undefined;
    paymentType!: number;
    isDefault!: boolean;
    cardNumber!: string | undefined;
    cardType!: number;
    cardHolderName!: string | undefined;
    cardExpirationMonth!: string | undefined;
    cardExpirationYear!: string | undefined;
    cardProfileToken!: string | undefined;
    cardPaymentToken!: string | undefined;
    contactFk!: AppContact;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppContactPaymentMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.contactId = _data["contactId"];
            this.contactCode = _data["contactCode"];
            this.description = _data["description"];
            this.paymentType = _data["paymentType"];
            this.isDefault = _data["isDefault"];
            this.cardNumber = _data["cardNumber"];
            this.cardType = _data["cardType"];
            this.cardHolderName = _data["cardHolderName"];
            this.cardExpirationMonth = _data["cardExpirationMonth"];
            this.cardExpirationYear = _data["cardExpirationYear"];
            this.cardProfileToken = _data["cardProfileToken"];
            this.cardPaymentToken = _data["cardPaymentToken"];
            this.contactFk = _data["contactFk"] ? AppContact.fromJS(_data["contactFk"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppContactPaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new AppContactPaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["contactCode"] = this.contactCode;
        data["description"] = this.description;
        data["paymentType"] = this.paymentType;
        data["isDefault"] = this.isDefault;
        data["cardNumber"] = this.cardNumber;
        data["cardType"] = this.cardType;
        data["cardHolderName"] = this.cardHolderName;
        data["cardExpirationMonth"] = this.cardExpirationMonth;
        data["cardExpirationYear"] = this.cardExpirationYear;
        data["cardProfileToken"] = this.cardProfileToken;
        data["cardPaymentToken"] = this.cardPaymentToken;
        data["contactFk"] = this.contactFk ? this.contactFk.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppContactPaymentMethod {
    tenantId: number;
    contactId: number;
    contactCode: string | undefined;
    description: string | undefined;
    paymentType: number;
    isDefault: boolean;
    cardNumber: string | undefined;
    cardType: number;
    cardHolderName: string | undefined;
    cardExpirationMonth: string | undefined;
    cardExpirationYear: string | undefined;
    cardProfileToken: string | undefined;
    cardPaymentToken: string | undefined;
    contactFk: AppContact;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppContact implements IAppContact {
    tenantId!: number | undefined;
    name!: string;
    tradeName!: string;
    code!: string | undefined;
    languageId!: number | undefined;
    languageCode!: string | undefined;
    currencyId!: number | undefined;
    currencyCode!: string | undefined;
    eMailAddress!: string | undefined;
    website!: string | undefined;
    entityId!: number;
    entityCode!: string | undefined;
    parentId!: number | undefined;
    parentCode!: string | undefined;
    partnerId!: number | undefined;
    partnerCode!: string | undefined;
    accountType!: string | undefined;
    accountTypeId!: number;
    ssin!: string | undefined;
    priceLevel!: string | undefined;
    isProfileData!: boolean;
    phone1TypeId!: number | undefined;
    phone1TypeName!: string | undefined;
    phone1CountryKey!: string | undefined;
    phone1Number!: string | undefined;
    phone1Ext!: string | undefined;
    phone2TypeId!: number | undefined;
    phone2TypeName!: string | undefined;
    phone2CountryKey!: string | undefined;
    phone2Number!: string | undefined;
    phone2Ext!: string | undefined;
    phone3TypeId!: number | undefined;
    phone3TypeName!: string | undefined;
    phone3CountryKey!: string | undefined;
    phone3Number!: string | undefined;
    phone3Ext!: string | undefined;
    languageFk!: AppEntity;
    currencyFk!: AppEntity;
    entityFk!: AppEntity;
    parentFk!: AppContact;
    partnerFk!: AppContact;
    phone1TypeFk!: AppEntity;
    phone2TypeFk!: AppEntity;
    phone3TypeFk!: AppEntity;
    accountId!: number | undefined;
    accountFk!: AppContact;
    parentFkList!: AppContact[] | undefined;
    partnerFkList!: AppContact[] | undefined;
    appContactAddresses!: AppContactAddress[] | undefined;
    appContactPaymentMethods!: AppContactPaymentMethod[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.tradeName = _data["tradeName"];
            this.code = _data["code"];
            this.languageId = _data["languageId"];
            this.languageCode = _data["languageCode"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.eMailAddress = _data["eMailAddress"];
            this.website = _data["website"];
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.parentId = _data["parentId"];
            this.parentCode = _data["parentCode"];
            this.partnerId = _data["partnerId"];
            this.partnerCode = _data["partnerCode"];
            this.accountType = _data["accountType"];
            this.accountTypeId = _data["accountTypeId"];
            this.ssin = _data["ssin"];
            this.priceLevel = _data["priceLevel"];
            this.isProfileData = _data["isProfileData"];
            this.phone1TypeId = _data["phone1TypeId"];
            this.phone1TypeName = _data["phone1TypeName"];
            this.phone1CountryKey = _data["phone1CountryKey"];
            this.phone1Number = _data["phone1Number"];
            this.phone1Ext = _data["phone1Ext"];
            this.phone2TypeId = _data["phone2TypeId"];
            this.phone2TypeName = _data["phone2TypeName"];
            this.phone2CountryKey = _data["phone2CountryKey"];
            this.phone2Number = _data["phone2Number"];
            this.phone2Ext = _data["phone2Ext"];
            this.phone3TypeId = _data["phone3TypeId"];
            this.phone3TypeName = _data["phone3TypeName"];
            this.phone3CountryKey = _data["phone3CountryKey"];
            this.phone3Number = _data["phone3Number"];
            this.phone3Ext = _data["phone3Ext"];
            this.languageFk = _data["languageFk"] ? AppEntity.fromJS(_data["languageFk"]) : <any>undefined;
            this.currencyFk = _data["currencyFk"] ? AppEntity.fromJS(_data["currencyFk"]) : <any>undefined;
            this.entityFk = _data["entityFk"] ? AppEntity.fromJS(_data["entityFk"]) : <any>undefined;
            this.parentFk = _data["parentFk"] ? AppContact.fromJS(_data["parentFk"]) : <any>undefined;
            this.partnerFk = _data["partnerFk"] ? AppContact.fromJS(_data["partnerFk"]) : <any>undefined;
            this.phone1TypeFk = _data["phone1TypeFk"] ? AppEntity.fromJS(_data["phone1TypeFk"]) : <any>undefined;
            this.phone2TypeFk = _data["phone2TypeFk"] ? AppEntity.fromJS(_data["phone2TypeFk"]) : <any>undefined;
            this.phone3TypeFk = _data["phone3TypeFk"] ? AppEntity.fromJS(_data["phone3TypeFk"]) : <any>undefined;
            this.accountId = _data["accountId"];
            this.accountFk = _data["accountFk"] ? AppContact.fromJS(_data["accountFk"]) : <any>undefined;
            if (Array.isArray(_data["parentFkList"])) {
                this.parentFkList = [] as any;
                for (let item of _data["parentFkList"])
                    this.parentFkList!.push(AppContact.fromJS(item));
            }
            if (Array.isArray(_data["partnerFkList"])) {
                this.partnerFkList = [] as any;
                for (let item of _data["partnerFkList"])
                    this.partnerFkList!.push(AppContact.fromJS(item));
            }
            if (Array.isArray(_data["appContactAddresses"])) {
                this.appContactAddresses = [] as any;
                for (let item of _data["appContactAddresses"])
                    this.appContactAddresses!.push(AppContactAddress.fromJS(item));
            }
            if (Array.isArray(_data["appContactPaymentMethods"])) {
                this.appContactPaymentMethods = [] as any;
                for (let item of _data["appContactPaymentMethods"])
                    this.appContactPaymentMethods!.push(AppContactPaymentMethod.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppContact {
        data = typeof data === 'object' ? data : {};
        let result = new AppContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["tradeName"] = this.tradeName;
        data["code"] = this.code;
        data["languageId"] = this.languageId;
        data["languageCode"] = this.languageCode;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["eMailAddress"] = this.eMailAddress;
        data["website"] = this.website;
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["parentId"] = this.parentId;
        data["parentCode"] = this.parentCode;
        data["partnerId"] = this.partnerId;
        data["partnerCode"] = this.partnerCode;
        data["accountType"] = this.accountType;
        data["accountTypeId"] = this.accountTypeId;
        data["ssin"] = this.ssin;
        data["priceLevel"] = this.priceLevel;
        data["isProfileData"] = this.isProfileData;
        data["phone1TypeId"] = this.phone1TypeId;
        data["phone1TypeName"] = this.phone1TypeName;
        data["phone1CountryKey"] = this.phone1CountryKey;
        data["phone1Number"] = this.phone1Number;
        data["phone1Ext"] = this.phone1Ext;
        data["phone2TypeId"] = this.phone2TypeId;
        data["phone2TypeName"] = this.phone2TypeName;
        data["phone2CountryKey"] = this.phone2CountryKey;
        data["phone2Number"] = this.phone2Number;
        data["phone2Ext"] = this.phone2Ext;
        data["phone3TypeId"] = this.phone3TypeId;
        data["phone3TypeName"] = this.phone3TypeName;
        data["phone3CountryKey"] = this.phone3CountryKey;
        data["phone3Number"] = this.phone3Number;
        data["phone3Ext"] = this.phone3Ext;
        data["languageFk"] = this.languageFk ? this.languageFk.toJSON() : <any>undefined;
        data["currencyFk"] = this.currencyFk ? this.currencyFk.toJSON() : <any>undefined;
        data["entityFk"] = this.entityFk ? this.entityFk.toJSON() : <any>undefined;
        data["parentFk"] = this.parentFk ? this.parentFk.toJSON() : <any>undefined;
        data["partnerFk"] = this.partnerFk ? this.partnerFk.toJSON() : <any>undefined;
        data["phone1TypeFk"] = this.phone1TypeFk ? this.phone1TypeFk.toJSON() : <any>undefined;
        data["phone2TypeFk"] = this.phone2TypeFk ? this.phone2TypeFk.toJSON() : <any>undefined;
        data["phone3TypeFk"] = this.phone3TypeFk ? this.phone3TypeFk.toJSON() : <any>undefined;
        data["accountId"] = this.accountId;
        data["accountFk"] = this.accountFk ? this.accountFk.toJSON() : <any>undefined;
        if (Array.isArray(this.parentFkList)) {
            data["parentFkList"] = [];
            for (let item of this.parentFkList)
                data["parentFkList"].push(item.toJSON());
        }
        if (Array.isArray(this.partnerFkList)) {
            data["partnerFkList"] = [];
            for (let item of this.partnerFkList)
                data["partnerFkList"].push(item.toJSON());
        }
        if (Array.isArray(this.appContactAddresses)) {
            data["appContactAddresses"] = [];
            for (let item of this.appContactAddresses)
                data["appContactAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.appContactPaymentMethods)) {
            data["appContactPaymentMethods"] = [];
            for (let item of this.appContactPaymentMethods)
                data["appContactPaymentMethods"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppContact {
    tenantId: number | undefined;
    name: string;
    tradeName: string;
    code: string | undefined;
    languageId: number | undefined;
    languageCode: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    eMailAddress: string | undefined;
    website: string | undefined;
    entityId: number;
    entityCode: string | undefined;
    parentId: number | undefined;
    parentCode: string | undefined;
    partnerId: number | undefined;
    partnerCode: string | undefined;
    accountType: string | undefined;
    accountTypeId: number;
    ssin: string | undefined;
    priceLevel: string | undefined;
    isProfileData: boolean;
    phone1TypeId: number | undefined;
    phone1TypeName: string | undefined;
    phone1CountryKey: string | undefined;
    phone1Number: string | undefined;
    phone1Ext: string | undefined;
    phone2TypeId: number | undefined;
    phone2TypeName: string | undefined;
    phone2CountryKey: string | undefined;
    phone2Number: string | undefined;
    phone2Ext: string | undefined;
    phone3TypeId: number | undefined;
    phone3TypeName: string | undefined;
    phone3CountryKey: string | undefined;
    phone3Number: string | undefined;
    phone3Ext: string | undefined;
    languageFk: AppEntity;
    currencyFk: AppEntity;
    entityFk: AppEntity;
    parentFk: AppContact;
    partnerFk: AppContact;
    phone1TypeFk: AppEntity;
    phone2TypeFk: AppEntity;
    phone3TypeFk: AppEntity;
    accountId: number | undefined;
    accountFk: AppContact;
    parentFkList: AppContact[] | undefined;
    partnerFkList: AppContact[] | undefined;
    appContactAddresses: AppContactAddress[] | undefined;
    appContactPaymentMethods: AppContactPaymentMethod[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export enum OccuranceUnitOfTime {
    Hour = 0,
    Day = 1,
    Week = 2,
    Month = 3,
}

export class AppAdvertisementDto implements IAppAdvertisementDto {
    code!: string | undefined;
    tenantId!: number | undefined;
    description!: string | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    startTime!: string | undefined;
    endTime!: string | undefined;
    timeZone!: string | undefined;
    publishOnHomePage!: boolean;
    publishOnMarketLandingPage!: boolean;
    approvalDateTime!: moment.Moment;
    paymentMethod!: string | undefined;
    invoiceNumber!: number;
    numberOfOccurences!: number;
    periodOfView!: number;
    appEntityId!: number;
    userId!: number | undefined;
    marketPlaceImage!: string | undefined;
    homeImage!: string | undefined;
    occuranceUnitOfTime!: OccuranceUnitOfTime;
    url!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppAdvertisementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.tenantId = _data["tenantId"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.timeZone = _data["timeZone"];
            this.publishOnHomePage = _data["publishOnHomePage"];
            this.publishOnMarketLandingPage = _data["publishOnMarketLandingPage"];
            this.approvalDateTime = _data["approvalDateTime"] ? moment(_data["approvalDateTime"].toString()) : <any>undefined;
            this.paymentMethod = _data["paymentMethod"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.numberOfOccurences = _data["numberOfOccurences"];
            this.periodOfView = _data["periodOfView"];
            this.appEntityId = _data["appEntityId"];
            this.userId = _data["userId"];
            this.marketPlaceImage = _data["marketPlaceImage"];
            this.homeImage = _data["homeImage"];
            this.occuranceUnitOfTime = _data["occuranceUnitOfTime"];
            this.url = _data["url"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppAdvertisementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppAdvertisementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["tenantId"] = this.tenantId;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["timeZone"] = this.timeZone;
        data["publishOnHomePage"] = this.publishOnHomePage;
        data["publishOnMarketLandingPage"] = this.publishOnMarketLandingPage;
        data["approvalDateTime"] = this.approvalDateTime ? this.approvalDateTime.toISOString() : <any>undefined;
        data["paymentMethod"] = this.paymentMethod;
        data["invoiceNumber"] = this.invoiceNumber;
        data["numberOfOccurences"] = this.numberOfOccurences;
        data["periodOfView"] = this.periodOfView;
        data["appEntityId"] = this.appEntityId;
        data["userId"] = this.userId;
        data["marketPlaceImage"] = this.marketPlaceImage;
        data["homeImage"] = this.homeImage;
        data["occuranceUnitOfTime"] = this.occuranceUnitOfTime;
        data["url"] = this.url;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppAdvertisementDto {
    code: string | undefined;
    tenantId: number | undefined;
    description: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    startTime: string | undefined;
    endTime: string | undefined;
    timeZone: string | undefined;
    publishOnHomePage: boolean;
    publishOnMarketLandingPage: boolean;
    approvalDateTime: moment.Moment;
    paymentMethod: string | undefined;
    invoiceNumber: number;
    numberOfOccurences: number;
    periodOfView: number;
    appEntityId: number;
    userId: number | undefined;
    marketPlaceImage: string | undefined;
    homeImage: string | undefined;
    occuranceUnitOfTime: OccuranceUnitOfTime;
    url: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppAdvertisementForViewDto implements IGetAppAdvertisementForViewDto {
    appAdvertisement!: AppAdvertisementDto;
    appEntityName!: string | undefined;
    userName!: string | undefined;
    tenantName!: string | undefined;
    accountId!: number;
    url!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppAdvertisementForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appAdvertisement = _data["appAdvertisement"] ? AppAdvertisementDto.fromJS(_data["appAdvertisement"]) : <any>undefined;
            this.appEntityName = _data["appEntityName"];
            this.userName = _data["userName"];
            this.tenantName = _data["tenantName"];
            this.accountId = _data["accountId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): GetAppAdvertisementForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppAdvertisementForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appAdvertisement"] = this.appAdvertisement ? this.appAdvertisement.toJSON() : <any>undefined;
        data["appEntityName"] = this.appEntityName;
        data["userName"] = this.userName;
        data["tenantName"] = this.tenantName;
        data["accountId"] = this.accountId;
        data["url"] = this.url;
        return data;
    }
}

export interface IGetAppAdvertisementForViewDto {
    appAdvertisement: AppAdvertisementDto;
    appEntityName: string | undefined;
    userName: string | undefined;
    tenantName: string | undefined;
    accountId: number;
    url: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppAdvertisementForViewDto implements IPagedResultDtoOfGetAppAdvertisementForViewDto {
    totalCount!: number;
    items!: GetAppAdvertisementForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppAdvertisementForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppAdvertisementForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppAdvertisementForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppAdvertisementForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppAdvertisementForViewDto {
    totalCount: number;
    items: GetAppAdvertisementForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppAdvertisementDto implements ICreateOrEditAppAdvertisementDto {
    code!: string;
    tenantId!: number | undefined;
    description!: string | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    startTime!: string | undefined;
    endTime!: string | undefined;
    timeZone!: string | undefined;
    publishOnHomePage!: boolean;
    publishOnMarketLandingPage!: boolean;
    approvalDateTime!: moment.Moment;
    paymentMethod!: string | undefined;
    invoiceNumber!: number;
    utcFromDateTime!: moment.Moment;
    utcToDateTime!: moment.Moment;
    numberOfOccurences!: number;
    periodOfView!: number;
    appEntityId!: number;
    userId!: number | undefined;
    attachments!: AppEntityAttachmentDto[] | undefined;
    occuranceUnitOfTime!: OccuranceUnitOfTime;
    url!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppAdvertisementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.tenantId = _data["tenantId"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.timeZone = _data["timeZone"];
            this.publishOnHomePage = _data["publishOnHomePage"];
            this.publishOnMarketLandingPage = _data["publishOnMarketLandingPage"];
            this.approvalDateTime = _data["approvalDateTime"] ? moment(_data["approvalDateTime"].toString()) : <any>undefined;
            this.paymentMethod = _data["paymentMethod"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.utcFromDateTime = _data["utcFromDateTime"] ? moment(_data["utcFromDateTime"].toString()) : <any>undefined;
            this.utcToDateTime = _data["utcToDateTime"] ? moment(_data["utcToDateTime"].toString()) : <any>undefined;
            this.numberOfOccurences = _data["numberOfOccurences"];
            this.periodOfView = _data["periodOfView"];
            this.appEntityId = _data["appEntityId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.occuranceUnitOfTime = _data["occuranceUnitOfTime"];
            this.url = _data["url"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppAdvertisementDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppAdvertisementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["tenantId"] = this.tenantId;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["timeZone"] = this.timeZone;
        data["publishOnHomePage"] = this.publishOnHomePage;
        data["publishOnMarketLandingPage"] = this.publishOnMarketLandingPage;
        data["approvalDateTime"] = this.approvalDateTime ? this.approvalDateTime.toISOString() : <any>undefined;
        data["paymentMethod"] = this.paymentMethod;
        data["invoiceNumber"] = this.invoiceNumber;
        data["utcFromDateTime"] = this.utcFromDateTime ? this.utcFromDateTime.toISOString() : <any>undefined;
        data["utcToDateTime"] = this.utcToDateTime ? this.utcToDateTime.toISOString() : <any>undefined;
        data["numberOfOccurences"] = this.numberOfOccurences;
        data["periodOfView"] = this.periodOfView;
        data["appEntityId"] = this.appEntityId;
        data["userId"] = this.userId;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["occuranceUnitOfTime"] = this.occuranceUnitOfTime;
        data["url"] = this.url;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppAdvertisementDto {
    code: string;
    tenantId: number | undefined;
    description: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    startTime: string | undefined;
    endTime: string | undefined;
    timeZone: string | undefined;
    publishOnHomePage: boolean;
    publishOnMarketLandingPage: boolean;
    approvalDateTime: moment.Moment;
    paymentMethod: string | undefined;
    invoiceNumber: number;
    utcFromDateTime: moment.Moment;
    utcToDateTime: moment.Moment;
    numberOfOccurences: number;
    periodOfView: number;
    appEntityId: number;
    userId: number | undefined;
    attachments: AppEntityAttachmentDto[] | undefined;
    occuranceUnitOfTime: OccuranceUnitOfTime;
    url: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppAdvertisementForEditOutput implements IGetAppAdvertisementForEditOutput {
    appAdvertisement!: CreateOrEditAppAdvertisementDto;
    appEntityName!: string | undefined;
    userName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppAdvertisementForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appAdvertisement = _data["appAdvertisement"] ? CreateOrEditAppAdvertisementDto.fromJS(_data["appAdvertisement"]) : <any>undefined;
            this.appEntityName = _data["appEntityName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): GetAppAdvertisementForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppAdvertisementForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appAdvertisement"] = this.appAdvertisement ? this.appAdvertisement.toJSON() : <any>undefined;
        data["appEntityName"] = this.appEntityName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IGetAppAdvertisementForEditOutput {
    appAdvertisement: CreateOrEditAppAdvertisementDto;
    appEntityName: string | undefined;
    userName: string | undefined;

    [key: string]: any;
}

export class AppAdvertisementAppEntityLookupTableDto implements IAppAdvertisementAppEntityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppAdvertisementAppEntityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppAdvertisementAppEntityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppAdvertisementAppEntityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppAdvertisementAppEntityLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto implements IPagedResultDtoOfAppAdvertisementAppEntityLookupTableDto {
    totalCount!: number;
    items!: AppAdvertisementAppEntityLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppAdvertisementAppEntityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppAdvertisementAppEntityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppAdvertisementAppEntityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppAdvertisementAppEntityLookupTableDto {
    totalCount: number;
    items: AppAdvertisementAppEntityLookupTableDto[] | undefined;

    [key: string]: any;
}

export class AppAdvertisementUserLookupTableDto implements IAppAdvertisementUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppAdvertisementUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppAdvertisementUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppAdvertisementUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppAdvertisementUserLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfAppAdvertisementUserLookupTableDto implements IPagedResultDtoOfAppAdvertisementUserLookupTableDto {
    totalCount!: number;
    items!: AppAdvertisementUserLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppAdvertisementUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppAdvertisementUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppAdvertisementUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppAdvertisementUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppAdvertisementUserLookupTableDto {
    totalCount: number;
    items: AppAdvertisementUserLookupTableDto[] | undefined;

    [key: string]: any;
}

export class SelectItemDto implements ISelectItemDto {
    value!: string | undefined;
    label!: string | undefined;
    isHostRecord!: boolean | undefined;

    [key: string]: any;

    constructor(data?: ISelectItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.label = _data["label"];
            this.isHostRecord = _data["isHostRecord"];
        }
    }

    static fromJS(data: any): SelectItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["label"] = this.label;
        data["isHostRecord"] = this.isHostRecord;
        return data;
    }
}

export interface ISelectItemDto {
    value: string | undefined;
    label: string | undefined;
    isHostRecord: boolean | undefined;

    [key: string]: any;
}

export class AppEntityAddressDto implements IAppEntityAddressDto {
    entitytId!: number;
    addressTypeId!: number;
    addressTypeIdName!: string | undefined;
    addressId!: number;
    code!: string | undefined;
    name!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: number;
    countryIdName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entitytId = _data["entitytId"];
            this.addressTypeId = _data["addressTypeId"];
            this.addressTypeIdName = _data["addressTypeIdName"];
            this.addressId = _data["addressId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
            this.countryIdName = _data["countryIdName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entitytId"] = this.entitytId;
        data["addressTypeId"] = this.addressTypeId;
        data["addressTypeIdName"] = this.addressTypeIdName;
        data["addressId"] = this.addressId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        data["countryIdName"] = this.countryIdName;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityAddressDto {
    entitytId: number;
    addressTypeId: number;
    addressTypeIdName: string | undefined;
    addressId: number;
    code: string | undefined;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: number;
    countryIdName: string | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntityExtraDataDto implements IAppEntityExtraDataDto {
    entityId!: number;
    entityObjectTypeId!: number | undefined;
    entityObjectTypeCode!: string | undefined;
    entityObjectTypeName!: string | undefined;
    attributeValueId!: number | undefined;
    attributeValue!: string | undefined;
    attributeId!: number;
    attributeValueFkName!: string | undefined;
    attributeValueFkCode!: string | undefined;
    attributeCode!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityExtraDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.entityObjectTypeName = _data["entityObjectTypeName"];
            this.attributeValueId = _data["attributeValueId"];
            this.attributeValue = _data["attributeValue"];
            this.attributeId = _data["attributeId"];
            this.attributeValueFkName = _data["attributeValueFkName"];
            this.attributeValueFkCode = _data["attributeValueFkCode"];
            this.attributeCode = _data["attributeCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityExtraDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityExtraDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["entityObjectTypeName"] = this.entityObjectTypeName;
        data["attributeValueId"] = this.attributeValueId;
        data["attributeValue"] = this.attributeValue;
        data["attributeId"] = this.attributeId;
        data["attributeValueFkName"] = this.attributeValueFkName;
        data["attributeValueFkCode"] = this.attributeValueFkCode;
        data["attributeCode"] = this.attributeCode;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityExtraDataDto {
    entityId: number;
    entityObjectTypeId: number | undefined;
    entityObjectTypeCode: string | undefined;
    entityObjectTypeName: string | undefined;
    attributeValueId: number | undefined;
    attributeValue: string | undefined;
    attributeId: number;
    attributeValueFkName: string | undefined;
    attributeValueFkCode: string | undefined;
    attributeCode: string | undefined;
    id: number;

    [key: string]: any;
}

export class AppEntitiesRelationshipDto implements IAppEntitiesRelationshipDto {
    entityId!: number;
    entityCode!: string | undefined;
    entityTypeCode!: string | undefined;
    entityTable!: string | undefined;
    tenantId!: number | undefined;
    contactId!: number | undefined;
    relatedEntityId!: number;
    relatedEntityCode!: string | undefined;
    relatedEntityTypeCode!: string | undefined;
    relatedEntityTable!: string | undefined;
    relatedTenantId!: number | undefined;
    relatedContactId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntitiesRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.entityTypeCode = _data["entityTypeCode"];
            this.entityTable = _data["entityTable"];
            this.tenantId = _data["tenantId"];
            this.contactId = _data["contactId"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.relatedEntityCode = _data["relatedEntityCode"];
            this.relatedEntityTypeCode = _data["relatedEntityTypeCode"];
            this.relatedEntityTable = _data["relatedEntityTable"];
            this.relatedTenantId = _data["relatedTenantId"];
            this.relatedContactId = _data["relatedContactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntitiesRelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntitiesRelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["entityTypeCode"] = this.entityTypeCode;
        data["entityTable"] = this.entityTable;
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["relatedEntityId"] = this.relatedEntityId;
        data["relatedEntityCode"] = this.relatedEntityCode;
        data["relatedEntityTypeCode"] = this.relatedEntityTypeCode;
        data["relatedEntityTable"] = this.relatedEntityTable;
        data["relatedTenantId"] = this.relatedTenantId;
        data["relatedContactId"] = this.relatedContactId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntitiesRelationshipDto {
    entityId: number;
    entityCode: string | undefined;
    entityTypeCode: string | undefined;
    entityTable: string | undefined;
    tenantId: number | undefined;
    contactId: number | undefined;
    relatedEntityId: number;
    relatedEntityCode: string | undefined;
    relatedEntityTypeCode: string | undefined;
    relatedEntityTable: string | undefined;
    relatedTenantId: number | undefined;
    relatedContactId: number | undefined;
    id: number;

    [key: string]: any;
}

export enum AppEntityTypes {
    EVENT = 0,
    POST = 1,
}

export class AppEntityDto implements IAppEntityDto {
    tenantId!: number | undefined;
    attachmentSourceTenantId!: number | undefined;
    name!: string | undefined;
    code!: string | undefined;
    notes!: string | undefined;
    isHostRecord!: boolean;
    addFromAttachments!: boolean;
    relatedEntityId!: number | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeCode!: string | undefined;
    entityObjectStatusId!: number | undefined;
    objectId!: number;
    entityAddresses!: AppEntityAddressDto[] | undefined;
    entityCategories!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    entitiesRelationships!: AppEntitiesRelationshipDto[] | undefined;
    relatedEntitiesRelationships!: AppEntitiesRelationshipDto[] | undefined;
    appEntityTypes!: AppEntityTypes;
    ssin!: string | undefined;
    tenantOwner!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.attachmentSourceTenantId = _data["attachmentSourceTenantId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.notes = _data["notes"];
            this.isHostRecord = _data["isHostRecord"];
            this.addFromAttachments = _data["addFromAttachments"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.entityObjectStatusId = _data["entityObjectStatusId"];
            this.objectId = _data["objectId"];
            if (Array.isArray(_data["entityAddresses"])) {
                this.entityAddresses = [] as any;
                for (let item of _data["entityAddresses"])
                    this.entityAddresses!.push(AppEntityAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategories"])) {
                this.entityCategories = [] as any;
                for (let item of _data["entityCategories"])
                    this.entityCategories!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassifications"])) {
                this.entityClassifications = [] as any;
                for (let item of _data["entityClassifications"])
                    this.entityClassifications!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["entitiesRelationships"])) {
                this.entitiesRelationships = [] as any;
                for (let item of _data["entitiesRelationships"])
                    this.entitiesRelationships!.push(AppEntitiesRelationshipDto.fromJS(item));
            }
            if (Array.isArray(_data["relatedEntitiesRelationships"])) {
                this.relatedEntitiesRelationships = [] as any;
                for (let item of _data["relatedEntitiesRelationships"])
                    this.relatedEntitiesRelationships!.push(AppEntitiesRelationshipDto.fromJS(item));
            }
            this.appEntityTypes = _data["appEntityTypes"];
            this.ssin = _data["ssin"];
            this.tenantOwner = _data["tenantOwner"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["attachmentSourceTenantId"] = this.attachmentSourceTenantId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["notes"] = this.notes;
        data["isHostRecord"] = this.isHostRecord;
        data["addFromAttachments"] = this.addFromAttachments;
        data["relatedEntityId"] = this.relatedEntityId;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["entityObjectStatusId"] = this.entityObjectStatusId;
        data["objectId"] = this.objectId;
        if (Array.isArray(this.entityAddresses)) {
            data["entityAddresses"] = [];
            for (let item of this.entityAddresses)
                data["entityAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategories)) {
            data["entityCategories"] = [];
            for (let item of this.entityCategories)
                data["entityCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassifications)) {
            data["entityClassifications"] = [];
            for (let item of this.entityClassifications)
                data["entityClassifications"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.entitiesRelationships)) {
            data["entitiesRelationships"] = [];
            for (let item of this.entitiesRelationships)
                data["entitiesRelationships"].push(item.toJSON());
        }
        if (Array.isArray(this.relatedEntitiesRelationships)) {
            data["relatedEntitiesRelationships"] = [];
            for (let item of this.relatedEntitiesRelationships)
                data["relatedEntitiesRelationships"].push(item.toJSON());
        }
        data["appEntityTypes"] = this.appEntityTypes;
        data["ssin"] = this.ssin;
        data["tenantOwner"] = this.tenantOwner;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityDto {
    tenantId: number | undefined;
    attachmentSourceTenantId: number | undefined;
    name: string | undefined;
    code: string | undefined;
    notes: string | undefined;
    isHostRecord: boolean;
    addFromAttachments: boolean;
    relatedEntityId: number | undefined;
    entityObjectTypeId: number;
    entityObjectTypeCode: string | undefined;
    entityObjectStatusId: number | undefined;
    objectId: number;
    entityAddresses: AppEntityAddressDto[] | undefined;
    entityCategories: AppEntityCategoryDto[] | undefined;
    entityClassifications: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    entitiesRelationships: AppEntitiesRelationshipDto[] | undefined;
    relatedEntitiesRelationships: AppEntitiesRelationshipDto[] | undefined;
    appEntityTypes: AppEntityTypes;
    ssin: string | undefined;
    tenantOwner: number;
    id: number;

    [key: string]: any;
}

export class GetAppEntityForViewDto implements IGetAppEntityForViewDto {
    appEntity!: AppEntityDto;
    sycEntityObjectTypeName!: string | undefined;
    sycEntityObjectStatusName!: string | undefined;
    sydObjectName!: string | undefined;
    isManual!: boolean;

    [key: string]: any;

    constructor(data?: IGetAppEntityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appEntity = _data["appEntity"] ? AppEntityDto.fromJS(_data["appEntity"]) : <any>undefined;
            this.sycEntityObjectTypeName = _data["sycEntityObjectTypeName"];
            this.sycEntityObjectStatusName = _data["sycEntityObjectStatusName"];
            this.sydObjectName = _data["sydObjectName"];
            this.isManual = _data["isManual"];
        }
    }

    static fromJS(data: any): GetAppEntityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppEntityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appEntity"] = this.appEntity ? this.appEntity.toJSON() : <any>undefined;
        data["sycEntityObjectTypeName"] = this.sycEntityObjectTypeName;
        data["sycEntityObjectStatusName"] = this.sycEntityObjectStatusName;
        data["sydObjectName"] = this.sydObjectName;
        data["isManual"] = this.isManual;
        return data;
    }
}

export interface IGetAppEntityForViewDto {
    appEntity: AppEntityDto;
    sycEntityObjectTypeName: string | undefined;
    sycEntityObjectStatusName: string | undefined;
    sydObjectName: string | undefined;
    isManual: boolean;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppEntityForViewDto implements IPagedResultDtoOfGetAppEntityForViewDto {
    totalCount!: number;
    items!: GetAppEntityForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppEntityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppEntityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppEntityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppEntityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppEntityForViewDto {
    totalCount: number;
    items: GetAppEntityForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppEntityDto implements ICreateOrEditAppEntityDto {
    name!: string;
    code!: string;
    notes!: string | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityObjectTypeId!: number;
    entityObjectStatusId!: number | undefined;
    objectId!: number;
    entityObjectTypeCode!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectStatusId = _data["entityObjectStatusId"];
            this.objectId = _data["objectId"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["notes"] = this.notes;
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectStatusId"] = this.entityObjectStatusId;
        data["objectId"] = this.objectId;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppEntityDto {
    name: string;
    code: string;
    notes: string | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityObjectTypeId: number;
    entityObjectStatusId: number | undefined;
    objectId: number;
    entityObjectTypeCode: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppEntityForEditOutput implements IGetAppEntityForEditOutput {
    appEntity!: CreateOrEditAppEntityDto;
    sycEntityObjectTypeName!: string | undefined;
    sycEntityObjectStatusName!: string | undefined;
    sydObjectName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppEntityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appEntity = _data["appEntity"] ? CreateOrEditAppEntityDto.fromJS(_data["appEntity"]) : <any>undefined;
            this.sycEntityObjectTypeName = _data["sycEntityObjectTypeName"];
            this.sycEntityObjectStatusName = _data["sycEntityObjectStatusName"];
            this.sydObjectName = _data["sydObjectName"];
        }
    }

    static fromJS(data: any): GetAppEntityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppEntityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appEntity"] = this.appEntity ? this.appEntity.toJSON() : <any>undefined;
        data["sycEntityObjectTypeName"] = this.sycEntityObjectTypeName;
        data["sycEntityObjectStatusName"] = this.sycEntityObjectStatusName;
        data["sydObjectName"] = this.sydObjectName;
        return data;
    }
}

export interface IGetAppEntityForEditOutput {
    appEntity: CreateOrEditAppEntityDto;
    sycEntityObjectTypeName: string | undefined;
    sycEntityObjectStatusName: string | undefined;
    sydObjectName: string | undefined;

    [key: string]: any;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    [key: string]: any;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;

    [key: string]: any;
}

export class AppEntitySycEntityObjectTypeLookupTableDto implements IAppEntitySycEntityObjectTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppEntitySycEntityObjectTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppEntitySycEntityObjectTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntitySycEntityObjectTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppEntitySycEntityObjectTypeLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AppEntitySycEntityObjectStatusLookupTableDto implements IAppEntitySycEntityObjectStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;
    code!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppEntitySycEntityObjectStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AppEntitySycEntityObjectStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntitySycEntityObjectStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        return data;
    }
}

export interface IAppEntitySycEntityObjectStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
    code: string | undefined;

    [key: string]: any;
}

export class AppEntitySydObjectLookupTableDto implements IAppEntitySydObjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppEntitySydObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppEntitySydObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntitySydObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppEntitySydObjectLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfLookupLabelDto implements IPagedResultDtoOfLookupLabelDto {
    totalCount!: number;
    items!: LookupLabelDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfLookupLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupLabelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLookupLabelDto {
    totalCount: number;
    items: LookupLabelDto[] | undefined;

    [key: string]: any;
}

export class LookupLabelWithAttachmentDto implements ILookupLabelWithAttachmentDto {
    attachmentName!: string | undefined;
    value!: number;
    label!: string | undefined;
    code!: string | undefined;
    stockAvailability!: number | undefined;
    isHostRecord!: boolean | undefined;

    [key: string]: any;

    constructor(data?: ILookupLabelWithAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.attachmentName = _data["attachmentName"];
            this.value = _data["value"];
            this.label = _data["label"];
            this.code = _data["code"];
            this.stockAvailability = _data["stockAvailability"];
            this.isHostRecord = _data["isHostRecord"];
        }
    }

    static fromJS(data: any): LookupLabelWithAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLabelWithAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["attachmentName"] = this.attachmentName;
        data["value"] = this.value;
        data["label"] = this.label;
        data["code"] = this.code;
        data["stockAvailability"] = this.stockAvailability;
        data["isHostRecord"] = this.isHostRecord;
        return data;
    }
}

export interface ILookupLabelWithAttachmentDto {
    attachmentName: string | undefined;
    value: number;
    label: string | undefined;
    code: string | undefined;
    stockAvailability: number | undefined;
    isHostRecord: boolean | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfLookupLabelWithAttachmentDto implements IPagedResultDtoOfLookupLabelWithAttachmentDto {
    totalCount!: number;
    items!: LookupLabelWithAttachmentDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfLookupLabelWithAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupLabelWithAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupLabelWithAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupLabelWithAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLookupLabelWithAttachmentDto {
    totalCount: number;
    items: LookupLabelWithAttachmentDto[] | undefined;

    [key: string]: any;
}

export class CurrencyInfoDto implements ICurrencyInfoDto {
    symbol!: string | undefined;
    value!: number;
    label!: string | undefined;
    code!: string | undefined;
    stockAvailability!: number | undefined;
    isHostRecord!: boolean | undefined;

    [key: string]: any;

    constructor(data?: ICurrencyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.symbol = _data["symbol"];
            this.value = _data["value"];
            this.label = _data["label"];
            this.code = _data["code"];
            this.stockAvailability = _data["stockAvailability"];
            this.isHostRecord = _data["isHostRecord"];
        }
    }

    static fromJS(data: any): CurrencyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["symbol"] = this.symbol;
        data["value"] = this.value;
        data["label"] = this.label;
        data["code"] = this.code;
        data["stockAvailability"] = this.stockAvailability;
        data["isHostRecord"] = this.isHostRecord;
        return data;
    }
}

export interface ICurrencyInfoDto {
    symbol: string | undefined;
    value: number;
    label: string | undefined;
    code: string | undefined;
    stockAvailability: number | undefined;
    isHostRecord: boolean | undefined;

    [key: string]: any;
}

export class AppContactDto implements IAppContactDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    tradeName!: string | undefined;
    code!: string | undefined;
    languageId!: number | undefined;
    languageCode!: string | undefined;
    currencyId!: number | undefined;
    currencyCode!: string | undefined;
    eMailAddress!: string | undefined;
    website!: string | undefined;
    entityId!: number;
    entityCode!: string | undefined;
    parentId!: number | undefined;
    parentCode!: string | undefined;
    partnerId!: number | undefined;
    partnerCode!: string | undefined;
    accountType!: string | undefined;
    accountTypeId!: number;
    ssin!: string | undefined;
    priceLevel!: string | undefined;
    isProfileData!: boolean;
    phone1TypeId!: number | undefined;
    phone1TypeName!: string | undefined;
    phone1Number!: string | undefined;
    phone1Ext!: string | undefined;
    phone2TypeId!: number | undefined;
    phone2TypeName!: string | undefined;
    phone2Number!: string | undefined;
    phone2Ext!: string | undefined;
    phone3TypeId!: number | undefined;
    phone3TypeName!: string | undefined;
    phone3Number!: string | undefined;
    phone3Ext!: string | undefined;
    accountId!: number | undefined;
    contactAddresses!: AppContactAddressDto[] | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.tradeName = _data["tradeName"];
            this.code = _data["code"];
            this.languageId = _data["languageId"];
            this.languageCode = _data["languageCode"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.eMailAddress = _data["eMailAddress"];
            this.website = _data["website"];
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.parentId = _data["parentId"];
            this.parentCode = _data["parentCode"];
            this.partnerId = _data["partnerId"];
            this.partnerCode = _data["partnerCode"];
            this.accountType = _data["accountType"];
            this.accountTypeId = _data["accountTypeId"];
            this.ssin = _data["ssin"];
            this.priceLevel = _data["priceLevel"];
            this.isProfileData = _data["isProfileData"];
            this.phone1TypeId = _data["phone1TypeId"];
            this.phone1TypeName = _data["phone1TypeName"];
            this.phone1Number = _data["phone1Number"];
            this.phone1Ext = _data["phone1Ext"];
            this.phone2TypeId = _data["phone2TypeId"];
            this.phone2TypeName = _data["phone2TypeName"];
            this.phone2Number = _data["phone2Number"];
            this.phone2Ext = _data["phone2Ext"];
            this.phone3TypeId = _data["phone3TypeId"];
            this.phone3TypeName = _data["phone3TypeName"];
            this.phone3Number = _data["phone3Number"];
            this.phone3Ext = _data["phone3Ext"];
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["contactAddresses"])) {
                this.contactAddresses = [] as any;
                for (let item of _data["contactAddresses"])
                    this.contactAddresses!.push(AppContactAddressDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["tradeName"] = this.tradeName;
        data["code"] = this.code;
        data["languageId"] = this.languageId;
        data["languageCode"] = this.languageCode;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["eMailAddress"] = this.eMailAddress;
        data["website"] = this.website;
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["parentId"] = this.parentId;
        data["parentCode"] = this.parentCode;
        data["partnerId"] = this.partnerId;
        data["partnerCode"] = this.partnerCode;
        data["accountType"] = this.accountType;
        data["accountTypeId"] = this.accountTypeId;
        data["ssin"] = this.ssin;
        data["priceLevel"] = this.priceLevel;
        data["isProfileData"] = this.isProfileData;
        data["phone1TypeId"] = this.phone1TypeId;
        data["phone1TypeName"] = this.phone1TypeName;
        data["phone1Number"] = this.phone1Number;
        data["phone1Ext"] = this.phone1Ext;
        data["phone2TypeId"] = this.phone2TypeId;
        data["phone2TypeName"] = this.phone2TypeName;
        data["phone2Number"] = this.phone2Number;
        data["phone2Ext"] = this.phone2Ext;
        data["phone3TypeId"] = this.phone3TypeId;
        data["phone3TypeName"] = this.phone3TypeName;
        data["phone3Number"] = this.phone3Number;
        data["phone3Ext"] = this.phone3Ext;
        data["accountId"] = this.accountId;
        if (Array.isArray(this.contactAddresses)) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IAppContactDto {
    tenantId: number | undefined;
    name: string | undefined;
    tradeName: string | undefined;
    code: string | undefined;
    languageId: number | undefined;
    languageCode: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    eMailAddress: string | undefined;
    website: string | undefined;
    entityId: number;
    entityCode: string | undefined;
    parentId: number | undefined;
    parentCode: string | undefined;
    partnerId: number | undefined;
    partnerCode: string | undefined;
    accountType: string | undefined;
    accountTypeId: number;
    ssin: string | undefined;
    priceLevel: string | undefined;
    isProfileData: boolean;
    phone1TypeId: number | undefined;
    phone1TypeName: string | undefined;
    phone1Number: string | undefined;
    phone1Ext: string | undefined;
    phone2TypeId: number | undefined;
    phone2TypeName: string | undefined;
    phone2Number: string | undefined;
    phone2Ext: string | undefined;
    phone3TypeId: number | undefined;
    phone3TypeName: string | undefined;
    phone3Number: string | undefined;
    phone3Ext: string | undefined;
    accountId: number | undefined;
    contactAddresses: AppContactAddressDto[] | undefined;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfAppEntityCategoryDto implements IPagedResultDtoOfAppEntityCategoryDto {
    totalCount!: number;
    items!: AppEntityCategoryDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppEntityCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppEntityCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppEntityCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppEntityCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppEntityCategoryDto {
    totalCount: number;
    items: AppEntityCategoryDto[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfAppEntityClassificationDto implements IPagedResultDtoOfAppEntityClassificationDto {
    totalCount!: number;
    items!: AppEntityClassificationDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppEntityClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppEntityClassificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppEntityClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppEntityClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppEntityClassificationDto {
    totalCount: number;
    items: AppEntityClassificationDto[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfString implements IPagedResultDtoOfString {
    totalCount!: number;
    items!: string[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data;
    }
}

export interface IPagedResultDtoOfString {
    totalCount: number;
    items: string[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfAppEntityAttachmentDto implements IPagedResultDtoOfAppEntityAttachmentDto {
    totalCount!: number;
    items!: AppEntityAttachmentDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppEntityAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppEntityAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppEntityAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppEntityAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppEntityAttachmentDto {
    totalCount: number;
    items: AppEntityAttachmentDto[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfAppEntityExtraDataDto implements IPagedResultDtoOfAppEntityExtraDataDto {
    totalCount!: number;
    items!: AppEntityExtraDataDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppEntityExtraDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppEntityExtraDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppEntityExtraDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppEntityExtraDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppEntityExtraDataDto {
    totalCount: number;
    items: AppEntityExtraDataDto[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfInt64 implements IPagedResultDtoOfInt64 {
    totalCount!: number;
    items!: number[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data;
    }
}

export interface IPagedResultDtoOfInt64 {
    totalCount: number;
    items: number[] | undefined;

    [key: string]: any;
}

export class AppEntityUserReactionDto implements IAppEntityUserReactionDto {
    reactionSelected!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityUserReactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.reactionSelected = _data["reactionSelected"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityUserReactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityUserReactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["reactionSelected"] = this.reactionSelected;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityUserReactionDto {
    reactionSelected: number;
    id: number;

    [key: string]: any;
}

export class AppEntityUserReactionsCountDto implements IAppEntityUserReactionsCountDto {
    reactionsCount!: number;
    likeCount!: number;
    celebrateCount!: number;
    loverCount!: number;
    insightfulCount!: number;
    curiousCount!: number;
    viewersCount!: number;
    commentsCount!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityUserReactionsCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.reactionsCount = _data["reactionsCount"];
            this.likeCount = _data["likeCount"];
            this.celebrateCount = _data["celebrateCount"];
            this.loverCount = _data["loverCount"];
            this.insightfulCount = _data["insightfulCount"];
            this.curiousCount = _data["curiousCount"];
            this.viewersCount = _data["viewersCount"];
            this.commentsCount = _data["commentsCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityUserReactionsCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityUserReactionsCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["reactionsCount"] = this.reactionsCount;
        data["likeCount"] = this.likeCount;
        data["celebrateCount"] = this.celebrateCount;
        data["loverCount"] = this.loverCount;
        data["insightfulCount"] = this.insightfulCount;
        data["curiousCount"] = this.curiousCount;
        data["viewersCount"] = this.viewersCount;
        data["commentsCount"] = this.commentsCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityUserReactionsCountDto {
    reactionsCount: number;
    likeCount: number;
    celebrateCount: number;
    loverCount: number;
    insightfulCount: number;
    curiousCount: number;
    viewersCount: number;
    commentsCount: number;
    id: number;

    [key: string]: any;
}

export class AppEntityUserReactionsDto implements IAppEntityUserReactionsDto {
    userId!: number;
    reactionSelected!: number;
    actionTime!: moment.Moment;
    userName!: string | undefined;
    userImage!: string | undefined;
    jobTitle!: string | undefined;
    accountName!: string | undefined;
    profilePictureId!: string;
    profilePictureUrl!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    tenancyName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEntityUserReactionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.reactionSelected = _data["reactionSelected"];
            this.actionTime = _data["actionTime"] ? moment(_data["actionTime"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.userImage = _data["userImage"];
            this.jobTitle = _data["jobTitle"];
            this.accountName = _data["accountName"];
            this.profilePictureId = _data["profilePictureId"];
            this.profilePictureUrl = _data["profilePictureUrl"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.tenancyName = _data["tenancyName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEntityUserReactionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEntityUserReactionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["reactionSelected"] = this.reactionSelected;
        data["actionTime"] = this.actionTime ? this.actionTime.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["userImage"] = this.userImage;
        data["jobTitle"] = this.jobTitle;
        data["accountName"] = this.accountName;
        data["profilePictureId"] = this.profilePictureId;
        data["profilePictureUrl"] = this.profilePictureUrl;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["tenancyName"] = this.tenancyName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEntityUserReactionsDto {
    userId: number;
    reactionSelected: number;
    actionTime: moment.Moment;
    userName: string | undefined;
    userImage: string | undefined;
    jobTitle: string | undefined;
    accountName: string | undefined;
    profilePictureId: string;
    profilePictureUrl: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    tenancyName: string | undefined;
    tenantId: number | undefined;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfAppEntityUserReactionsDto implements IPagedResultDtoOfAppEntityUserReactionsDto {
    totalCount!: number;
    items!: AppEntityUserReactionsDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppEntityUserReactionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppEntityUserReactionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppEntityUserReactionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppEntityUserReactionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppEntityUserReactionsDto {
    totalCount: number;
    items: AppEntityUserReactionsDto[] | undefined;

    [key: string]: any;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;

    [key: string]: any;
}

export class AppPostDto implements IAppPostDto {
    code!: string | undefined;
    description!: string | undefined;
    tenantId!: number | undefined;
    appContactId!: number | undefined;
    appEntityId!: number | undefined;
    creatorUserId!: number | undefined;
    userName!: string | undefined;
    accountName!: string | undefined;
    accountId!: number;
    profilePictureId!: string;
    userImage!: GetProfilePictureOutput;
    creationDatetime!: moment.Moment;
    embeddedLink!: string | undefined;
    profilePictureUrl!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.appContactId = _data["appContactId"];
            this.appEntityId = _data["appEntityId"];
            this.creatorUserId = _data["creatorUserId"];
            this.userName = _data["userName"];
            this.accountName = _data["accountName"];
            this.accountId = _data["accountId"];
            this.profilePictureId = _data["profilePictureId"];
            this.userImage = _data["userImage"] ? GetProfilePictureOutput.fromJS(_data["userImage"]) : <any>undefined;
            this.creationDatetime = _data["creationDatetime"] ? moment(_data["creationDatetime"].toString()) : <any>undefined;
            this.embeddedLink = _data["embeddedLink"];
            this.profilePictureUrl = _data["profilePictureUrl"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["appContactId"] = this.appContactId;
        data["appEntityId"] = this.appEntityId;
        data["creatorUserId"] = this.creatorUserId;
        data["userName"] = this.userName;
        data["accountName"] = this.accountName;
        data["accountId"] = this.accountId;
        data["profilePictureId"] = this.profilePictureId;
        data["userImage"] = this.userImage ? this.userImage.toJSON() : <any>undefined;
        data["creationDatetime"] = this.creationDatetime ? this.creationDatetime.toISOString() : <any>undefined;
        data["embeddedLink"] = this.embeddedLink;
        data["profilePictureUrl"] = this.profilePictureUrl;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppPostDto {
    code: string | undefined;
    description: string | undefined;
    tenantId: number | undefined;
    appContactId: number | undefined;
    appEntityId: number | undefined;
    creatorUserId: number | undefined;
    userName: string | undefined;
    accountName: string | undefined;
    accountId: number;
    profilePictureId: string;
    userImage: GetProfilePictureOutput;
    creationDatetime: moment.Moment;
    embeddedLink: string | undefined;
    profilePictureUrl: string | undefined;
    id: number;

    [key: string]: any;
}

export class TopPostDto implements ITopPostDto {
    userId!: number;
    appPost!: AppPostDto;
    userName!: string | undefined;
    description!: string | undefined;
    imageUrl!: string | undefined;
    createdOn!: string | undefined;
    type!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ITopPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.appPost = _data["appPost"] ? AppPostDto.fromJS(_data["appPost"]) : <any>undefined;
            this.userName = _data["userName"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.createdOn = _data["createdOn"];
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TopPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["appPost"] = this.appPost ? this.appPost.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["createdOn"] = this.createdOn;
        data["type"] = this.type;
        data["id"] = this.id;
        return data;
    }
}

export interface ITopPostDto {
    userId: number;
    appPost: AppPostDto;
    userName: string | undefined;
    description: string | undefined;
    imageUrl: string | undefined;
    createdOn: string | undefined;
    type: string | undefined;
    id: number;

    [key: string]: any;
}

export class UserInformationDto implements IUserInformationDto {
    userImage!: string | undefined;
    jobTitle!: string | undefined;
    accountName!: string | undefined;
    accountId!: number;
    userName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userImage = _data["userImage"];
            this.jobTitle = _data["jobTitle"];
            this.accountName = _data["accountName"];
            this.accountId = _data["accountId"];
            this.userName = _data["userName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userImage"] = this.userImage;
        data["jobTitle"] = this.jobTitle;
        data["accountName"] = this.accountName;
        data["accountId"] = this.accountId;
        data["userName"] = this.userName;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserInformationDto {
    userImage: string | undefined;
    jobTitle: string | undefined;
    accountName: string | undefined;
    accountId: number;
    userName: string | undefined;
    id: number;

    [key: string]: any;
}

export class TopCompany implements ITopCompany {
    accountId!: number;
    tenantId!: number;
    accountName!: string | undefined;
    logoUrl!: string | undefined;

    [key: string]: any;

    constructor(data?: ITopCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountId = _data["accountId"];
            this.tenantId = _data["tenantId"];
            this.accountName = _data["accountName"];
            this.logoUrl = _data["logoUrl"];
        }
    }

    static fromJS(data: any): TopCompany {
        data = typeof data === 'object' ? data : {};
        let result = new TopCompany();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["tenantId"] = this.tenantId;
        data["accountName"] = this.accountName;
        data["logoUrl"] = this.logoUrl;
        return data;
    }
}

export interface ITopCompany {
    accountId: number;
    tenantId: number;
    accountName: string | undefined;
    logoUrl: string | undefined;

    [key: string]: any;
}

export enum ResponceType {
    OTHER = 0,
    INTEREST = 1,
    GOING = 2,
    MAYBE = 3,
    CANNOTGO = 4,
    INVITE = 5,
    NOTINTEREST = 6,
}

export class AppEventGuestDto implements IAppEventGuestDto {
    entityId!: number;
    responceId!: number;
    userResponceType!: ResponceType;
    userId!: number | undefined;
    eventId!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEventGuestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.responceId = _data["responceId"];
            this.userResponceType = _data["userResponceType"];
            this.userId = _data["userId"];
            this.eventId = _data["eventId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEventGuestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEventGuestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["responceId"] = this.responceId;
        data["userResponceType"] = this.userResponceType;
        data["userId"] = this.userId;
        data["eventId"] = this.eventId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEventGuestDto {
    entityId: number;
    responceId: number;
    userResponceType: ResponceType;
    userId: number | undefined;
    eventId: number;
    id: number;

    [key: string]: any;
}

export class GetAppEventGuestForViewDto implements IGetAppEventGuestForViewDto {
    appEventGuest!: AppEventGuestDto;

    [key: string]: any;

    constructor(data?: IGetAppEventGuestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appEventGuest = _data["appEventGuest"] ? AppEventGuestDto.fromJS(_data["appEventGuest"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppEventGuestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppEventGuestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appEventGuest"] = this.appEventGuest ? this.appEventGuest.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppEventGuestForViewDto {
    appEventGuest: AppEventGuestDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppEventGuestForViewDto implements IPagedResultDtoOfGetAppEventGuestForViewDto {
    totalCount!: number;
    items!: GetAppEventGuestForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppEventGuestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppEventGuestForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppEventGuestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppEventGuestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppEventGuestForViewDto {
    totalCount: number;
    items: GetAppEventGuestForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppEventGuestDto implements ICreateOrEditAppEventGuestDto {
    eventId!: number;
    code!: string | undefined;
    userResponce!: ResponceType;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppEventGuestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.eventId = _data["eventId"];
            this.code = _data["code"];
            this.userResponce = _data["userResponce"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppEventGuestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppEventGuestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["eventId"] = this.eventId;
        data["code"] = this.code;
        data["userResponce"] = this.userResponce;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppEventGuestDto {
    eventId: number;
    code: string | undefined;
    userResponce: ResponceType;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppEventGuestForEditOutput implements IGetAppEventGuestForEditOutput {
    appEventGuest!: CreateOrEditAppEventGuestDto;

    [key: string]: any;

    constructor(data?: IGetAppEventGuestForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appEventGuest = _data["appEventGuest"] ? CreateOrEditAppEventGuestDto.fromJS(_data["appEventGuest"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppEventGuestForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppEventGuestForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appEventGuest"] = this.appEventGuest ? this.appEventGuest.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppEventGuestForEditOutput {
    appEventGuest: CreateOrEditAppEventGuestDto;

    [key: string]: any;
}

export enum EventsFilterTypesEnum {
    AllEvents = 0,
    MyEvents = 1,
    UpcommingEvents = 2,
    PriorEvents = 3,
}

export class AppEventDto implements IAppEventDto {
    entityId!: number | undefined;
    userName!: string | undefined;
    userId!: number;
    isOnLine!: boolean;
    isPublished!: boolean;
    logoURL!: string | undefined;
    banarURL!: string | undefined;
    status!: string | undefined;
    guestsCount!: number;
    address1!: string | undefined;
    address2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postal!: string | undefined;
    country!: string | undefined;
    fromDate!: moment.Moment;
    utcFromDateTime!: moment.Moment;
    utcToDateTime!: moment.Moment;
    toDate!: moment.Moment;
    fromTime!: moment.Moment;
    toTime!: moment.Moment;
    privacy!: boolean;
    guestCanInviteFriends!: boolean;
    name!: string | undefined;
    code!: string | undefined;
    description!: string | undefined;
    timeZone!: string | undefined;
    registrationLink!: string | undefined;
    attachments!: AppEntityAttachmentDto[] | undefined;
    address!: AppEntityAddressDto;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.userName = _data["userName"];
            this.userId = _data["userId"];
            this.isOnLine = _data["isOnLine"];
            this.isPublished = _data["isPublished"];
            this.logoURL = _data["logoURL"];
            this.banarURL = _data["banarURL"];
            this.status = _data["status"];
            this.guestsCount = _data["guestsCount"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postal = _data["postal"];
            this.country = _data["country"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.utcFromDateTime = _data["utcFromDateTime"] ? moment(_data["utcFromDateTime"].toString()) : <any>undefined;
            this.utcToDateTime = _data["utcToDateTime"] ? moment(_data["utcToDateTime"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.fromTime = _data["fromTime"] ? moment(_data["fromTime"].toString()) : <any>undefined;
            this.toTime = _data["toTime"] ? moment(_data["toTime"].toString()) : <any>undefined;
            this.privacy = _data["privacy"];
            this.guestCanInviteFriends = _data["guestCanInviteFriends"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.timeZone = _data["timeZone"];
            this.registrationLink = _data["registrationLink"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.address = _data["address"] ? AppEntityAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        data["isOnLine"] = this.isOnLine;
        data["isPublished"] = this.isPublished;
        data["logoURL"] = this.logoURL;
        data["banarURL"] = this.banarURL;
        data["status"] = this.status;
        data["guestsCount"] = this.guestsCount;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postal"] = this.postal;
        data["country"] = this.country;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["utcFromDateTime"] = this.utcFromDateTime ? this.utcFromDateTime.toISOString() : <any>undefined;
        data["utcToDateTime"] = this.utcToDateTime ? this.utcToDateTime.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["fromTime"] = this.fromTime ? this.fromTime.toISOString() : <any>undefined;
        data["toTime"] = this.toTime ? this.toTime.toISOString() : <any>undefined;
        data["privacy"] = this.privacy;
        data["guestCanInviteFriends"] = this.guestCanInviteFriends;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["timeZone"] = this.timeZone;
        data["registrationLink"] = this.registrationLink;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppEventDto {
    entityId: number | undefined;
    userName: string | undefined;
    userId: number;
    isOnLine: boolean;
    isPublished: boolean;
    logoURL: string | undefined;
    banarURL: string | undefined;
    status: string | undefined;
    guestsCount: number;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postal: string | undefined;
    country: string | undefined;
    fromDate: moment.Moment;
    utcFromDateTime: moment.Moment;
    utcToDateTime: moment.Moment;
    toDate: moment.Moment;
    fromTime: moment.Moment;
    toTime: moment.Moment;
    privacy: boolean;
    guestCanInviteFriends: boolean;
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    timeZone: string | undefined;
    registrationLink: string | undefined;
    attachments: AppEntityAttachmentDto[] | undefined;
    address: AppEntityAddressDto;
    id: number;

    [key: string]: any;
}

export class GetAppEventForViewDto implements IGetAppEventForViewDto {
    appEvent!: AppEventDto;
    currentUserResponce!: ResponceType;
    currentFromDateTime!: moment.Moment;
    currentToDateTime!: moment.Moment;

    [key: string]: any;

    constructor(data?: IGetAppEventForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appEvent = _data["appEvent"] ? AppEventDto.fromJS(_data["appEvent"]) : <any>undefined;
            this.currentUserResponce = _data["currentUserResponce"];
            this.currentFromDateTime = _data["currentFromDateTime"] ? moment(_data["currentFromDateTime"].toString()) : <any>undefined;
            this.currentToDateTime = _data["currentToDateTime"] ? moment(_data["currentToDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppEventForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppEventForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appEvent"] = this.appEvent ? this.appEvent.toJSON() : <any>undefined;
        data["currentUserResponce"] = this.currentUserResponce;
        data["currentFromDateTime"] = this.currentFromDateTime ? this.currentFromDateTime.toISOString() : <any>undefined;
        data["currentToDateTime"] = this.currentToDateTime ? this.currentToDateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetAppEventForViewDto {
    appEvent: AppEventDto;
    currentUserResponce: ResponceType;
    currentFromDateTime: moment.Moment;
    currentToDateTime: moment.Moment;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppEventForViewDto implements IPagedResultDtoOfGetAppEventForViewDto {
    totalCount!: number;
    items!: GetAppEventForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppEventForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppEventForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppEventForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppEventForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppEventForViewDto {
    totalCount: number;
    items: GetAppEventForViewDto[] | undefined;

    [key: string]: any;
}

export class GetAppEventForEditDto implements IGetAppEventForEditDto {
    appEvent!: AppEventDto;
    currentUserResponce!: ResponceType;
    currentFromDateTime!: moment.Moment;
    currentToDateTime!: moment.Moment;

    [key: string]: any;

    constructor(data?: IGetAppEventForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appEvent = _data["appEvent"] ? AppEventDto.fromJS(_data["appEvent"]) : <any>undefined;
            this.currentUserResponce = _data["currentUserResponce"];
            this.currentFromDateTime = _data["currentFromDateTime"] ? moment(_data["currentFromDateTime"].toString()) : <any>undefined;
            this.currentToDateTime = _data["currentToDateTime"] ? moment(_data["currentToDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppEventForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppEventForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appEvent"] = this.appEvent ? this.appEvent.toJSON() : <any>undefined;
        data["currentUserResponce"] = this.currentUserResponce;
        data["currentFromDateTime"] = this.currentFromDateTime ? this.currentFromDateTime.toISOString() : <any>undefined;
        data["currentToDateTime"] = this.currentToDateTime ? this.currentToDateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetAppEventForEditDto {
    appEvent: AppEventDto;
    currentUserResponce: ResponceType;
    currentFromDateTime: moment.Moment;
    currentToDateTime: moment.Moment;

    [key: string]: any;
}

export class CreateOrEditAppEventDto implements ICreateOrEditAppEventDto {
    entityId!: number;
    code!: string | undefined;
    isOnLine!: boolean;
    name!: string | undefined;
    timeZone!: string | undefined;
    fromDate!: moment.Moment;
    toDate!: moment.Moment;
    fromTime!: moment.Moment;
    toTime!: moment.Moment;
    privacy!: boolean;
    guestCanInviteFriends!: boolean;
    address!: AppEntityAddressDto;
    description!: string | undefined;
    registrationLink!: string | undefined;
    attachments!: AppEntityAttachmentDto[] | undefined;
    status!: number;
    isPublished!: boolean;
    utcFromDateTime!: moment.Moment;
    utcToDateTime!: moment.Moment;
    fromHour!: number;
    toHour!: number;
    fromMinute!: number;
    toMinute!: number;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.code = _data["code"];
            this.isOnLine = _data["isOnLine"];
            this.name = _data["name"];
            this.timeZone = _data["timeZone"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.fromTime = _data["fromTime"] ? moment(_data["fromTime"].toString()) : <any>undefined;
            this.toTime = _data["toTime"] ? moment(_data["toTime"].toString()) : <any>undefined;
            this.privacy = _data["privacy"];
            this.guestCanInviteFriends = _data["guestCanInviteFriends"];
            this.address = _data["address"] ? AppEntityAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.description = _data["description"];
            this.registrationLink = _data["registrationLink"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.status = _data["status"];
            this.isPublished = _data["isPublished"];
            this.utcFromDateTime = _data["utcFromDateTime"] ? moment(_data["utcFromDateTime"].toString()) : <any>undefined;
            this.utcToDateTime = _data["utcToDateTime"] ? moment(_data["utcToDateTime"].toString()) : <any>undefined;
            this.fromHour = _data["fromHour"];
            this.toHour = _data["toHour"];
            this.fromMinute = _data["fromMinute"];
            this.toMinute = _data["toMinute"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["code"] = this.code;
        data["isOnLine"] = this.isOnLine;
        data["name"] = this.name;
        data["timeZone"] = this.timeZone;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["fromTime"] = this.fromTime ? this.fromTime.toISOString() : <any>undefined;
        data["toTime"] = this.toTime ? this.toTime.toISOString() : <any>undefined;
        data["privacy"] = this.privacy;
        data["guestCanInviteFriends"] = this.guestCanInviteFriends;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["registrationLink"] = this.registrationLink;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["isPublished"] = this.isPublished;
        data["utcFromDateTime"] = this.utcFromDateTime ? this.utcFromDateTime.toISOString() : <any>undefined;
        data["utcToDateTime"] = this.utcToDateTime ? this.utcToDateTime.toISOString() : <any>undefined;
        data["fromHour"] = this.fromHour;
        data["toHour"] = this.toHour;
        data["fromMinute"] = this.fromMinute;
        data["toMinute"] = this.toMinute;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppEventDto {
    entityId: number;
    code: string | undefined;
    isOnLine: boolean;
    name: string | undefined;
    timeZone: string | undefined;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    fromTime: moment.Moment;
    toTime: moment.Moment;
    privacy: boolean;
    guestCanInviteFriends: boolean;
    address: AppEntityAddressDto;
    description: string | undefined;
    registrationLink: string | undefined;
    attachments: AppEntityAttachmentDto[] | undefined;
    status: number;
    isPublished: boolean;
    utcFromDateTime: moment.Moment;
    utcToDateTime: moment.Moment;
    fromHour: number;
    toHour: number;
    fromMinute: number;
    toMinute: number;
    id: number | undefined;

    [key: string]: any;
}

export enum ItemsFilterTypesEnum {
    MyItems = 0,
    MyListing = 1,
    SharedWithMe = 2,
    Public = 3,
    SharedWithMeAndPublic = 4,
}

export class ArrtibuteFilter implements IArrtibuteFilter {
    arrtibuteId!: number;
    arrtibuteValueId!: number;
    readonly keyValue!: string | undefined;

    [key: string]: any;

    constructor(data?: IArrtibuteFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.arrtibuteId = _data["arrtibuteId"];
            this.arrtibuteValueId = _data["arrtibuteValueId"];
            (<any>this).keyValue = _data["keyValue"];
        }
    }

    static fromJS(data: any): ArrtibuteFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ArrtibuteFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["arrtibuteId"] = this.arrtibuteId;
        data["arrtibuteValueId"] = this.arrtibuteValueId;
        data["keyValue"] = this.keyValue;
        return data;
    }
}

export interface IArrtibuteFilter {
    arrtibuteId: number;
    arrtibuteValueId: number;
    keyValue: string | undefined;

    [key: string]: any;
}

export class AppItemDto implements IAppItemDto {
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    price!: number;
    published!: boolean;
    listed!: boolean;
    imageUrl!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.published = _data["published"];
            this.listed = _data["listed"];
            this.imageUrl = _data["imageUrl"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["published"] = this.published;
        data["listed"] = this.listed;
        data["imageUrl"] = this.imageUrl;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemDto {
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    price: number;
    published: boolean;
    listed: boolean;
    imageUrl: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppItemForViewDto implements IGetAppItemForViewDto {
    appItem!: AppItemDto;
    selected!: boolean;

    [key: string]: any;

    constructor(data?: IGetAppItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItem = _data["appItem"] ? AppItemDto.fromJS(_data["appItem"]) : <any>undefined;
            this.selected = _data["selected"];
        }
    }

    static fromJS(data: any): GetAppItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItem"] = this.appItem ? this.appItem.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        return data;
    }
}

export interface IGetAppItemForViewDto {
    appItem: AppItemDto;
    selected: boolean;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppItemForViewDto implements IPagedResultDtoOfGetAppItemForViewDto {
    totalCount!: number;
    items!: GetAppItemForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppItemForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppItemForViewDto {
    totalCount: number;
    items: GetAppItemForViewDto[] | undefined;

    [key: string]: any;
}

export class GetAllAppItemsInput implements IGetAllAppItemsInput {
    tenantId!: number | undefined;
    appItemListId!: number | undefined;
    selectorOnly!: boolean | undefined;
    filter!: string | undefined;
    filterType!: ItemsFilterTypesEnum;
    lastKey!: string | undefined;
    selectorKey!: string | undefined;
    priceListId!: number;
    arrtibuteFilters!: ArrtibuteFilter[] | undefined;
    classificationFilters!: number[] | undefined;
    categoryFilters!: number[] | undefined;
    departmentFilters!: number[] | undefined;
    entityObjectTypeId!: number;
    minimumPrice!: number;
    maximumPrice!: number;
    itemType!: number;
    listingStatus!: number;
    publishStatus!: number;
    visibilityStatus!: number;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    [key: string]: any;

    constructor(data?: IGetAllAppItemsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.appItemListId = _data["appItemListId"];
            this.selectorOnly = _data["selectorOnly"];
            this.filter = _data["filter"];
            this.filterType = _data["filterType"];
            this.lastKey = _data["lastKey"];
            this.selectorKey = _data["selectorKey"];
            this.priceListId = _data["priceListId"];
            if (Array.isArray(_data["arrtibuteFilters"])) {
                this.arrtibuteFilters = [] as any;
                for (let item of _data["arrtibuteFilters"])
                    this.arrtibuteFilters!.push(ArrtibuteFilter.fromJS(item));
            }
            if (Array.isArray(_data["classificationFilters"])) {
                this.classificationFilters = [] as any;
                for (let item of _data["classificationFilters"])
                    this.classificationFilters!.push(item);
            }
            if (Array.isArray(_data["categoryFilters"])) {
                this.categoryFilters = [] as any;
                for (let item of _data["categoryFilters"])
                    this.categoryFilters!.push(item);
            }
            if (Array.isArray(_data["departmentFilters"])) {
                this.departmentFilters = [] as any;
                for (let item of _data["departmentFilters"])
                    this.departmentFilters!.push(item);
            }
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.minimumPrice = _data["minimumPrice"];
            this.maximumPrice = _data["maximumPrice"];
            this.itemType = _data["itemType"];
            this.listingStatus = _data["listingStatus"];
            this.publishStatus = _data["publishStatus"];
            this.visibilityStatus = _data["visibilityStatus"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllAppItemsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAppItemsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["appItemListId"] = this.appItemListId;
        data["selectorOnly"] = this.selectorOnly;
        data["filter"] = this.filter;
        data["filterType"] = this.filterType;
        data["lastKey"] = this.lastKey;
        data["selectorKey"] = this.selectorKey;
        data["priceListId"] = this.priceListId;
        if (Array.isArray(this.arrtibuteFilters)) {
            data["arrtibuteFilters"] = [];
            for (let item of this.arrtibuteFilters)
                data["arrtibuteFilters"].push(item.toJSON());
        }
        if (Array.isArray(this.classificationFilters)) {
            data["classificationFilters"] = [];
            for (let item of this.classificationFilters)
                data["classificationFilters"].push(item);
        }
        if (Array.isArray(this.categoryFilters)) {
            data["categoryFilters"] = [];
            for (let item of this.categoryFilters)
                data["categoryFilters"].push(item);
        }
        if (Array.isArray(this.departmentFilters)) {
            data["departmentFilters"] = [];
            for (let item of this.departmentFilters)
                data["departmentFilters"].push(item);
        }
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["minimumPrice"] = this.minimumPrice;
        data["maximumPrice"] = this.maximumPrice;
        data["itemType"] = this.itemType;
        data["listingStatus"] = this.listingStatus;
        data["publishStatus"] = this.publishStatus;
        data["visibilityStatus"] = this.visibilityStatus;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IGetAllAppItemsInput {
    tenantId: number | undefined;
    appItemListId: number | undefined;
    selectorOnly: boolean | undefined;
    filter: string | undefined;
    filterType: ItemsFilterTypesEnum;
    lastKey: string | undefined;
    selectorKey: string | undefined;
    priceListId: number;
    arrtibuteFilters: ArrtibuteFilter[] | undefined;
    classificationFilters: number[] | undefined;
    categoryFilters: number[] | undefined;
    departmentFilters: number[] | undefined;
    entityObjectTypeId: number;
    minimumPrice: number;
    maximumPrice: number;
    itemType: number;
    listingStatus: number;
    publishStatus: number;
    visibilityStatus: number;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    [key: string]: any;
}

export class EDRestAttributes implements IEDRestAttributes {
    extraAttrName!: string | undefined;
    totalCount!: number;
    extraAttributeId!: number;
    values!: LookupLabelDto[] | undefined;

    [key: string]: any;

    constructor(data?: IEDRestAttributes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.extraAttrName = _data["extraAttrName"];
            this.totalCount = _data["totalCount"];
            this.extraAttributeId = _data["extraAttributeId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(LookupLabelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EDRestAttributes {
        data = typeof data === 'object' ? data : {};
        let result = new EDRestAttributes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["extraAttrName"] = this.extraAttrName;
        data["totalCount"] = this.totalCount;
        data["extraAttributeId"] = this.extraAttributeId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEDRestAttributes {
    extraAttrName: string | undefined;
    totalCount: number;
    extraAttributeId: number;
    values: LookupLabelDto[] | undefined;

    [key: string]: any;
}

export class ExtraDataSelectedValues implements IExtraDataSelectedValues {
    value!: string | undefined;
    totalCount!: number;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    defaultEntityAttachment!: AppEntityAttachmentDto;
    edRestAttributes!: EDRestAttributes[] | undefined;

    [key: string]: any;

    constructor(data?: IExtraDataSelectedValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.defaultEntityAttachment = _data["defaultEntityAttachment"] ? AppEntityAttachmentDto.fromJS(_data["defaultEntityAttachment"]) : <any>undefined;
            if (Array.isArray(_data["edRestAttributes"])) {
                this.edRestAttributes = [] as any;
                for (let item of _data["edRestAttributes"])
                    this.edRestAttributes!.push(EDRestAttributes.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExtraDataSelectedValues {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraDataSelectedValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        data["defaultEntityAttachment"] = this.defaultEntityAttachment ? this.defaultEntityAttachment.toJSON() : <any>undefined;
        if (Array.isArray(this.edRestAttributes)) {
            data["edRestAttributes"] = [];
            for (let item of this.edRestAttributes)
                data["edRestAttributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExtraDataSelectedValues {
    value: string | undefined;
    totalCount: number;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    defaultEntityAttachment: AppEntityAttachmentDto;
    edRestAttributes: EDRestAttributes[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfExtraDataSelectedValues implements IPagedResultDtoOfExtraDataSelectedValues {
    totalCount!: number;
    items!: ExtraDataSelectedValues[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfExtraDataSelectedValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExtraDataSelectedValues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExtraDataSelectedValues {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExtraDataSelectedValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfExtraDataSelectedValues {
    totalCount: number;
    items: ExtraDataSelectedValues[] | undefined;

    [key: string]: any;
}

export class AppItemPriceInfo implements IAppItemPriceInfo {
    code!: string | undefined;
    price!: number;
    currencyId!: number;
    currencyCode!: string | undefined;
    currencySymbol!: string | undefined;
    currencyName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemPriceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.price = _data["price"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.currencySymbol = _data["currencySymbol"];
            this.currencyName = _data["currencyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemPriceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemPriceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["price"] = this.price;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["currencySymbol"] = this.currencySymbol;
        data["currencyName"] = this.currencyName;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemPriceInfo {
    code: string | undefined;
    price: number;
    currencyId: number;
    currencyCode: string | undefined;
    currencySymbol: string | undefined;
    currencyName: string | undefined;
    id: number;

    [key: string]: any;
}

export class ItemSharingDto implements IItemSharingDto {
    sharedTenantId!: number | undefined;
    sharedUserId!: number | undefined;
    sharedUserEMail!: string | undefined;
    sharedUserName!: string | undefined;
    sharedUserSureName!: string | undefined;
    sharedUserTenantName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IItemSharingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sharedTenantId = _data["sharedTenantId"];
            this.sharedUserId = _data["sharedUserId"];
            this.sharedUserEMail = _data["sharedUserEMail"];
            this.sharedUserName = _data["sharedUserName"];
            this.sharedUserSureName = _data["sharedUserSureName"];
            this.sharedUserTenantName = _data["sharedUserTenantName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ItemSharingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemSharingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sharedTenantId"] = this.sharedTenantId;
        data["sharedUserId"] = this.sharedUserId;
        data["sharedUserEMail"] = this.sharedUserEMail;
        data["sharedUserName"] = this.sharedUserName;
        data["sharedUserSureName"] = this.sharedUserSureName;
        data["sharedUserTenantName"] = this.sharedUserTenantName;
        data["id"] = this.id;
        return data;
    }
}

export interface IItemSharingDto {
    sharedTenantId: number | undefined;
    sharedUserId: number | undefined;
    sharedUserEMail: string | undefined;
    sharedUserName: string | undefined;
    sharedUserSureName: string | undefined;
    sharedUserTenantName: string | undefined;
    id: number;

    [key: string]: any;
}

export class VariationItemDto implements IVariationItemDto {
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    position!: number;
    parentId!: number | undefined;
    price!: number;
    code!: string | undefined;
    listingItemId!: number | undefined;
    stockAvailability!: number;
    appItemPriceInfos!: AppItemPriceInfo[] | undefined;
    ssin!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IVariationItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            this.position = _data["position"];
            this.parentId = _data["parentId"];
            this.price = _data["price"];
            this.code = _data["code"];
            this.listingItemId = _data["listingItemId"];
            this.stockAvailability = _data["stockAvailability"];
            if (Array.isArray(_data["appItemPriceInfos"])) {
                this.appItemPriceInfos = [] as any;
                for (let item of _data["appItemPriceInfos"])
                    this.appItemPriceInfos!.push(AppItemPriceInfo.fromJS(item));
            }
            this.ssin = _data["ssin"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VariationItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new VariationItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        data["position"] = this.position;
        data["parentId"] = this.parentId;
        data["price"] = this.price;
        data["code"] = this.code;
        data["listingItemId"] = this.listingItemId;
        data["stockAvailability"] = this.stockAvailability;
        if (Array.isArray(this.appItemPriceInfos)) {
            data["appItemPriceInfos"] = [];
            for (let item of this.appItemPriceInfos)
                data["appItemPriceInfos"].push(item.toJSON());
        }
        data["ssin"] = this.ssin;
        data["id"] = this.id;
        return data;
    }
}

export interface IVariationItemDto {
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    position: number;
    parentId: number | undefined;
    price: number;
    code: string | undefined;
    listingItemId: number | undefined;
    stockAvailability: number;
    appItemPriceInfos: AppItemPriceInfo[] | undefined;
    ssin: string | undefined;
    id: number;

    [key: string]: any;
}

export class ExtraDataAttrDto implements IExtraDataAttrDto {
    extraAttrUsage!: string | undefined;
    extraAttrName!: string | undefined;
    selectedValuesTotalCount!: number;
    extraAttrDataType!: string | undefined;
    extraAttributeId!: number;
    selectedValues!: ExtraDataSelectedValues[] | undefined;

    [key: string]: any;

    constructor(data?: IExtraDataAttrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.extraAttrUsage = _data["extraAttrUsage"];
            this.extraAttrName = _data["extraAttrName"];
            this.selectedValuesTotalCount = _data["selectedValuesTotalCount"];
            this.extraAttrDataType = _data["extraAttrDataType"];
            this.extraAttributeId = _data["extraAttributeId"];
            if (Array.isArray(_data["selectedValues"])) {
                this.selectedValues = [] as any;
                for (let item of _data["selectedValues"])
                    this.selectedValues!.push(ExtraDataSelectedValues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExtraDataAttrDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraDataAttrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["extraAttrUsage"] = this.extraAttrUsage;
        data["extraAttrName"] = this.extraAttrName;
        data["selectedValuesTotalCount"] = this.selectedValuesTotalCount;
        data["extraAttrDataType"] = this.extraAttrDataType;
        data["extraAttributeId"] = this.extraAttributeId;
        if (Array.isArray(this.selectedValues)) {
            data["selectedValues"] = [];
            for (let item of this.selectedValues)
                data["selectedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExtraDataAttrDto {
    extraAttrUsage: string | undefined;
    extraAttrName: string | undefined;
    selectedValuesTotalCount: number;
    extraAttrDataType: string | undefined;
    extraAttributeId: number;
    selectedValues: ExtraDataSelectedValues[] | undefined;

    [key: string]: any;
}

export class AppSizeScalesDetailDto implements IAppSizeScalesDetailDto {
    sizeCode!: string | undefined;
    sizeRatio!: number;
    d1Position!: string | undefined;
    d2Position!: string | undefined;
    d3Position!: string | undefined;
    sizeId!: number | undefined;
    dimensionName!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: IAppSizeScalesDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sizeCode = _data["sizeCode"];
            this.sizeRatio = _data["sizeRatio"];
            this.d1Position = _data["d1Position"];
            this.d2Position = _data["d2Position"];
            this.d3Position = _data["d3Position"];
            this.sizeId = _data["sizeId"];
            this.dimensionName = _data["dimensionName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppSizeScalesDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSizeScalesDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sizeCode"] = this.sizeCode;
        data["sizeRatio"] = this.sizeRatio;
        data["d1Position"] = this.d1Position;
        data["d2Position"] = this.d2Position;
        data["d3Position"] = this.d3Position;
        data["sizeId"] = this.sizeId;
        data["dimensionName"] = this.dimensionName;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppSizeScalesDetailDto {
    sizeCode: string | undefined;
    sizeRatio: number;
    d1Position: string | undefined;
    d2Position: string | undefined;
    d3Position: string | undefined;
    sizeId: number | undefined;
    dimensionName: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class AppItemSizesScaleInfo implements IAppItemSizesScaleInfo {
    sizeScaleId!: number | undefined;
    name!: string | undefined;
    parentId!: number | undefined;
    code!: string | undefined;
    noOfDimensions!: number;
    isDefault!: boolean;
    dimesion1Name!: string;
    dimesion2Name!: string | undefined;
    dimesion3Name!: string | undefined;
    appSizeScalesDetails!: AppSizeScalesDetailDto[] | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: IAppItemSizesScaleInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sizeScaleId = _data["sizeScaleId"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.noOfDimensions = _data["noOfDimensions"];
            this.isDefault = _data["isDefault"];
            this.dimesion1Name = _data["dimesion1Name"];
            this.dimesion2Name = _data["dimesion2Name"];
            this.dimesion3Name = _data["dimesion3Name"];
            if (Array.isArray(_data["appSizeScalesDetails"])) {
                this.appSizeScalesDetails = [] as any;
                for (let item of _data["appSizeScalesDetails"])
                    this.appSizeScalesDetails!.push(AppSizeScalesDetailDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemSizesScaleInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemSizesScaleInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sizeScaleId"] = this.sizeScaleId;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["noOfDimensions"] = this.noOfDimensions;
        data["isDefault"] = this.isDefault;
        data["dimesion1Name"] = this.dimesion1Name;
        data["dimesion2Name"] = this.dimesion2Name;
        data["dimesion3Name"] = this.dimesion3Name;
        if (Array.isArray(this.appSizeScalesDetails)) {
            data["appSizeScalesDetails"] = [];
            for (let item of this.appSizeScalesDetails)
                data["appSizeScalesDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemSizesScaleInfo {
    sizeScaleId: number | undefined;
    name: string | undefined;
    parentId: number | undefined;
    code: string | undefined;
    noOfDimensions: number;
    isDefault: boolean;
    dimesion1Name: string;
    dimesion2Name: string | undefined;
    dimesion3Name: string | undefined;
    appSizeScalesDetails: AppSizeScalesDetailDto[] | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class AppItemVariationsDto implements IAppItemVariationsDto {
    appItemPriceInfos!: AppItemPriceInfo[] | undefined;
    code!: string | undefined;
    name!: string | undefined;
    entityId!: number;
    description!: string | undefined;
    price!: number;
    stockAvailability!: number;
    status!: string | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeName!: string | undefined;
    itemType!: number;
    sharingLevel!: number;
    parentId!: number | undefined;
    listingItemId!: number | undefined;
    published!: boolean;
    listed!: boolean;
    itemSharing!: ItemSharingDto[] | undefined;
    entityCategories!: PagedResultDtoOfAppEntityCategoryDto;
    entityCategoriesAdded!: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved!: AppEntityCategoryDto[] | undefined;
    entityDepartments!: PagedResultDtoOfAppEntityCategoryDto;
    entityDepartmentsAdded!: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: PagedResultDtoOfAppEntityClassificationDto;
    entityClassificationsAdded!: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    variationItems!: VariationItemDto[] | undefined;
    extraDataAttr!: ExtraDataAttrDto[] | undefined;
    recommended!: ExtraDataAttrDto[] | undefined;
    additional!: ExtraDataAttrDto[] | undefined;
    variations!: ExtraDataAttrDto[] | undefined;
    appItemSizesScaleInfo!: AppItemSizesScaleInfo[] | undefined;
    sycIdentifierId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemVariationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["appItemPriceInfos"])) {
                this.appItemPriceInfos = [] as any;
                for (let item of _data["appItemPriceInfos"])
                    this.appItemPriceInfos!.push(AppItemPriceInfo.fromJS(item));
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.entityId = _data["entityId"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockAvailability = _data["stockAvailability"];
            this.status = _data["status"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeName = _data["entityObjectTypeName"];
            this.itemType = _data["itemType"];
            this.sharingLevel = _data["sharingLevel"];
            this.parentId = _data["parentId"];
            this.listingItemId = _data["listingItemId"];
            this.published = _data["published"];
            this.listed = _data["listed"];
            if (Array.isArray(_data["itemSharing"])) {
                this.itemSharing = [] as any;
                for (let item of _data["itemSharing"])
                    this.itemSharing!.push(ItemSharingDto.fromJS(item));
            }
            this.entityCategories = _data["entityCategories"] ? PagedResultDtoOfAppEntityCategoryDto.fromJS(_data["entityCategories"]) : <any>undefined;
            if (Array.isArray(_data["entityCategoriesAdded"])) {
                this.entityCategoriesAdded = [] as any;
                for (let item of _data["entityCategoriesAdded"])
                    this.entityCategoriesAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategoriesRemoved"])) {
                this.entityCategoriesRemoved = [] as any;
                for (let item of _data["entityCategoriesRemoved"])
                    this.entityCategoriesRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            this.entityDepartments = _data["entityDepartments"] ? PagedResultDtoOfAppEntityCategoryDto.fromJS(_data["entityDepartments"]) : <any>undefined;
            if (Array.isArray(_data["entityDepartmentsAdded"])) {
                this.entityDepartmentsAdded = [] as any;
                for (let item of _data["entityDepartmentsAdded"])
                    this.entityDepartmentsAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityDepartmentsRemoved"])) {
                this.entityDepartmentsRemoved = [] as any;
                for (let item of _data["entityDepartmentsRemoved"])
                    this.entityDepartmentsRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            this.entityClassifications = _data["entityClassifications"] ? PagedResultDtoOfAppEntityClassificationDto.fromJS(_data["entityClassifications"]) : <any>undefined;
            if (Array.isArray(_data["entityClassificationsAdded"])) {
                this.entityClassificationsAdded = [] as any;
                for (let item of _data["entityClassificationsAdded"])
                    this.entityClassificationsAdded!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassificationsRemoved"])) {
                this.entityClassificationsRemoved = [] as any;
                for (let item of _data["entityClassificationsRemoved"])
                    this.entityClassificationsRemoved!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["variationItems"])) {
                this.variationItems = [] as any;
                for (let item of _data["variationItems"])
                    this.variationItems!.push(VariationItemDto.fromJS(item));
            }
            if (Array.isArray(_data["extraDataAttr"])) {
                this.extraDataAttr = [] as any;
                for (let item of _data["extraDataAttr"])
                    this.extraDataAttr!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["recommended"])) {
                this.recommended = [] as any;
                for (let item of _data["recommended"])
                    this.recommended!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["additional"])) {
                this.additional = [] as any;
                for (let item of _data["additional"])
                    this.additional!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["appItemSizesScaleInfo"])) {
                this.appItemSizesScaleInfo = [] as any;
                for (let item of _data["appItemSizesScaleInfo"])
                    this.appItemSizesScaleInfo!.push(AppItemSizesScaleInfo.fromJS(item));
            }
            this.sycIdentifierId = _data["sycIdentifierId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemVariationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemVariationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.appItemPriceInfos)) {
            data["appItemPriceInfos"] = [];
            for (let item of this.appItemPriceInfos)
                data["appItemPriceInfos"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["entityId"] = this.entityId;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockAvailability"] = this.stockAvailability;
        data["status"] = this.status;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeName"] = this.entityObjectTypeName;
        data["itemType"] = this.itemType;
        data["sharingLevel"] = this.sharingLevel;
        data["parentId"] = this.parentId;
        data["listingItemId"] = this.listingItemId;
        data["published"] = this.published;
        data["listed"] = this.listed;
        if (Array.isArray(this.itemSharing)) {
            data["itemSharing"] = [];
            for (let item of this.itemSharing)
                data["itemSharing"].push(item.toJSON());
        }
        data["entityCategories"] = this.entityCategories ? this.entityCategories.toJSON() : <any>undefined;
        if (Array.isArray(this.entityCategoriesAdded)) {
            data["entityCategoriesAdded"] = [];
            for (let item of this.entityCategoriesAdded)
                data["entityCategoriesAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategoriesRemoved)) {
            data["entityCategoriesRemoved"] = [];
            for (let item of this.entityCategoriesRemoved)
                data["entityCategoriesRemoved"].push(item.toJSON());
        }
        data["entityDepartments"] = this.entityDepartments ? this.entityDepartments.toJSON() : <any>undefined;
        if (Array.isArray(this.entityDepartmentsAdded)) {
            data["entityDepartmentsAdded"] = [];
            for (let item of this.entityDepartmentsAdded)
                data["entityDepartmentsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityDepartmentsRemoved)) {
            data["entityDepartmentsRemoved"] = [];
            for (let item of this.entityDepartmentsRemoved)
                data["entityDepartmentsRemoved"].push(item.toJSON());
        }
        data["entityClassifications"] = this.entityClassifications ? this.entityClassifications.toJSON() : <any>undefined;
        if (Array.isArray(this.entityClassificationsAdded)) {
            data["entityClassificationsAdded"] = [];
            for (let item of this.entityClassificationsAdded)
                data["entityClassificationsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassificationsRemoved)) {
            data["entityClassificationsRemoved"] = [];
            for (let item of this.entityClassificationsRemoved)
                data["entityClassificationsRemoved"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.variationItems)) {
            data["variationItems"] = [];
            for (let item of this.variationItems)
                data["variationItems"].push(item.toJSON());
        }
        if (Array.isArray(this.extraDataAttr)) {
            data["extraDataAttr"] = [];
            for (let item of this.extraDataAttr)
                data["extraDataAttr"].push(item.toJSON());
        }
        if (Array.isArray(this.recommended)) {
            data["recommended"] = [];
            for (let item of this.recommended)
                data["recommended"].push(item.toJSON());
        }
        if (Array.isArray(this.additional)) {
            data["additional"] = [];
            for (let item of this.additional)
                data["additional"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        if (Array.isArray(this.appItemSizesScaleInfo)) {
            data["appItemSizesScaleInfo"] = [];
            for (let item of this.appItemSizesScaleInfo)
                data["appItemSizesScaleInfo"].push(item.toJSON());
        }
        data["sycIdentifierId"] = this.sycIdentifierId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemVariationsDto {
    appItemPriceInfos: AppItemPriceInfo[] | undefined;
    code: string | undefined;
    name: string | undefined;
    entityId: number;
    description: string | undefined;
    price: number;
    stockAvailability: number;
    status: string | undefined;
    entityObjectTypeId: number;
    entityObjectTypeName: string | undefined;
    itemType: number;
    sharingLevel: number;
    parentId: number | undefined;
    listingItemId: number | undefined;
    published: boolean;
    listed: boolean;
    itemSharing: ItemSharingDto[] | undefined;
    entityCategories: PagedResultDtoOfAppEntityCategoryDto;
    entityCategoriesAdded: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved: AppEntityCategoryDto[] | undefined;
    entityDepartments: PagedResultDtoOfAppEntityCategoryDto;
    entityDepartmentsAdded: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved: AppEntityCategoryDto[] | undefined;
    entityClassifications: PagedResultDtoOfAppEntityClassificationDto;
    entityClassificationsAdded: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    variationItems: VariationItemDto[] | undefined;
    extraDataAttr: ExtraDataAttrDto[] | undefined;
    recommended: ExtraDataAttrDto[] | undefined;
    additional: ExtraDataAttrDto[] | undefined;
    variations: ExtraDataAttrDto[] | undefined;
    appItemSizesScaleInfo: AppItemSizesScaleInfo[] | undefined;
    sycIdentifierId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AppItemAttributePriceDto implements IAppItemAttributePriceDto {
    appItemCode!: string | undefined;
    appItemId!: number;
    attibuteCode!: string | undefined;
    attributeValue!: string | undefined;
    price!: number;

    [key: string]: any;

    constructor(data?: IAppItemAttributePriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItemCode = _data["appItemCode"];
            this.appItemId = _data["appItemId"];
            this.attibuteCode = _data["attibuteCode"];
            this.attributeValue = _data["attributeValue"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): AppItemAttributePriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemAttributePriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItemCode"] = this.appItemCode;
        data["appItemId"] = this.appItemId;
        data["attibuteCode"] = this.attibuteCode;
        data["attributeValue"] = this.attributeValue;
        data["price"] = this.price;
        return data;
    }
}

export interface IAppItemAttributePriceDto {
    appItemCode: string | undefined;
    appItemId: number;
    attibuteCode: string | undefined;
    attributeValue: string | undefined;
    price: number;

    [key: string]: any;
}

export enum RecommandedOrAdditional {
    RECOMMENDED = 0,
    ADDITIONAL = 1,
}

export class ExtraAttribute implements IExtraAttribute {
    attributeId!: number;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    dataType!: string | undefined;
    width!: string | undefined;
    decimals!: number;
    defaultValue!: string | undefined;
    usage!: string | undefined;
    isLookup!: boolean;
    entityObjectTypeCode!: string | undefined;
    acceptMultipleValues!: boolean;
    validEntries!: string | undefined;
    isVariation!: boolean;
    isAdvancedSearch!: boolean;
    allowAddNew!: boolean;

    [key: string]: any;

    constructor(data?: IExtraAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.attributeId = _data["attributeId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataType = _data["dataType"];
            this.width = _data["width"];
            this.decimals = _data["decimals"];
            this.defaultValue = _data["defaultValue"];
            this.usage = _data["usage"];
            this.isLookup = _data["isLookup"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.acceptMultipleValues = _data["acceptMultipleValues"];
            this.validEntries = _data["validEntries"];
            this.isVariation = _data["isVariation"];
            this.isAdvancedSearch = _data["isAdvancedSearch"];
            this.allowAddNew = _data["allowAddNew"];
        }
    }

    static fromJS(data: any): ExtraAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["attributeId"] = this.attributeId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataType"] = this.dataType;
        data["width"] = this.width;
        data["decimals"] = this.decimals;
        data["defaultValue"] = this.defaultValue;
        data["usage"] = this.usage;
        data["isLookup"] = this.isLookup;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["acceptMultipleValues"] = this.acceptMultipleValues;
        data["validEntries"] = this.validEntries;
        data["isVariation"] = this.isVariation;
        data["isAdvancedSearch"] = this.isAdvancedSearch;
        data["allowAddNew"] = this.allowAddNew;
        return data;
    }
}

export interface IExtraAttribute {
    attributeId: number;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    dataType: string | undefined;
    width: string | undefined;
    decimals: number;
    defaultValue: string | undefined;
    usage: string | undefined;
    isLookup: boolean;
    entityObjectTypeCode: string | undefined;
    acceptMultipleValues: boolean;
    validEntries: string | undefined;
    isVariation: boolean;
    isAdvancedSearch: boolean;
    allowAddNew: boolean;

    [key: string]: any;
}

export class AppItemForViewDto implements IAppItemForViewDto {
    shipDate!: string;
    soldOutDate!: string;
    materialContent!: string | undefined;
    maxPrice!: number;
    minPrice!: number;
    totalCategory!: number;
    totalClassification!: number;
    totalDepartment!: number;
    entityCategoriesNames!: PagedResultDtoOfString;
    entityDepartmentsNames!: PagedResultDtoOfString;
    entityClassificationsNames!: PagedResultDtoOfString;
    extraAttributesVar!: ExtraAttribute[] | undefined;
    showSync!: boolean;
    lastModifiedDate!: moment.Moment;
    numberOfSubscribers!: number;
    code!: string | undefined;
    name!: string | undefined;
    entityId!: number;
    description!: string | undefined;
    price!: number;
    stockAvailability!: number;
    status!: string | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeName!: string | undefined;
    itemType!: number;
    sharingLevel!: number;
    parentId!: number | undefined;
    listingItemId!: number | undefined;
    published!: boolean;
    listed!: boolean;
    itemSharing!: ItemSharingDto[] | undefined;
    entityCategories!: PagedResultDtoOfAppEntityCategoryDto;
    entityCategoriesAdded!: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved!: AppEntityCategoryDto[] | undefined;
    entityDepartments!: PagedResultDtoOfAppEntityCategoryDto;
    entityDepartmentsAdded!: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: PagedResultDtoOfAppEntityClassificationDto;
    entityClassificationsAdded!: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    variationItems!: VariationItemDto[] | undefined;
    extraDataAttr!: ExtraDataAttrDto[] | undefined;
    recommended!: ExtraDataAttrDto[] | undefined;
    additional!: ExtraDataAttrDto[] | undefined;
    variations!: ExtraDataAttrDto[] | undefined;
    appItemPriceInfos!: AppItemPriceInfo[] | undefined;
    appItemSizesScaleInfo!: AppItemSizesScaleInfo[] | undefined;
    sycIdentifierId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.shipDate = _data["shipDate"];
            this.soldOutDate = _data["soldOutDate"];
            this.materialContent = _data["materialContent"];
            this.maxPrice = _data["maxPrice"];
            this.minPrice = _data["minPrice"];
            this.totalCategory = _data["totalCategory"];
            this.totalClassification = _data["totalClassification"];
            this.totalDepartment = _data["totalDepartment"];
            this.entityCategoriesNames = _data["entityCategoriesNames"] ? PagedResultDtoOfString.fromJS(_data["entityCategoriesNames"]) : <any>undefined;
            this.entityDepartmentsNames = _data["entityDepartmentsNames"] ? PagedResultDtoOfString.fromJS(_data["entityDepartmentsNames"]) : <any>undefined;
            this.entityClassificationsNames = _data["entityClassificationsNames"] ? PagedResultDtoOfString.fromJS(_data["entityClassificationsNames"]) : <any>undefined;
            if (Array.isArray(_data["extraAttributesVar"])) {
                this.extraAttributesVar = [] as any;
                for (let item of _data["extraAttributesVar"])
                    this.extraAttributesVar!.push(ExtraAttribute.fromJS(item));
            }
            this.showSync = _data["showSync"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? moment(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.numberOfSubscribers = _data["numberOfSubscribers"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.entityId = _data["entityId"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockAvailability = _data["stockAvailability"];
            this.status = _data["status"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeName = _data["entityObjectTypeName"];
            this.itemType = _data["itemType"];
            this.sharingLevel = _data["sharingLevel"];
            this.parentId = _data["parentId"];
            this.listingItemId = _data["listingItemId"];
            this.published = _data["published"];
            this.listed = _data["listed"];
            if (Array.isArray(_data["itemSharing"])) {
                this.itemSharing = [] as any;
                for (let item of _data["itemSharing"])
                    this.itemSharing!.push(ItemSharingDto.fromJS(item));
            }
            this.entityCategories = _data["entityCategories"] ? PagedResultDtoOfAppEntityCategoryDto.fromJS(_data["entityCategories"]) : <any>undefined;
            if (Array.isArray(_data["entityCategoriesAdded"])) {
                this.entityCategoriesAdded = [] as any;
                for (let item of _data["entityCategoriesAdded"])
                    this.entityCategoriesAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategoriesRemoved"])) {
                this.entityCategoriesRemoved = [] as any;
                for (let item of _data["entityCategoriesRemoved"])
                    this.entityCategoriesRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            this.entityDepartments = _data["entityDepartments"] ? PagedResultDtoOfAppEntityCategoryDto.fromJS(_data["entityDepartments"]) : <any>undefined;
            if (Array.isArray(_data["entityDepartmentsAdded"])) {
                this.entityDepartmentsAdded = [] as any;
                for (let item of _data["entityDepartmentsAdded"])
                    this.entityDepartmentsAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityDepartmentsRemoved"])) {
                this.entityDepartmentsRemoved = [] as any;
                for (let item of _data["entityDepartmentsRemoved"])
                    this.entityDepartmentsRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            this.entityClassifications = _data["entityClassifications"] ? PagedResultDtoOfAppEntityClassificationDto.fromJS(_data["entityClassifications"]) : <any>undefined;
            if (Array.isArray(_data["entityClassificationsAdded"])) {
                this.entityClassificationsAdded = [] as any;
                for (let item of _data["entityClassificationsAdded"])
                    this.entityClassificationsAdded!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassificationsRemoved"])) {
                this.entityClassificationsRemoved = [] as any;
                for (let item of _data["entityClassificationsRemoved"])
                    this.entityClassificationsRemoved!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["variationItems"])) {
                this.variationItems = [] as any;
                for (let item of _data["variationItems"])
                    this.variationItems!.push(VariationItemDto.fromJS(item));
            }
            if (Array.isArray(_data["extraDataAttr"])) {
                this.extraDataAttr = [] as any;
                for (let item of _data["extraDataAttr"])
                    this.extraDataAttr!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["recommended"])) {
                this.recommended = [] as any;
                for (let item of _data["recommended"])
                    this.recommended!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["additional"])) {
                this.additional = [] as any;
                for (let item of _data["additional"])
                    this.additional!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["appItemPriceInfos"])) {
                this.appItemPriceInfos = [] as any;
                for (let item of _data["appItemPriceInfos"])
                    this.appItemPriceInfos!.push(AppItemPriceInfo.fromJS(item));
            }
            if (Array.isArray(_data["appItemSizesScaleInfo"])) {
                this.appItemSizesScaleInfo = [] as any;
                for (let item of _data["appItemSizesScaleInfo"])
                    this.appItemSizesScaleInfo!.push(AppItemSizesScaleInfo.fromJS(item));
            }
            this.sycIdentifierId = _data["sycIdentifierId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["shipDate"] = this.shipDate;
        data["soldOutDate"] = this.soldOutDate;
        data["materialContent"] = this.materialContent;
        data["maxPrice"] = this.maxPrice;
        data["minPrice"] = this.minPrice;
        data["totalCategory"] = this.totalCategory;
        data["totalClassification"] = this.totalClassification;
        data["totalDepartment"] = this.totalDepartment;
        data["entityCategoriesNames"] = this.entityCategoriesNames ? this.entityCategoriesNames.toJSON() : <any>undefined;
        data["entityDepartmentsNames"] = this.entityDepartmentsNames ? this.entityDepartmentsNames.toJSON() : <any>undefined;
        data["entityClassificationsNames"] = this.entityClassificationsNames ? this.entityClassificationsNames.toJSON() : <any>undefined;
        if (Array.isArray(this.extraAttributesVar)) {
            data["extraAttributesVar"] = [];
            for (let item of this.extraAttributesVar)
                data["extraAttributesVar"].push(item.toJSON());
        }
        data["showSync"] = this.showSync;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["numberOfSubscribers"] = this.numberOfSubscribers;
        data["code"] = this.code;
        data["name"] = this.name;
        data["entityId"] = this.entityId;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockAvailability"] = this.stockAvailability;
        data["status"] = this.status;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeName"] = this.entityObjectTypeName;
        data["itemType"] = this.itemType;
        data["sharingLevel"] = this.sharingLevel;
        data["parentId"] = this.parentId;
        data["listingItemId"] = this.listingItemId;
        data["published"] = this.published;
        data["listed"] = this.listed;
        if (Array.isArray(this.itemSharing)) {
            data["itemSharing"] = [];
            for (let item of this.itemSharing)
                data["itemSharing"].push(item.toJSON());
        }
        data["entityCategories"] = this.entityCategories ? this.entityCategories.toJSON() : <any>undefined;
        if (Array.isArray(this.entityCategoriesAdded)) {
            data["entityCategoriesAdded"] = [];
            for (let item of this.entityCategoriesAdded)
                data["entityCategoriesAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategoriesRemoved)) {
            data["entityCategoriesRemoved"] = [];
            for (let item of this.entityCategoriesRemoved)
                data["entityCategoriesRemoved"].push(item.toJSON());
        }
        data["entityDepartments"] = this.entityDepartments ? this.entityDepartments.toJSON() : <any>undefined;
        if (Array.isArray(this.entityDepartmentsAdded)) {
            data["entityDepartmentsAdded"] = [];
            for (let item of this.entityDepartmentsAdded)
                data["entityDepartmentsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityDepartmentsRemoved)) {
            data["entityDepartmentsRemoved"] = [];
            for (let item of this.entityDepartmentsRemoved)
                data["entityDepartmentsRemoved"].push(item.toJSON());
        }
        data["entityClassifications"] = this.entityClassifications ? this.entityClassifications.toJSON() : <any>undefined;
        if (Array.isArray(this.entityClassificationsAdded)) {
            data["entityClassificationsAdded"] = [];
            for (let item of this.entityClassificationsAdded)
                data["entityClassificationsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassificationsRemoved)) {
            data["entityClassificationsRemoved"] = [];
            for (let item of this.entityClassificationsRemoved)
                data["entityClassificationsRemoved"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.variationItems)) {
            data["variationItems"] = [];
            for (let item of this.variationItems)
                data["variationItems"].push(item.toJSON());
        }
        if (Array.isArray(this.extraDataAttr)) {
            data["extraDataAttr"] = [];
            for (let item of this.extraDataAttr)
                data["extraDataAttr"].push(item.toJSON());
        }
        if (Array.isArray(this.recommended)) {
            data["recommended"] = [];
            for (let item of this.recommended)
                data["recommended"].push(item.toJSON());
        }
        if (Array.isArray(this.additional)) {
            data["additional"] = [];
            for (let item of this.additional)
                data["additional"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        if (Array.isArray(this.appItemPriceInfos)) {
            data["appItemPriceInfos"] = [];
            for (let item of this.appItemPriceInfos)
                data["appItemPriceInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.appItemSizesScaleInfo)) {
            data["appItemSizesScaleInfo"] = [];
            for (let item of this.appItemSizesScaleInfo)
                data["appItemSizesScaleInfo"].push(item.toJSON());
        }
        data["sycIdentifierId"] = this.sycIdentifierId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemForViewDto {
    shipDate: string;
    soldOutDate: string;
    materialContent: string | undefined;
    maxPrice: number;
    minPrice: number;
    totalCategory: number;
    totalClassification: number;
    totalDepartment: number;
    entityCategoriesNames: PagedResultDtoOfString;
    entityDepartmentsNames: PagedResultDtoOfString;
    entityClassificationsNames: PagedResultDtoOfString;
    extraAttributesVar: ExtraAttribute[] | undefined;
    showSync: boolean;
    lastModifiedDate: moment.Moment;
    numberOfSubscribers: number;
    code: string | undefined;
    name: string | undefined;
    entityId: number;
    description: string | undefined;
    price: number;
    stockAvailability: number;
    status: string | undefined;
    entityObjectTypeId: number;
    entityObjectTypeName: string | undefined;
    itemType: number;
    sharingLevel: number;
    parentId: number | undefined;
    listingItemId: number | undefined;
    published: boolean;
    listed: boolean;
    itemSharing: ItemSharingDto[] | undefined;
    entityCategories: PagedResultDtoOfAppEntityCategoryDto;
    entityCategoriesAdded: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved: AppEntityCategoryDto[] | undefined;
    entityDepartments: PagedResultDtoOfAppEntityCategoryDto;
    entityDepartmentsAdded: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved: AppEntityCategoryDto[] | undefined;
    entityClassifications: PagedResultDtoOfAppEntityClassificationDto;
    entityClassificationsAdded: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    variationItems: VariationItemDto[] | undefined;
    extraDataAttr: ExtraDataAttrDto[] | undefined;
    recommended: ExtraDataAttrDto[] | undefined;
    additional: ExtraDataAttrDto[] | undefined;
    variations: ExtraDataAttrDto[] | undefined;
    appItemPriceInfos: AppItemPriceInfo[] | undefined;
    appItemSizesScaleInfo: AppItemSizesScaleInfo[] | undefined;
    sycIdentifierId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppItemDetailForViewDto implements IGetAppItemDetailForViewDto {
    appItem!: AppItemForViewDto;

    [key: string]: any;

    constructor(data?: IGetAppItemDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItem = _data["appItem"] ? AppItemForViewDto.fromJS(_data["appItem"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppItemDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppItemDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItem"] = this.appItem ? this.appItem.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppItemDetailForViewDto {
    appItem: AppItemForViewDto;

    [key: string]: any;
}

export class PagedResultDtoOfExtraDataAttrDto implements IPagedResultDtoOfExtraDataAttrDto {
    totalCount!: number;
    items!: ExtraDataAttrDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfExtraDataAttrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExtraDataAttrDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExtraDataAttrDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExtraDataAttrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfExtraDataAttrDto {
    totalCount: number;
    items: ExtraDataAttrDto[] | undefined;

    [key: string]: any;
}

export class AppItemForEditDto implements IAppItemForEditDto {
    code!: string | undefined;
    name!: string | undefined;
    entityId!: number;
    description!: string | undefined;
    price!: number;
    stockAvailability!: number;
    status!: string | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeName!: string | undefined;
    itemType!: number;
    sharingLevel!: number;
    parentId!: number | undefined;
    listingItemId!: number | undefined;
    published!: boolean;
    listed!: boolean;
    itemSharing!: ItemSharingDto[] | undefined;
    entityCategories!: PagedResultDtoOfAppEntityCategoryDto;
    entityCategoriesAdded!: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved!: AppEntityCategoryDto[] | undefined;
    entityDepartments!: PagedResultDtoOfAppEntityCategoryDto;
    entityDepartmentsAdded!: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: PagedResultDtoOfAppEntityClassificationDto;
    entityClassificationsAdded!: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    variationItems!: VariationItemDto[] | undefined;
    extraDataAttr!: ExtraDataAttrDto[] | undefined;
    recommended!: ExtraDataAttrDto[] | undefined;
    additional!: ExtraDataAttrDto[] | undefined;
    variations!: ExtraDataAttrDto[] | undefined;
    appItemPriceInfos!: AppItemPriceInfo[] | undefined;
    appItemSizesScaleInfo!: AppItemSizesScaleInfo[] | undefined;
    sycIdentifierId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.entityId = _data["entityId"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockAvailability = _data["stockAvailability"];
            this.status = _data["status"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeName = _data["entityObjectTypeName"];
            this.itemType = _data["itemType"];
            this.sharingLevel = _data["sharingLevel"];
            this.parentId = _data["parentId"];
            this.listingItemId = _data["listingItemId"];
            this.published = _data["published"];
            this.listed = _data["listed"];
            if (Array.isArray(_data["itemSharing"])) {
                this.itemSharing = [] as any;
                for (let item of _data["itemSharing"])
                    this.itemSharing!.push(ItemSharingDto.fromJS(item));
            }
            this.entityCategories = _data["entityCategories"] ? PagedResultDtoOfAppEntityCategoryDto.fromJS(_data["entityCategories"]) : <any>undefined;
            if (Array.isArray(_data["entityCategoriesAdded"])) {
                this.entityCategoriesAdded = [] as any;
                for (let item of _data["entityCategoriesAdded"])
                    this.entityCategoriesAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategoriesRemoved"])) {
                this.entityCategoriesRemoved = [] as any;
                for (let item of _data["entityCategoriesRemoved"])
                    this.entityCategoriesRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            this.entityDepartments = _data["entityDepartments"] ? PagedResultDtoOfAppEntityCategoryDto.fromJS(_data["entityDepartments"]) : <any>undefined;
            if (Array.isArray(_data["entityDepartmentsAdded"])) {
                this.entityDepartmentsAdded = [] as any;
                for (let item of _data["entityDepartmentsAdded"])
                    this.entityDepartmentsAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityDepartmentsRemoved"])) {
                this.entityDepartmentsRemoved = [] as any;
                for (let item of _data["entityDepartmentsRemoved"])
                    this.entityDepartmentsRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            this.entityClassifications = _data["entityClassifications"] ? PagedResultDtoOfAppEntityClassificationDto.fromJS(_data["entityClassifications"]) : <any>undefined;
            if (Array.isArray(_data["entityClassificationsAdded"])) {
                this.entityClassificationsAdded = [] as any;
                for (let item of _data["entityClassificationsAdded"])
                    this.entityClassificationsAdded!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassificationsRemoved"])) {
                this.entityClassificationsRemoved = [] as any;
                for (let item of _data["entityClassificationsRemoved"])
                    this.entityClassificationsRemoved!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["variationItems"])) {
                this.variationItems = [] as any;
                for (let item of _data["variationItems"])
                    this.variationItems!.push(VariationItemDto.fromJS(item));
            }
            if (Array.isArray(_data["extraDataAttr"])) {
                this.extraDataAttr = [] as any;
                for (let item of _data["extraDataAttr"])
                    this.extraDataAttr!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["recommended"])) {
                this.recommended = [] as any;
                for (let item of _data["recommended"])
                    this.recommended!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["additional"])) {
                this.additional = [] as any;
                for (let item of _data["additional"])
                    this.additional!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["appItemPriceInfos"])) {
                this.appItemPriceInfos = [] as any;
                for (let item of _data["appItemPriceInfos"])
                    this.appItemPriceInfos!.push(AppItemPriceInfo.fromJS(item));
            }
            if (Array.isArray(_data["appItemSizesScaleInfo"])) {
                this.appItemSizesScaleInfo = [] as any;
                for (let item of _data["appItemSizesScaleInfo"])
                    this.appItemSizesScaleInfo!.push(AppItemSizesScaleInfo.fromJS(item));
            }
            this.sycIdentifierId = _data["sycIdentifierId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["entityId"] = this.entityId;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockAvailability"] = this.stockAvailability;
        data["status"] = this.status;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeName"] = this.entityObjectTypeName;
        data["itemType"] = this.itemType;
        data["sharingLevel"] = this.sharingLevel;
        data["parentId"] = this.parentId;
        data["listingItemId"] = this.listingItemId;
        data["published"] = this.published;
        data["listed"] = this.listed;
        if (Array.isArray(this.itemSharing)) {
            data["itemSharing"] = [];
            for (let item of this.itemSharing)
                data["itemSharing"].push(item.toJSON());
        }
        data["entityCategories"] = this.entityCategories ? this.entityCategories.toJSON() : <any>undefined;
        if (Array.isArray(this.entityCategoriesAdded)) {
            data["entityCategoriesAdded"] = [];
            for (let item of this.entityCategoriesAdded)
                data["entityCategoriesAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategoriesRemoved)) {
            data["entityCategoriesRemoved"] = [];
            for (let item of this.entityCategoriesRemoved)
                data["entityCategoriesRemoved"].push(item.toJSON());
        }
        data["entityDepartments"] = this.entityDepartments ? this.entityDepartments.toJSON() : <any>undefined;
        if (Array.isArray(this.entityDepartmentsAdded)) {
            data["entityDepartmentsAdded"] = [];
            for (let item of this.entityDepartmentsAdded)
                data["entityDepartmentsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityDepartmentsRemoved)) {
            data["entityDepartmentsRemoved"] = [];
            for (let item of this.entityDepartmentsRemoved)
                data["entityDepartmentsRemoved"].push(item.toJSON());
        }
        data["entityClassifications"] = this.entityClassifications ? this.entityClassifications.toJSON() : <any>undefined;
        if (Array.isArray(this.entityClassificationsAdded)) {
            data["entityClassificationsAdded"] = [];
            for (let item of this.entityClassificationsAdded)
                data["entityClassificationsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassificationsRemoved)) {
            data["entityClassificationsRemoved"] = [];
            for (let item of this.entityClassificationsRemoved)
                data["entityClassificationsRemoved"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.variationItems)) {
            data["variationItems"] = [];
            for (let item of this.variationItems)
                data["variationItems"].push(item.toJSON());
        }
        if (Array.isArray(this.extraDataAttr)) {
            data["extraDataAttr"] = [];
            for (let item of this.extraDataAttr)
                data["extraDataAttr"].push(item.toJSON());
        }
        if (Array.isArray(this.recommended)) {
            data["recommended"] = [];
            for (let item of this.recommended)
                data["recommended"].push(item.toJSON());
        }
        if (Array.isArray(this.additional)) {
            data["additional"] = [];
            for (let item of this.additional)
                data["additional"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        if (Array.isArray(this.appItemPriceInfos)) {
            data["appItemPriceInfos"] = [];
            for (let item of this.appItemPriceInfos)
                data["appItemPriceInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.appItemSizesScaleInfo)) {
            data["appItemSizesScaleInfo"] = [];
            for (let item of this.appItemSizesScaleInfo)
                data["appItemSizesScaleInfo"].push(item.toJSON());
        }
        data["sycIdentifierId"] = this.sycIdentifierId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemForEditDto {
    code: string | undefined;
    name: string | undefined;
    entityId: number;
    description: string | undefined;
    price: number;
    stockAvailability: number;
    status: string | undefined;
    entityObjectTypeId: number;
    entityObjectTypeName: string | undefined;
    itemType: number;
    sharingLevel: number;
    parentId: number | undefined;
    listingItemId: number | undefined;
    published: boolean;
    listed: boolean;
    itemSharing: ItemSharingDto[] | undefined;
    entityCategories: PagedResultDtoOfAppEntityCategoryDto;
    entityCategoriesAdded: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved: AppEntityCategoryDto[] | undefined;
    entityDepartments: PagedResultDtoOfAppEntityCategoryDto;
    entityDepartmentsAdded: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved: AppEntityCategoryDto[] | undefined;
    entityClassifications: PagedResultDtoOfAppEntityClassificationDto;
    entityClassificationsAdded: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    variationItems: VariationItemDto[] | undefined;
    extraDataAttr: ExtraDataAttrDto[] | undefined;
    recommended: ExtraDataAttrDto[] | undefined;
    additional: ExtraDataAttrDto[] | undefined;
    variations: ExtraDataAttrDto[] | undefined;
    appItemPriceInfos: AppItemPriceInfo[] | undefined;
    appItemSizesScaleInfo: AppItemSizesScaleInfo[] | undefined;
    sycIdentifierId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppItemForEditOutput implements IGetAppItemForEditOutput {
    appItem!: AppItemForEditDto;

    [key: string]: any;

    constructor(data?: IGetAppItemForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItem = _data["appItem"] ? AppItemForEditDto.fromJS(_data["appItem"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppItemForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppItemForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItem"] = this.appItem ? this.appItem.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppItemForEditOutput {
    appItem: AppItemForEditDto;

    [key: string]: any;
}

export class CreateOrEditAppItemDto implements ICreateOrEditAppItemDto {
    code!: string | undefined;
    shipDate!: string;
    soldOutDate!: string;
    materialContent!: string | undefined;
    name!: string | undefined;
    entityId!: number;
    description!: string | undefined;
    price!: number;
    stockAvailability!: number;
    status!: string | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeName!: string | undefined;
    itemType!: number;
    sharingLevel!: number;
    parentId!: number | undefined;
    listingItemId!: number | undefined;
    published!: boolean;
    listed!: boolean;
    itemSharing!: ItemSharingDto[] | undefined;
    entityCategories!: AppEntityCategoryDto[] | undefined;
    entityCategoriesAdded!: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved!: AppEntityCategoryDto[] | undefined;
    entityDepartments!: AppEntityCategoryDto[] | undefined;
    entityDepartmentsAdded!: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: AppEntityClassificationDto[] | undefined;
    entityClassificationsAdded!: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    variationItems!: VariationItemDto[] | undefined;
    extraDataAttr!: ExtraDataAttrDto[] | undefined;
    recommended!: ExtraDataAttrDto[] | undefined;
    additional!: ExtraDataAttrDto[] | undefined;
    variations!: ExtraDataAttrDto[] | undefined;
    appItemPriceInfos!: AppItemPriceInfo[] | undefined;
    appItemSizesScaleInfo!: AppItemSizesScaleInfo[] | undefined;
    originalCode!: string | undefined;
    sycIdentifierId!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.shipDate = _data["shipDate"];
            this.soldOutDate = _data["soldOutDate"];
            this.materialContent = _data["materialContent"];
            this.name = _data["name"];
            this.entityId = _data["entityId"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockAvailability = _data["stockAvailability"];
            this.status = _data["status"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeName = _data["entityObjectTypeName"];
            this.itemType = _data["itemType"];
            this.sharingLevel = _data["sharingLevel"];
            this.parentId = _data["parentId"];
            this.listingItemId = _data["listingItemId"];
            this.published = _data["published"];
            this.listed = _data["listed"];
            if (Array.isArray(_data["itemSharing"])) {
                this.itemSharing = [] as any;
                for (let item of _data["itemSharing"])
                    this.itemSharing!.push(ItemSharingDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategories"])) {
                this.entityCategories = [] as any;
                for (let item of _data["entityCategories"])
                    this.entityCategories!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategoriesAdded"])) {
                this.entityCategoriesAdded = [] as any;
                for (let item of _data["entityCategoriesAdded"])
                    this.entityCategoriesAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategoriesRemoved"])) {
                this.entityCategoriesRemoved = [] as any;
                for (let item of _data["entityCategoriesRemoved"])
                    this.entityCategoriesRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityDepartments"])) {
                this.entityDepartments = [] as any;
                for (let item of _data["entityDepartments"])
                    this.entityDepartments!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityDepartmentsAdded"])) {
                this.entityDepartmentsAdded = [] as any;
                for (let item of _data["entityDepartmentsAdded"])
                    this.entityDepartmentsAdded!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityDepartmentsRemoved"])) {
                this.entityDepartmentsRemoved = [] as any;
                for (let item of _data["entityDepartmentsRemoved"])
                    this.entityDepartmentsRemoved!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassifications"])) {
                this.entityClassifications = [] as any;
                for (let item of _data["entityClassifications"])
                    this.entityClassifications!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassificationsAdded"])) {
                this.entityClassificationsAdded = [] as any;
                for (let item of _data["entityClassificationsAdded"])
                    this.entityClassificationsAdded!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassificationsRemoved"])) {
                this.entityClassificationsRemoved = [] as any;
                for (let item of _data["entityClassificationsRemoved"])
                    this.entityClassificationsRemoved!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["variationItems"])) {
                this.variationItems = [] as any;
                for (let item of _data["variationItems"])
                    this.variationItems!.push(VariationItemDto.fromJS(item));
            }
            if (Array.isArray(_data["extraDataAttr"])) {
                this.extraDataAttr = [] as any;
                for (let item of _data["extraDataAttr"])
                    this.extraDataAttr!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["recommended"])) {
                this.recommended = [] as any;
                for (let item of _data["recommended"])
                    this.recommended!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["additional"])) {
                this.additional = [] as any;
                for (let item of _data["additional"])
                    this.additional!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(ExtraDataAttrDto.fromJS(item));
            }
            if (Array.isArray(_data["appItemPriceInfos"])) {
                this.appItemPriceInfos = [] as any;
                for (let item of _data["appItemPriceInfos"])
                    this.appItemPriceInfos!.push(AppItemPriceInfo.fromJS(item));
            }
            if (Array.isArray(_data["appItemSizesScaleInfo"])) {
                this.appItemSizesScaleInfo = [] as any;
                for (let item of _data["appItemSizesScaleInfo"])
                    this.appItemSizesScaleInfo!.push(AppItemSizesScaleInfo.fromJS(item));
            }
            this.originalCode = _data["originalCode"];
            this.sycIdentifierId = _data["sycIdentifierId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["shipDate"] = this.shipDate;
        data["soldOutDate"] = this.soldOutDate;
        data["materialContent"] = this.materialContent;
        data["name"] = this.name;
        data["entityId"] = this.entityId;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockAvailability"] = this.stockAvailability;
        data["status"] = this.status;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeName"] = this.entityObjectTypeName;
        data["itemType"] = this.itemType;
        data["sharingLevel"] = this.sharingLevel;
        data["parentId"] = this.parentId;
        data["listingItemId"] = this.listingItemId;
        data["published"] = this.published;
        data["listed"] = this.listed;
        if (Array.isArray(this.itemSharing)) {
            data["itemSharing"] = [];
            for (let item of this.itemSharing)
                data["itemSharing"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategories)) {
            data["entityCategories"] = [];
            for (let item of this.entityCategories)
                data["entityCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategoriesAdded)) {
            data["entityCategoriesAdded"] = [];
            for (let item of this.entityCategoriesAdded)
                data["entityCategoriesAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategoriesRemoved)) {
            data["entityCategoriesRemoved"] = [];
            for (let item of this.entityCategoriesRemoved)
                data["entityCategoriesRemoved"].push(item.toJSON());
        }
        if (Array.isArray(this.entityDepartments)) {
            data["entityDepartments"] = [];
            for (let item of this.entityDepartments)
                data["entityDepartments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityDepartmentsAdded)) {
            data["entityDepartmentsAdded"] = [];
            for (let item of this.entityDepartmentsAdded)
                data["entityDepartmentsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityDepartmentsRemoved)) {
            data["entityDepartmentsRemoved"] = [];
            for (let item of this.entityDepartmentsRemoved)
                data["entityDepartmentsRemoved"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassifications)) {
            data["entityClassifications"] = [];
            for (let item of this.entityClassifications)
                data["entityClassifications"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassificationsAdded)) {
            data["entityClassificationsAdded"] = [];
            for (let item of this.entityClassificationsAdded)
                data["entityClassificationsAdded"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassificationsRemoved)) {
            data["entityClassificationsRemoved"] = [];
            for (let item of this.entityClassificationsRemoved)
                data["entityClassificationsRemoved"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.variationItems)) {
            data["variationItems"] = [];
            for (let item of this.variationItems)
                data["variationItems"].push(item.toJSON());
        }
        if (Array.isArray(this.extraDataAttr)) {
            data["extraDataAttr"] = [];
            for (let item of this.extraDataAttr)
                data["extraDataAttr"].push(item.toJSON());
        }
        if (Array.isArray(this.recommended)) {
            data["recommended"] = [];
            for (let item of this.recommended)
                data["recommended"].push(item.toJSON());
        }
        if (Array.isArray(this.additional)) {
            data["additional"] = [];
            for (let item of this.additional)
                data["additional"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        if (Array.isArray(this.appItemPriceInfos)) {
            data["appItemPriceInfos"] = [];
            for (let item of this.appItemPriceInfos)
                data["appItemPriceInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.appItemSizesScaleInfo)) {
            data["appItemSizesScaleInfo"] = [];
            for (let item of this.appItemSizesScaleInfo)
                data["appItemSizesScaleInfo"].push(item.toJSON());
        }
        data["originalCode"] = this.originalCode;
        data["sycIdentifierId"] = this.sycIdentifierId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppItemDto {
    code: string | undefined;
    shipDate: string;
    soldOutDate: string;
    materialContent: string | undefined;
    name: string | undefined;
    entityId: number;
    description: string | undefined;
    price: number;
    stockAvailability: number;
    status: string | undefined;
    entityObjectTypeId: number;
    entityObjectTypeName: string | undefined;
    itemType: number;
    sharingLevel: number;
    parentId: number | undefined;
    listingItemId: number | undefined;
    published: boolean;
    listed: boolean;
    itemSharing: ItemSharingDto[] | undefined;
    entityCategories: AppEntityCategoryDto[] | undefined;
    entityCategoriesAdded: AppEntityCategoryDto[] | undefined;
    entityCategoriesRemoved: AppEntityCategoryDto[] | undefined;
    entityDepartments: AppEntityCategoryDto[] | undefined;
    entityDepartmentsAdded: AppEntityCategoryDto[] | undefined;
    entityDepartmentsRemoved: AppEntityCategoryDto[] | undefined;
    entityClassifications: AppEntityClassificationDto[] | undefined;
    entityClassificationsAdded: AppEntityClassificationDto[] | undefined;
    entityClassificationsRemoved: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    variationItems: VariationItemDto[] | undefined;
    extraDataAttr: ExtraDataAttrDto[] | undefined;
    recommended: ExtraDataAttrDto[] | undefined;
    additional: ExtraDataAttrDto[] | undefined;
    variations: ExtraDataAttrDto[] | undefined;
    appItemPriceInfos: AppItemPriceInfo[] | undefined;
    appItemSizesScaleInfo: AppItemSizesScaleInfo[] | undefined;
    originalCode: string | undefined;
    sycIdentifierId: number;
    id: number;

    [key: string]: any;
}

export class PublishItemOptions implements IPublishItemOptions {
    listingItemId!: number | undefined;
    itemListId!: number;
    sharingLevel!: number;
    message!: string | undefined;
    itemSharing!: ItemSharingDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPublishItemOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.listingItemId = _data["listingItemId"];
            this.itemListId = _data["itemListId"];
            this.sharingLevel = _data["sharingLevel"];
            this.message = _data["message"];
            if (Array.isArray(_data["itemSharing"])) {
                this.itemSharing = [] as any;
                for (let item of _data["itemSharing"])
                    this.itemSharing!.push(ItemSharingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublishItemOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PublishItemOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["listingItemId"] = this.listingItemId;
        data["itemListId"] = this.itemListId;
        data["sharingLevel"] = this.sharingLevel;
        data["message"] = this.message;
        if (Array.isArray(this.itemSharing)) {
            data["itemSharing"] = [];
            for (let item of this.itemSharing)
                data["itemSharing"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPublishItemOptions {
    listingItemId: number | undefined;
    itemListId: number;
    sharingLevel: number;
    message: string | undefined;
    itemSharing: ItemSharingDto[] | undefined;

    [key: string]: any;
}

export class SharingItemOptions implements ISharingItemOptions {
    appItemId!: number;
    syncProduct!: boolean;
    sharingLevel!: number;
    message!: string | undefined;
    itemSharing!: ItemSharingDto[] | undefined;

    [key: string]: any;

    constructor(data?: ISharingItemOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItemId = _data["appItemId"];
            this.syncProduct = _data["syncProduct"];
            this.sharingLevel = _data["sharingLevel"];
            this.message = _data["message"];
            if (Array.isArray(_data["itemSharing"])) {
                this.itemSharing = [] as any;
                for (let item of _data["itemSharing"])
                    this.itemSharing!.push(ItemSharingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SharingItemOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SharingItemOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItemId"] = this.appItemId;
        data["syncProduct"] = this.syncProduct;
        data["sharingLevel"] = this.sharingLevel;
        data["message"] = this.message;
        if (Array.isArray(this.itemSharing)) {
            data["itemSharing"] = [];
            for (let item of this.itemSharing)
                data["itemSharing"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISharingItemOptions {
    appItemId: number;
    syncProduct: boolean;
    sharingLevel: number;
    message: string | undefined;
    itemSharing: ItemSharingDto[] | undefined;

    [key: string]: any;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    [key: string]: any;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfInt64 {
    id: number;

    [key: string]: any;
}

export enum StateEnum {
    ToBeAdded = 0,
    ToBeRemoved = 1,
    ActiveOrEmpty = 2,
}

export class AppItemVariationDto implements IAppItemVariationDto {
    itemId!: number;
    itemCode!: string | undefined;
    itemName!: string | undefined;
    price!: number;
    imgURL!: string | undefined;
    itemSSIN!: string | undefined;
    state!: StateEnum;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemVariationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.itemId = _data["itemId"];
            this.itemCode = _data["itemCode"];
            this.itemName = _data["itemName"];
            this.price = _data["price"];
            this.imgURL = _data["imgURL"];
            this.itemSSIN = _data["itemSSIN"];
            this.state = _data["state"];
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemVariationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemVariationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["itemName"] = this.itemName;
        data["price"] = this.price;
        data["imgURL"] = this.imgURL;
        data["itemSSIN"] = this.itemSSIN;
        data["state"] = this.state;
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemVariationDto {
    itemId: number;
    itemCode: string | undefined;
    itemName: string | undefined;
    price: number;
    imgURL: string | undefined;
    itemSSIN: string | undefined;
    state: StateEnum;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    id: number;

    [key: string]: any;
}

export class AppItemImpExtrAttributes implements IAppItemImpExtrAttributes {
    name!: string | undefined;
    code!: string | undefined;
    value!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppItemImpExtrAttributes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AppItemImpExtrAttributes {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemImpExtrAttributes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["value"] = this.value;
        return data;
    }
}

export interface IAppItemImpExtrAttributes {
    name: string | undefined;
    code: string | undefined;
    value: string | undefined;

    [key: string]: any;
}

export class AppItemImage implements IAppItemImage {
    imageFileName!: string | undefined;
    imageGuid!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppItemImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.imageFileName = _data["imageFileName"];
            this.imageGuid = _data["imageGuid"];
        }
    }

    static fromJS(data: any): AppItemImage {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["imageFileName"] = this.imageFileName;
        data["imageGuid"] = this.imageGuid;
        return data;
    }
}

export interface IAppItemImage {
    imageFileName: string | undefined;
    imageGuid: string | undefined;

    [key: string]: any;
}

export class AppItemExcelDto implements IAppItemExcelDto {
    id!: number;
    rowNumber!: number;
    recordType!: string;
    productType!: string;
    productClassificationCode!: string | undefined;
    productClassificationDescription!: string | undefined;
    productCategoryCode!: string | undefined;
    productCategoryDescription!: string | undefined;
    price!: string | undefined;
    currency!: string | undefined;
    parentCode!: string | undefined;
    imageType!: string | undefined;
    imageFolderName!: string | undefined;
    parentId!: number;
    extraAttributesValues!: AppItemImpExtrAttributes[] | undefined;
    extraAttributes!: ExtraAttribute[] | undefined;
    images!: AppItemImage[] | undefined;
    code!: string;
    name!: string;
    productDescription!: string;
    entityObjectClassificaionID!: number | undefined;
    entityObjectCategoryID!: number | undefined;
    sizeScaleName!: string | undefined;
    scaleSizesOrder!: string | undefined;
    sizeRatioName!: string | undefined;
    sizeRatioValue!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppItemExcelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.rowNumber = _data["rowNumber"];
            this.recordType = _data["recordType"];
            this.productType = _data["productType"];
            this.productClassificationCode = _data["productClassificationCode"];
            this.productClassificationDescription = _data["productClassificationDescription"];
            this.productCategoryCode = _data["productCategoryCode"];
            this.productCategoryDescription = _data["productCategoryDescription"];
            this.price = _data["price"];
            this.currency = _data["currency"];
            this.parentCode = _data["parentCode"];
            this.imageType = _data["imageType"];
            this.imageFolderName = _data["imageFolderName"];
            this.parentId = _data["parentId"];
            if (Array.isArray(_data["extraAttributesValues"])) {
                this.extraAttributesValues = [] as any;
                for (let item of _data["extraAttributesValues"])
                    this.extraAttributesValues!.push(AppItemImpExtrAttributes.fromJS(item));
            }
            if (Array.isArray(_data["extraAttributes"])) {
                this.extraAttributes = [] as any;
                for (let item of _data["extraAttributes"])
                    this.extraAttributes!.push(ExtraAttribute.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(AppItemImage.fromJS(item));
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.productDescription = _data["productDescription"];
            this.entityObjectClassificaionID = _data["entityObjectClassificaionID"];
            this.entityObjectCategoryID = _data["entityObjectCategoryID"];
            this.sizeScaleName = _data["sizeScaleName"];
            this.scaleSizesOrder = _data["scaleSizesOrder"];
            this.sizeRatioName = _data["sizeRatioName"];
            this.sizeRatioValue = _data["sizeRatioValue"];
        }
    }

    static fromJS(data: any): AppItemExcelDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemExcelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["rowNumber"] = this.rowNumber;
        data["recordType"] = this.recordType;
        data["productType"] = this.productType;
        data["productClassificationCode"] = this.productClassificationCode;
        data["productClassificationDescription"] = this.productClassificationDescription;
        data["productCategoryCode"] = this.productCategoryCode;
        data["productCategoryDescription"] = this.productCategoryDescription;
        data["price"] = this.price;
        data["currency"] = this.currency;
        data["parentCode"] = this.parentCode;
        data["imageType"] = this.imageType;
        data["imageFolderName"] = this.imageFolderName;
        data["parentId"] = this.parentId;
        if (Array.isArray(this.extraAttributesValues)) {
            data["extraAttributesValues"] = [];
            for (let item of this.extraAttributesValues)
                data["extraAttributesValues"].push(item.toJSON());
        }
        if (Array.isArray(this.extraAttributes)) {
            data["extraAttributes"] = [];
            for (let item of this.extraAttributes)
                data["extraAttributes"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["productDescription"] = this.productDescription;
        data["entityObjectClassificaionID"] = this.entityObjectClassificaionID;
        data["entityObjectCategoryID"] = this.entityObjectCategoryID;
        data["sizeScaleName"] = this.sizeScaleName;
        data["scaleSizesOrder"] = this.scaleSizesOrder;
        data["sizeRatioName"] = this.sizeRatioName;
        data["sizeRatioValue"] = this.sizeRatioValue;
        return data;
    }
}

export interface IAppItemExcelDto {
    id: number;
    rowNumber: number;
    recordType: string;
    productType: string;
    productClassificationCode: string | undefined;
    productClassificationDescription: string | undefined;
    productCategoryCode: string | undefined;
    productCategoryDescription: string | undefined;
    price: string | undefined;
    currency: string | undefined;
    parentCode: string | undefined;
    imageType: string | undefined;
    imageFolderName: string | undefined;
    parentId: number;
    extraAttributesValues: AppItemImpExtrAttributes[] | undefined;
    extraAttributes: ExtraAttribute[] | undefined;
    images: AppItemImage[] | undefined;
    code: string;
    name: string;
    productDescription: string;
    entityObjectClassificaionID: number | undefined;
    entityObjectCategoryID: number | undefined;
    sizeScaleName: string | undefined;
    scaleSizesOrder: string | undefined;
    sizeRatioName: string | undefined;
    sizeRatioValue: string | undefined;

    [key: string]: any;
}

export class AppItemtExcelRecordDTO implements IAppItemtExcelRecordDTO {
    recordType!: string | undefined;
    parentCode!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    fieldsErrors!: string[] | undefined;
    excelDto!: AppItemExcelDto;
    status!: string | undefined;
    errorMessage!: string | undefined;
    imageType!: string | undefined;
    image!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppItemtExcelRecordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.recordType = _data["recordType"];
            this.parentCode = _data["parentCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            if (Array.isArray(_data["fieldsErrors"])) {
                this.fieldsErrors = [] as any;
                for (let item of _data["fieldsErrors"])
                    this.fieldsErrors!.push(item);
            }
            this.excelDto = _data["excelDto"] ? AppItemExcelDto.fromJS(_data["excelDto"]) : <any>undefined;
            this.status = _data["status"];
            this.errorMessage = _data["errorMessage"];
            this.imageType = _data["imageType"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): AppItemtExcelRecordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemtExcelRecordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["recordType"] = this.recordType;
        data["parentCode"] = this.parentCode;
        data["code"] = this.code;
        data["name"] = this.name;
        if (Array.isArray(this.fieldsErrors)) {
            data["fieldsErrors"] = [];
            for (let item of this.fieldsErrors)
                data["fieldsErrors"].push(item);
        }
        data["excelDto"] = this.excelDto ? this.excelDto.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["errorMessage"] = this.errorMessage;
        data["imageType"] = this.imageType;
        data["image"] = this.image;
        return data;
    }
}

export interface IAppItemtExcelRecordDTO {
    recordType: string | undefined;
    parentCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
    fieldsErrors: string[] | undefined;
    excelDto: AppItemExcelDto;
    status: string | undefined;
    errorMessage: string | undefined;
    imageType: string | undefined;
    image: string | undefined;

    [key: string]: any;
}

export class AppItemExcelResultsDTO implements IAppItemExcelResultsDTO {
    excelLogDTO!: ExcelLogDto;
    totalRecords!: number;
    codesFromList!: string[] | undefined;
    fromList!: number[] | undefined;
    from!: number;
    toList!: number[] | undefined;
    to!: number;
    totalPassedRecords!: number;
    totalFailedRecords!: number;
    repreateHandler!: ExcelRecordRepeateHandler;
    excelRecords!: AppItemtExcelRecordDTO[] | undefined;
    filePath!: string | undefined;
    errorMessage!: string | undefined;
    hasDuplication!: boolean;

    [key: string]: any;

    constructor(data?: IAppItemExcelResultsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.excelLogDTO = _data["excelLogDTO"] ? ExcelLogDto.fromJS(_data["excelLogDTO"]) : <any>undefined;
            this.totalRecords = _data["totalRecords"];
            if (Array.isArray(_data["codesFromList"])) {
                this.codesFromList = [] as any;
                for (let item of _data["codesFromList"])
                    this.codesFromList!.push(item);
            }
            if (Array.isArray(_data["fromList"])) {
                this.fromList = [] as any;
                for (let item of _data["fromList"])
                    this.fromList!.push(item);
            }
            this.from = _data["from"];
            if (Array.isArray(_data["toList"])) {
                this.toList = [] as any;
                for (let item of _data["toList"])
                    this.toList!.push(item);
            }
            this.to = _data["to"];
            this.totalPassedRecords = _data["totalPassedRecords"];
            this.totalFailedRecords = _data["totalFailedRecords"];
            this.repreateHandler = _data["repreateHandler"];
            if (Array.isArray(_data["excelRecords"])) {
                this.excelRecords = [] as any;
                for (let item of _data["excelRecords"])
                    this.excelRecords!.push(AppItemtExcelRecordDTO.fromJS(item));
            }
            this.filePath = _data["filePath"];
            this.errorMessage = _data["errorMessage"];
            this.hasDuplication = _data["hasDuplication"];
        }
    }

    static fromJS(data: any): AppItemExcelResultsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemExcelResultsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["excelLogDTO"] = this.excelLogDTO ? this.excelLogDTO.toJSON() : <any>undefined;
        data["totalRecords"] = this.totalRecords;
        if (Array.isArray(this.codesFromList)) {
            data["codesFromList"] = [];
            for (let item of this.codesFromList)
                data["codesFromList"].push(item);
        }
        if (Array.isArray(this.fromList)) {
            data["fromList"] = [];
            for (let item of this.fromList)
                data["fromList"].push(item);
        }
        data["from"] = this.from;
        if (Array.isArray(this.toList)) {
            data["toList"] = [];
            for (let item of this.toList)
                data["toList"].push(item);
        }
        data["to"] = this.to;
        data["totalPassedRecords"] = this.totalPassedRecords;
        data["totalFailedRecords"] = this.totalFailedRecords;
        data["repreateHandler"] = this.repreateHandler;
        if (Array.isArray(this.excelRecords)) {
            data["excelRecords"] = [];
            for (let item of this.excelRecords)
                data["excelRecords"].push(item.toJSON());
        }
        data["filePath"] = this.filePath;
        data["errorMessage"] = this.errorMessage;
        data["hasDuplication"] = this.hasDuplication;
        return data;
    }
}

export interface IAppItemExcelResultsDTO {
    excelLogDTO: ExcelLogDto;
    totalRecords: number;
    codesFromList: string[] | undefined;
    fromList: number[] | undefined;
    from: number;
    toList: number[] | undefined;
    to: number;
    totalPassedRecords: number;
    totalFailedRecords: number;
    repreateHandler: ExcelRecordRepeateHandler;
    excelRecords: AppItemtExcelRecordDTO[] | undefined;
    filePath: string | undefined;
    errorMessage: string | undefined;
    hasDuplication: boolean;

    [key: string]: any;
}

export class VariationAttribute implements IVariationAttribute {
    name!: string | undefined;
    attributeId!: number;

    [key: string]: any;

    constructor(data?: IVariationAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.attributeId = _data["attributeId"];
        }
    }

    static fromJS(data: any): VariationAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new VariationAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["attributeId"] = this.attributeId;
        return data;
    }
}

export interface IVariationAttribute {
    name: string | undefined;
    attributeId: number;

    [key: string]: any;
}

export class ProductVariationsType implements IProductVariationsType {
    id!: number;
    name!: string | undefined;
    variationAttributes!: VariationAttribute[] | undefined;

    [key: string]: any;

    constructor(data?: IProductVariationsType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["variationAttributes"])) {
                this.variationAttributes = [] as any;
                for (let item of _data["variationAttributes"])
                    this.variationAttributes!.push(VariationAttribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductVariationsType {
        data = typeof data === 'object' ? data : {};
        let result = new ProductVariationsType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.variationAttributes)) {
            data["variationAttributes"] = [];
            for (let item of this.variationAttributes)
                data["variationAttributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductVariationsType {
    id: number;
    name: string | undefined;
    variationAttributes: VariationAttribute[] | undefined;

    [key: string]: any;
}

export class AppItemSelectorDto implements IAppItemSelectorDto {
    key!: string;
    selectedId!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemSelectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.selectedId = _data["selectedId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemSelectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemSelectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["selectedId"] = this.selectedId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemSelectorDto {
    key: string;
    selectedId: number;
    id: number;

    [key: string]: any;
}

export class GetAppItemSelectorForViewDto implements IGetAppItemSelectorForViewDto {
    appItemSelector!: AppItemSelectorDto;

    [key: string]: any;

    constructor(data?: IGetAppItemSelectorForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItemSelector = _data["appItemSelector"] ? AppItemSelectorDto.fromJS(_data["appItemSelector"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppItemSelectorForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppItemSelectorForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItemSelector"] = this.appItemSelector ? this.appItemSelector.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppItemSelectorForViewDto {
    appItemSelector: AppItemSelectorDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppItemSelectorForViewDto implements IPagedResultDtoOfGetAppItemSelectorForViewDto {
    totalCount!: number;
    items!: GetAppItemSelectorForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppItemSelectorForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppItemSelectorForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppItemSelectorForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppItemSelectorForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppItemSelectorForViewDto {
    totalCount: number;
    items: GetAppItemSelectorForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppItemSelectorDto implements ICreateOrEditAppItemSelectorDto {
    key!: string;
    selectedId!: number;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppItemSelectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.selectedId = _data["selectedId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppItemSelectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppItemSelectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["selectedId"] = this.selectedId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppItemSelectorDto {
    key: string;
    selectedId: number;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppItemSelectorForEditOutput implements IGetAppItemSelectorForEditOutput {
    appItemSelector!: CreateOrEditAppItemSelectorDto;

    [key: string]: any;

    constructor(data?: IGetAppItemSelectorForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItemSelector = _data["appItemSelector"] ? CreateOrEditAppItemSelectorDto.fromJS(_data["appItemSelector"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppItemSelectorForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppItemSelectorForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItemSelector"] = this.appItemSelector ? this.appItemSelector.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppItemSelectorForEditOutput {
    appItemSelector: CreateOrEditAppItemSelectorDto;

    [key: string]: any;
}

export enum ItemsListFilterTypesEnum {
    MyItemsList = 0,
    SharedWithMe = 1,
    Public = 2,
}

export class AppItemsListDto implements IAppItemsListDto {
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    sharingLevel!: number;
    published!: boolean;
    creationTime!: moment.Moment;
    creatorUserName!: string | undefined;
    imgURL!: string | undefined;
    itemsCount!: number;
    tenantId!: number | undefined;
    statusCode!: string | undefined;
    statusId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sharingLevel = _data["sharingLevel"];
            this.published = _data["published"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserName = _data["creatorUserName"];
            this.imgURL = _data["imgURL"];
            this.itemsCount = _data["itemsCount"];
            this.tenantId = _data["tenantId"];
            this.statusCode = _data["statusCode"];
            this.statusId = _data["statusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sharingLevel"] = this.sharingLevel;
        data["published"] = this.published;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserName"] = this.creatorUserName;
        data["imgURL"] = this.imgURL;
        data["itemsCount"] = this.itemsCount;
        data["tenantId"] = this.tenantId;
        data["statusCode"] = this.statusCode;
        data["statusId"] = this.statusId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemsListDto {
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    sharingLevel: number;
    published: boolean;
    creationTime: moment.Moment;
    creatorUserName: string | undefined;
    imgURL: string | undefined;
    itemsCount: number;
    tenantId: number | undefined;
    statusCode: string | undefined;
    statusId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppItemsListForViewDto implements IGetAppItemsListForViewDto {
    appItemsList!: AppItemsListDto;

    [key: string]: any;

    constructor(data?: IGetAppItemsListForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItemsList = _data["appItemsList"] ? AppItemsListDto.fromJS(_data["appItemsList"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppItemsListForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppItemsListForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItemsList"] = this.appItemsList ? this.appItemsList.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppItemsListForViewDto {
    appItemsList: AppItemsListDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppItemsListForViewDto implements IPagedResultDtoOfGetAppItemsListForViewDto {
    totalCount!: number;
    items!: GetAppItemsListForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppItemsListForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppItemsListForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppItemsListForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppItemsListForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppItemsListForViewDto {
    totalCount: number;
    items: GetAppItemsListForViewDto[] | undefined;

    [key: string]: any;
}

export class AppItemsListItemVariationDto implements IAppItemsListItemVariationDto {
    variation!: AppItemVariationDto;
    itemsListId!: number;
    itemId!: number;
    itemCode!: string | undefined;
    itemDescription!: string | undefined;
    itemName!: string | undefined;
    imageURL!: string | undefined;
    state!: StateEnum;
    itemSSIN!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppItemsListItemVariationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.variation = _data["variation"] ? AppItemVariationDto.fromJS(_data["variation"]) : <any>undefined;
            this.itemsListId = _data["itemsListId"];
            this.itemId = _data["itemId"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.itemName = _data["itemName"];
            this.imageURL = _data["imageURL"];
            this.state = _data["state"];
            this.itemSSIN = _data["itemSSIN"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppItemsListItemVariationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemsListItemVariationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["variation"] = this.variation ? this.variation.toJSON() : <any>undefined;
        data["itemsListId"] = this.itemsListId;
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["itemName"] = this.itemName;
        data["imageURL"] = this.imageURL;
        data["state"] = this.state;
        data["itemSSIN"] = this.itemSSIN;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppItemsListItemVariationDto {
    variation: AppItemVariationDto;
    itemsListId: number;
    itemId: number;
    itemCode: string | undefined;
    itemDescription: string | undefined;
    itemName: string | undefined;
    imageURL: string | undefined;
    state: StateEnum;
    itemSSIN: string | undefined;
    id: number;

    [key: string]: any;
}

export class CreateOrEditAppItemsListItemDto implements ICreateOrEditAppItemsListItemDto {
    appItemsListItemVariations!: AppItemsListItemVariationDto[] | undefined;
    itemsListId!: number;
    itemId!: number;
    itemCode!: string | undefined;
    itemDescription!: string | undefined;
    itemName!: string | undefined;
    imageURL!: string | undefined;
    state!: StateEnum;
    itemSSIN!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppItemsListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["appItemsListItemVariations"])) {
                this.appItemsListItemVariations = [] as any;
                for (let item of _data["appItemsListItemVariations"])
                    this.appItemsListItemVariations!.push(AppItemsListItemVariationDto.fromJS(item));
            }
            this.itemsListId = _data["itemsListId"];
            this.itemId = _data["itemId"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.itemName = _data["itemName"];
            this.imageURL = _data["imageURL"];
            this.state = _data["state"];
            this.itemSSIN = _data["itemSSIN"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppItemsListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppItemsListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.appItemsListItemVariations)) {
            data["appItemsListItemVariations"] = [];
            for (let item of this.appItemsListItemVariations)
                data["appItemsListItemVariations"].push(item.toJSON());
        }
        data["itemsListId"] = this.itemsListId;
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["itemName"] = this.itemName;
        data["imageURL"] = this.imageURL;
        data["state"] = this.state;
        data["itemSSIN"] = this.itemSSIN;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppItemsListItemDto {
    appItemsListItemVariations: AppItemsListItemVariationDto[] | undefined;
    itemsListId: number;
    itemId: number;
    itemCode: string | undefined;
    itemDescription: string | undefined;
    itemName: string | undefined;
    imageURL: string | undefined;
    state: StateEnum;
    itemSSIN: string | undefined;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfCreateOrEditAppItemsListItemDto implements IPagedResultDtoOfCreateOrEditAppItemsListItemDto {
    totalCount!: number;
    items!: CreateOrEditAppItemsListItemDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfCreateOrEditAppItemsListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CreateOrEditAppItemsListItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCreateOrEditAppItemsListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCreateOrEditAppItemsListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfCreateOrEditAppItemsListItemDto {
    totalCount: number;
    items: CreateOrEditAppItemsListItemDto[] | undefined;

    [key: string]: any;
}

export class UserInfoDto implements IUserInfoDto {
    id!: number;
    name!: string | undefined;
    imageURL!: string | undefined;

    [key: string]: any;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageURL = _data["imageURL"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageURL"] = this.imageURL;
        return data;
    }
}

export interface IUserInfoDto {
    id: number;
    name: string | undefined;
    imageURL: string | undefined;

    [key: string]: any;
}

export class CreateOrEditAppItemsListDto implements ICreateOrEditAppItemsListDto {
    code!: string;
    name!: string | undefined;
    description!: string | undefined;
    sharingLevel!: number;
    published!: boolean;
    creationTime!: moment.Moment;
    appItemsListItems!: PagedResultDtoOfCreateOrEditAppItemsListItemDto;
    users!: UserInfoDto[] | undefined;
    usersCount!: number;
    statusCode!: string | undefined;
    statusId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppItemsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sharingLevel = _data["sharingLevel"];
            this.published = _data["published"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.appItemsListItems = _data["appItemsListItems"] ? PagedResultDtoOfCreateOrEditAppItemsListItemDto.fromJS(_data["appItemsListItems"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserInfoDto.fromJS(item));
            }
            this.usersCount = _data["usersCount"];
            this.statusCode = _data["statusCode"];
            this.statusId = _data["statusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppItemsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppItemsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sharingLevel"] = this.sharingLevel;
        data["published"] = this.published;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["appItemsListItems"] = this.appItemsListItems ? this.appItemsListItems.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["usersCount"] = this.usersCount;
        data["statusCode"] = this.statusCode;
        data["statusId"] = this.statusId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppItemsListDto {
    code: string;
    name: string | undefined;
    description: string | undefined;
    sharingLevel: number;
    published: boolean;
    creationTime: moment.Moment;
    appItemsListItems: PagedResultDtoOfCreateOrEditAppItemsListItemDto;
    users: UserInfoDto[] | undefined;
    usersCount: number;
    statusCode: string | undefined;
    statusId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppItemsListForEditOutput implements IGetAppItemsListForEditOutput {
    appItemsList!: CreateOrEditAppItemsListDto;
    tenantId!: number | undefined;
    showSync!: boolean;
    lastModifiedDate!: moment.Moment;
    numberOfSubscribers!: number;

    [key: string]: any;

    constructor(data?: IGetAppItemsListForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appItemsList = _data["appItemsList"] ? CreateOrEditAppItemsListDto.fromJS(_data["appItemsList"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.showSync = _data["showSync"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? moment(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.numberOfSubscribers = _data["numberOfSubscribers"];
        }
    }

    static fromJS(data: any): GetAppItemsListForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppItemsListForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appItemsList"] = this.appItemsList ? this.appItemsList.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["showSync"] = this.showSync;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["numberOfSubscribers"] = this.numberOfSubscribers;
        return data;
    }
}

export interface IGetAppItemsListForEditOutput {
    appItemsList: CreateOrEditAppItemsListDto;
    tenantId: number | undefined;
    showSync: boolean;
    lastModifiedDate: moment.Moment;
    numberOfSubscribers: number;

    [key: string]: any;
}

export class GetStatusResult implements IGetStatusResult {
    name!: string | undefined;
    code!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: IGetStatusResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetStatusResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetStatusResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetStatusResult {
    name: string | undefined;
    code: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class ShareItemListOptions implements IShareItemListOptions {
    appMarketplaceItemId!: number | undefined;
    itemListId!: number;
    sharingLevel!: number;
    message!: string | undefined;
    itemSharing!: ItemSharingDto[] | undefined;
    syncProductList!: boolean;

    [key: string]: any;

    constructor(data?: IShareItemListOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appMarketplaceItemId = _data["appMarketplaceItemId"];
            this.itemListId = _data["itemListId"];
            this.sharingLevel = _data["sharingLevel"];
            this.message = _data["message"];
            if (Array.isArray(_data["itemSharing"])) {
                this.itemSharing = [] as any;
                for (let item of _data["itemSharing"])
                    this.itemSharing!.push(ItemSharingDto.fromJS(item));
            }
            this.syncProductList = _data["syncProductList"];
        }
    }

    static fromJS(data: any): ShareItemListOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ShareItemListOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appMarketplaceItemId"] = this.appMarketplaceItemId;
        data["itemListId"] = this.itemListId;
        data["sharingLevel"] = this.sharingLevel;
        data["message"] = this.message;
        if (Array.isArray(this.itemSharing)) {
            data["itemSharing"] = [];
            for (let item of this.itemSharing)
                data["itemSharing"].push(item.toJSON());
        }
        data["syncProductList"] = this.syncProductList;
        return data;
    }
}

export interface IShareItemListOptions {
    appMarketplaceItemId: number | undefined;
    itemListId: number;
    sharingLevel: number;
    message: string | undefined;
    itemSharing: ItemSharingDto[] | undefined;
    syncProductList: boolean;

    [key: string]: any;
}

export class AppItemStockAvailabilityExcelDto implements IAppItemStockAvailabilityExcelDto {
    id!: number;
    rowNumber!: number;
    stockAvailable!: string | undefined;
    code!: string | undefined;
    parentCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppItemStockAvailabilityExcelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.rowNumber = _data["rowNumber"];
            this.stockAvailable = _data["stockAvailable"];
            this.code = _data["code"];
            this.parentCode = _data["parentCode"];
        }
    }

    static fromJS(data: any): AppItemStockAvailabilityExcelDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemStockAvailabilityExcelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["rowNumber"] = this.rowNumber;
        data["stockAvailable"] = this.stockAvailable;
        data["code"] = this.code;
        data["parentCode"] = this.parentCode;
        return data;
    }
}

export interface IAppItemStockAvailabilityExcelDto {
    id: number;
    rowNumber: number;
    stockAvailable: string | undefined;
    code: string | undefined;
    parentCode: string | undefined;

    [key: string]: any;
}

export class AppItemStockAvailabilityExcelRecordDTO implements IAppItemStockAvailabilityExcelRecordDTO {
    parentCode!: string | undefined;
    code!: string | undefined;
    stockAvailable!: number;
    fieldsErrors!: string[] | undefined;
    excelDto!: AppItemStockAvailabilityExcelDto;
    status!: string | undefined;
    errorMessage!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppItemStockAvailabilityExcelRecordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.parentCode = _data["parentCode"];
            this.code = _data["code"];
            this.stockAvailable = _data["stockAvailable"];
            if (Array.isArray(_data["fieldsErrors"])) {
                this.fieldsErrors = [] as any;
                for (let item of _data["fieldsErrors"])
                    this.fieldsErrors!.push(item);
            }
            this.excelDto = _data["excelDto"] ? AppItemStockAvailabilityExcelDto.fromJS(_data["excelDto"]) : <any>undefined;
            this.status = _data["status"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): AppItemStockAvailabilityExcelRecordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemStockAvailabilityExcelRecordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["parentCode"] = this.parentCode;
        data["code"] = this.code;
        data["stockAvailable"] = this.stockAvailable;
        if (Array.isArray(this.fieldsErrors)) {
            data["fieldsErrors"] = [];
            for (let item of this.fieldsErrors)
                data["fieldsErrors"].push(item);
        }
        data["excelDto"] = this.excelDto ? this.excelDto.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IAppItemStockAvailabilityExcelRecordDTO {
    parentCode: string | undefined;
    code: string | undefined;
    stockAvailable: number;
    fieldsErrors: string[] | undefined;
    excelDto: AppItemStockAvailabilityExcelDto;
    status: string | undefined;
    errorMessage: string | undefined;

    [key: string]: any;
}

export class AppItemStockAvailabilityExcelResultsDTO implements IAppItemStockAvailabilityExcelResultsDTO {
    excelLogDTO!: ExcelLogDto;
    totalRecords!: number;
    codesFromList!: string[] | undefined;
    fromList!: number[] | undefined;
    from!: number;
    toList!: number[] | undefined;
    to!: number;
    totalPassedRecords!: number;
    totalFailedRecords!: number;
    excelRecords!: AppItemStockAvailabilityExcelRecordDTO[] | undefined;
    filePath!: string | undefined;
    errorMessage!: string | undefined;
    hasDuplication!: boolean;

    [key: string]: any;

    constructor(data?: IAppItemStockAvailabilityExcelResultsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.excelLogDTO = _data["excelLogDTO"] ? ExcelLogDto.fromJS(_data["excelLogDTO"]) : <any>undefined;
            this.totalRecords = _data["totalRecords"];
            if (Array.isArray(_data["codesFromList"])) {
                this.codesFromList = [] as any;
                for (let item of _data["codesFromList"])
                    this.codesFromList!.push(item);
            }
            if (Array.isArray(_data["fromList"])) {
                this.fromList = [] as any;
                for (let item of _data["fromList"])
                    this.fromList!.push(item);
            }
            this.from = _data["from"];
            if (Array.isArray(_data["toList"])) {
                this.toList = [] as any;
                for (let item of _data["toList"])
                    this.toList!.push(item);
            }
            this.to = _data["to"];
            this.totalPassedRecords = _data["totalPassedRecords"];
            this.totalFailedRecords = _data["totalFailedRecords"];
            if (Array.isArray(_data["excelRecords"])) {
                this.excelRecords = [] as any;
                for (let item of _data["excelRecords"])
                    this.excelRecords!.push(AppItemStockAvailabilityExcelRecordDTO.fromJS(item));
            }
            this.filePath = _data["filePath"];
            this.errorMessage = _data["errorMessage"];
            this.hasDuplication = _data["hasDuplication"];
        }
    }

    static fromJS(data: any): AppItemStockAvailabilityExcelResultsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppItemStockAvailabilityExcelResultsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["excelLogDTO"] = this.excelLogDTO ? this.excelLogDTO.toJSON() : <any>undefined;
        data["totalRecords"] = this.totalRecords;
        if (Array.isArray(this.codesFromList)) {
            data["codesFromList"] = [];
            for (let item of this.codesFromList)
                data["codesFromList"].push(item);
        }
        if (Array.isArray(this.fromList)) {
            data["fromList"] = [];
            for (let item of this.fromList)
                data["fromList"].push(item);
        }
        data["from"] = this.from;
        if (Array.isArray(this.toList)) {
            data["toList"] = [];
            for (let item of this.toList)
                data["toList"].push(item);
        }
        data["to"] = this.to;
        data["totalPassedRecords"] = this.totalPassedRecords;
        data["totalFailedRecords"] = this.totalFailedRecords;
        if (Array.isArray(this.excelRecords)) {
            data["excelRecords"] = [];
            for (let item of this.excelRecords)
                data["excelRecords"].push(item.toJSON());
        }
        data["filePath"] = this.filePath;
        data["errorMessage"] = this.errorMessage;
        data["hasDuplication"] = this.hasDuplication;
        return data;
    }
}

export interface IAppItemStockAvailabilityExcelResultsDTO {
    excelLogDTO: ExcelLogDto;
    totalRecords: number;
    codesFromList: string[] | undefined;
    fromList: number[] | undefined;
    from: number;
    toList: number[] | undefined;
    to: number;
    totalPassedRecords: number;
    totalFailedRecords: number;
    excelRecords: AppItemStockAvailabilityExcelRecordDTO[] | undefined;
    filePath: string | undefined;
    errorMessage: string | undefined;
    hasDuplication: boolean;

    [key: string]: any;
}

export enum PostType {
    TEXT = 0,
    ARTICLES = 1,
    SINGLEIMAGE = 2,
    SINGLEVIDEO = 3,
    NEWSDIGEST = 4,
}

export class GetAppPostForViewDto implements IGetAppPostForViewDto {
    appPost!: AppPostDto;
    appContactName!: string | undefined;
    appContactId!: string | undefined;
    urlTitle!: string | undefined;
    appEntityName!: string | undefined;
    canEdit!: boolean;
    attachments!: AppEntityAttachmentDto[] | undefined;
    attachmentsURLs!: string[] | undefined;
    type!: PostType;
    entityObjectTypeCode!: string | undefined;
    timePassedFromCreation!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppPostForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appPost = _data["appPost"] ? AppPostDto.fromJS(_data["appPost"]) : <any>undefined;
            this.appContactName = _data["appContactName"];
            this.appContactId = _data["appContactId"];
            this.urlTitle = _data["urlTitle"];
            this.appEntityName = _data["appEntityName"];
            this.canEdit = _data["canEdit"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["attachmentsURLs"])) {
                this.attachmentsURLs = [] as any;
                for (let item of _data["attachmentsURLs"])
                    this.attachmentsURLs!.push(item);
            }
            this.type = _data["type"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.timePassedFromCreation = _data["timePassedFromCreation"];
        }
    }

    static fromJS(data: any): GetAppPostForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppPostForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appPost"] = this.appPost ? this.appPost.toJSON() : <any>undefined;
        data["appContactName"] = this.appContactName;
        data["appContactId"] = this.appContactId;
        data["urlTitle"] = this.urlTitle;
        data["appEntityName"] = this.appEntityName;
        data["canEdit"] = this.canEdit;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.attachmentsURLs)) {
            data["attachmentsURLs"] = [];
            for (let item of this.attachmentsURLs)
                data["attachmentsURLs"].push(item);
        }
        data["type"] = this.type;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["timePassedFromCreation"] = this.timePassedFromCreation;
        return data;
    }
}

export interface IGetAppPostForViewDto {
    appPost: AppPostDto;
    appContactName: string | undefined;
    appContactId: string | undefined;
    urlTitle: string | undefined;
    appEntityName: string | undefined;
    canEdit: boolean;
    attachments: AppEntityAttachmentDto[] | undefined;
    attachmentsURLs: string[] | undefined;
    type: PostType;
    entityObjectTypeCode: string | undefined;
    timePassedFromCreation: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppPostForViewDto implements IPagedResultDtoOfGetAppPostForViewDto {
    totalCount!: number;
    items!: GetAppPostForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppPostForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppPostForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppPostForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppPostForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppPostForViewDto {
    totalCount: number;
    items: GetAppPostForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppPostDto implements ICreateOrEditAppPostDto {
    code!: string | undefined;
    description!: string | undefined;
    relatedEntityId!: number | undefined;
    urlTitle!: string | undefined;
    type!: PostType;
    appContactId!: number | undefined;
    appEntityId!: number | undefined;
    creatorUserId!: number | undefined;
    tenantId!: number | undefined;
    userName!: string | undefined;
    tenantName!: string | undefined;
    profilePictureId!: string;
    userImage!: string | undefined;
    creationDatetime!: moment.Moment;
    canEdit!: boolean;
    attachments!: AppEntityAttachmentDto[] | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.description = _data["description"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.urlTitle = _data["urlTitle"];
            this.type = _data["type"];
            this.appContactId = _data["appContactId"];
            this.appEntityId = _data["appEntityId"];
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.tenantName = _data["tenantName"];
            this.profilePictureId = _data["profilePictureId"];
            this.userImage = _data["userImage"];
            this.creationDatetime = _data["creationDatetime"] ? moment(_data["creationDatetime"].toString()) : <any>undefined;
            this.canEdit = _data["canEdit"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["description"] = this.description;
        data["relatedEntityId"] = this.relatedEntityId;
        data["urlTitle"] = this.urlTitle;
        data["type"] = this.type;
        data["appContactId"] = this.appContactId;
        data["appEntityId"] = this.appEntityId;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["tenantName"] = this.tenantName;
        data["profilePictureId"] = this.profilePictureId;
        data["userImage"] = this.userImage;
        data["creationDatetime"] = this.creationDatetime ? this.creationDatetime.toISOString() : <any>undefined;
        data["canEdit"] = this.canEdit;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppPostDto {
    code: string | undefined;
    description: string | undefined;
    relatedEntityId: number | undefined;
    urlTitle: string | undefined;
    type: PostType;
    appContactId: number | undefined;
    appEntityId: number | undefined;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userName: string | undefined;
    tenantName: string | undefined;
    profilePictureId: string;
    userImage: string | undefined;
    creationDatetime: moment.Moment;
    canEdit: boolean;
    attachments: AppEntityAttachmentDto[] | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class AttachmentInfoDto implements IAttachmentInfoDto {
    description!: string | undefined;
    fileName!: string | undefined;
    fullPath!: string | undefined;
    guid!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAttachmentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.fileName = _data["fileName"];
            this.fullPath = _data["fullPath"];
            this.guid = _data["guid"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AttachmentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["fileName"] = this.fileName;
        data["fullPath"] = this.fullPath;
        data["guid"] = this.guid;
        data["id"] = this.id;
        return data;
    }
}

export interface IAttachmentInfoDto {
    description: string | undefined;
    fileName: string | undefined;
    fullPath: string | undefined;
    guid: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppPostForEditOutput implements IGetAppPostForEditOutput {
    appPost!: CreateOrEditAppPostDto;
    appContactName!: string | undefined;
    appEntityName!: string | undefined;
    urlTitle!: string | undefined;
    canEdit!: boolean;
    attachments!: AttachmentInfoDto[] | undefined;
    attachmentsURLs!: string[] | undefined;
    type!: PostType;
    entityObjectTypeCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppPostForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appPost = _data["appPost"] ? CreateOrEditAppPostDto.fromJS(_data["appPost"]) : <any>undefined;
            this.appContactName = _data["appContactName"];
            this.appEntityName = _data["appEntityName"];
            this.urlTitle = _data["urlTitle"];
            this.canEdit = _data["canEdit"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["attachmentsURLs"])) {
                this.attachmentsURLs = [] as any;
                for (let item of _data["attachmentsURLs"])
                    this.attachmentsURLs!.push(item);
            }
            this.type = _data["type"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
        }
    }

    static fromJS(data: any): GetAppPostForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppPostForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appPost"] = this.appPost ? this.appPost.toJSON() : <any>undefined;
        data["appContactName"] = this.appContactName;
        data["appEntityName"] = this.appEntityName;
        data["urlTitle"] = this.urlTitle;
        data["canEdit"] = this.canEdit;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.attachmentsURLs)) {
            data["attachmentsURLs"] = [];
            for (let item of this.attachmentsURLs)
                data["attachmentsURLs"].push(item);
        }
        data["type"] = this.type;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        return data;
    }
}

export interface IGetAppPostForEditOutput {
    appPost: CreateOrEditAppPostDto;
    appContactName: string | undefined;
    appEntityName: string | undefined;
    urlTitle: string | undefined;
    canEdit: boolean;
    attachments: AttachmentInfoDto[] | undefined;
    attachmentsURLs: string[] | undefined;
    type: PostType;
    entityObjectTypeCode: string | undefined;

    [key: string]: any;
}

export class GetAppPostForViewOutput implements IGetAppPostForViewOutput {
    appPost!: CreateOrEditAppPostDto;
    appContactName!: string | undefined;
    appEntityName!: string | undefined;
    canEdit!: boolean;
    attachments!: AttachmentInfoDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetAppPostForViewOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appPost = _data["appPost"] ? CreateOrEditAppPostDto.fromJS(_data["appPost"]) : <any>undefined;
            this.appContactName = _data["appContactName"];
            this.appEntityName = _data["appEntityName"];
            this.canEdit = _data["canEdit"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAppPostForViewOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppPostForViewOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appPost"] = this.appPost ? this.appPost.toJSON() : <any>undefined;
        data["appContactName"] = this.appContactName;
        data["appEntityName"] = this.appEntityName;
        data["canEdit"] = this.canEdit;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAppPostForViewOutput {
    appPost: CreateOrEditAppPostDto;
    appContactName: string | undefined;
    appEntityName: string | undefined;
    canEdit: boolean;
    attachments: AttachmentInfoDto[] | undefined;

    [key: string]: any;
}

export class AppPostAppContactLookupTableDto implements IAppPostAppContactLookupTableDto {
    id!: number;
    displayName!: string | undefined;
    userName!: string | undefined;
    userImage!: string | undefined;
    creationDatetime!: moment.Moment;

    [key: string]: any;

    constructor(data?: IAppPostAppContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.userName = _data["userName"];
            this.userImage = _data["userImage"];
            this.creationDatetime = _data["creationDatetime"] ? moment(_data["creationDatetime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AppPostAppContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPostAppContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["userName"] = this.userName;
        data["userImage"] = this.userImage;
        data["creationDatetime"] = this.creationDatetime ? this.creationDatetime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAppPostAppContactLookupTableDto {
    id: number;
    displayName: string | undefined;
    userName: string | undefined;
    userImage: string | undefined;
    creationDatetime: moment.Moment;

    [key: string]: any;
}

export class PagedResultDtoOfAppPostAppContactLookupTableDto implements IPagedResultDtoOfAppPostAppContactLookupTableDto {
    totalCount!: number;
    items!: AppPostAppContactLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppPostAppContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppPostAppContactLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppPostAppContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppPostAppContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppPostAppContactLookupTableDto {
    totalCount: number;
    items: AppPostAppContactLookupTableDto[] | undefined;

    [key: string]: any;
}

export class AppPostAppEntityLookupTableDto implements IAppPostAppEntityLookupTableDto {
    id!: number;
    displayName!: string | undefined;
    userName!: string | undefined;
    userImage!: string | undefined;
    creationDatetime!: moment.Moment;

    [key: string]: any;

    constructor(data?: IAppPostAppEntityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.userName = _data["userName"];
            this.userImage = _data["userImage"];
            this.creationDatetime = _data["creationDatetime"] ? moment(_data["creationDatetime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AppPostAppEntityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPostAppEntityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["userName"] = this.userName;
        data["userImage"] = this.userImage;
        data["creationDatetime"] = this.creationDatetime ? this.creationDatetime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAppPostAppEntityLookupTableDto {
    id: number;
    displayName: string | undefined;
    userName: string | undefined;
    userImage: string | undefined;
    creationDatetime: moment.Moment;

    [key: string]: any;
}

export class PagedResultDtoOfAppPostAppEntityLookupTableDto implements IPagedResultDtoOfAppPostAppEntityLookupTableDto {
    totalCount!: number;
    items!: AppPostAppEntityLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAppPostAppEntityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppPostAppEntityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppPostAppEntityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppPostAppEntityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAppPostAppEntityLookupTableDto {
    totalCount: number;
    items: AppPostAppEntityLookupTableDto[] | undefined;

    [key: string]: any;
}

export class LinkPreviewResult implements ILinkPreviewResult {
    image!: string | undefined;
    title!: string | undefined;
    fileName!: string | undefined;

    [key: string]: any;

    constructor(data?: ILinkPreviewResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.image = _data["image"];
            this.title = _data["title"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): LinkPreviewResult {
        data = typeof data === 'object' ? data : {};
        let result = new LinkPreviewResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["image"] = this.image;
        data["title"] = this.title;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface ILinkPreviewResult {
    image: string | undefined;
    title: string | undefined;
    fileName: string | undefined;

    [key: string]: any;
}

export class GetAppSizeScaleForViewDto implements IGetAppSizeScaleForViewDto {
    code!: string | undefined;
    name!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: IGetAppSizeScaleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAppSizeScaleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppSizeScaleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAppSizeScaleForViewDto {
    code: string | undefined;
    name: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppSizeScaleForViewDto implements IPagedResultDtoOfGetAppSizeScaleForViewDto {
    totalCount!: number;
    items!: GetAppSizeScaleForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppSizeScaleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppSizeScaleForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppSizeScaleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppSizeScaleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppSizeScaleForViewDto {
    totalCount: number;
    items: GetAppSizeScaleForViewDto[] | undefined;

    [key: string]: any;
}

export class AppSizeScaleForEditDto implements IAppSizeScaleForEditDto {
    name!: string;
    parentId!: number | undefined;
    code!: string | undefined;
    noOfDimensions!: number;
    isDefault!: boolean;
    dimesion1Name!: string;
    dimesion2Name!: string | undefined;
    dimesion3Name!: string | undefined;
    appSizeScalesDetails!: AppSizeScalesDetailDto[] | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: IAppSizeScaleForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.noOfDimensions = _data["noOfDimensions"];
            this.isDefault = _data["isDefault"];
            this.dimesion1Name = _data["dimesion1Name"];
            this.dimesion2Name = _data["dimesion2Name"];
            this.dimesion3Name = _data["dimesion3Name"];
            if (Array.isArray(_data["appSizeScalesDetails"])) {
                this.appSizeScalesDetails = [] as any;
                for (let item of _data["appSizeScalesDetails"])
                    this.appSizeScalesDetails!.push(AppSizeScalesDetailDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppSizeScaleForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSizeScaleForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["noOfDimensions"] = this.noOfDimensions;
        data["isDefault"] = this.isDefault;
        data["dimesion1Name"] = this.dimesion1Name;
        data["dimesion2Name"] = this.dimesion2Name;
        data["dimesion3Name"] = this.dimesion3Name;
        if (Array.isArray(this.appSizeScalesDetails)) {
            data["appSizeScalesDetails"] = [];
            for (let item of this.appSizeScalesDetails)
                data["appSizeScalesDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IAppSizeScaleForEditDto {
    name: string;
    parentId: number | undefined;
    code: string | undefined;
    noOfDimensions: number;
    isDefault: boolean;
    dimesion1Name: string;
    dimesion2Name: string | undefined;
    dimesion3Name: string | undefined;
    appSizeScalesDetails: AppSizeScalesDetailDto[] | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class AppTenantPlanDto implements IAppTenantPlanDto {
    addDate!: moment.Moment;
    endDate!: moment.Moment;
    startDate!: moment.Moment;
    planId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppTenantPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.addDate = _data["addDate"] ? moment(_data["addDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.planId = _data["planId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppTenantPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["planId"] = this.planId;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppTenantPlanDto {
    addDate: moment.Moment;
    endDate: moment.Moment;
    startDate: moment.Moment;
    planId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppTenantPlanForViewDto implements IGetAppTenantPlanForViewDto {
    appTenantPlan!: AppTenantPlanDto;
    sycPlanName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppTenantPlanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appTenantPlan = _data["appTenantPlan"] ? AppTenantPlanDto.fromJS(_data["appTenantPlan"]) : <any>undefined;
            this.sycPlanName = _data["sycPlanName"];
        }
    }

    static fromJS(data: any): GetAppTenantPlanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppTenantPlanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appTenantPlan"] = this.appTenantPlan ? this.appTenantPlan.toJSON() : <any>undefined;
        data["sycPlanName"] = this.sycPlanName;
        return data;
    }
}

export interface IGetAppTenantPlanForViewDto {
    appTenantPlan: AppTenantPlanDto;
    sycPlanName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppTenantPlanForViewDto implements IPagedResultDtoOfGetAppTenantPlanForViewDto {
    totalCount!: number;
    items!: GetAppTenantPlanForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppTenantPlanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppTenantPlanForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppTenantPlanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppTenantPlanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppTenantPlanForViewDto {
    totalCount: number;
    items: GetAppTenantPlanForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppTenantPlanDto implements ICreateOrEditAppTenantPlanDto {
    addDate!: moment.Moment;
    endDate!: moment.Moment;
    startDate!: moment.Moment;
    planId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppTenantPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.addDate = _data["addDate"] ? moment(_data["addDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.planId = _data["planId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppTenantPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppTenantPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["planId"] = this.planId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppTenantPlanDto {
    addDate: moment.Moment;
    endDate: moment.Moment;
    startDate: moment.Moment;
    planId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppTenantPlanForEditOutput implements IGetAppTenantPlanForEditOutput {
    appTenantPlan!: CreateOrEditAppTenantPlanDto;
    sycPlanName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppTenantPlanForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appTenantPlan = _data["appTenantPlan"] ? CreateOrEditAppTenantPlanDto.fromJS(_data["appTenantPlan"]) : <any>undefined;
            this.sycPlanName = _data["sycPlanName"];
        }
    }

    static fromJS(data: any): GetAppTenantPlanForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppTenantPlanForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appTenantPlan"] = this.appTenantPlan ? this.appTenantPlan.toJSON() : <any>undefined;
        data["sycPlanName"] = this.sycPlanName;
        return data;
    }
}

export interface IGetAppTenantPlanForEditOutput {
    appTenantPlan: CreateOrEditAppTenantPlanDto;
    sycPlanName: string | undefined;

    [key: string]: any;
}

export class AppTenantPlanSycPlanLookupTableDto implements IAppTenantPlanSycPlanLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppTenantPlanSycPlanLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppTenantPlanSycPlanLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantPlanSycPlanLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppTenantPlanSycPlanLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AppTenantsActivitiesLogDto implements IAppTenantsActivitiesLogDto {
    activityDate!: moment.Moment;
    units!: number;
    unitPrice!: number;
    amount!: number;
    billed!: boolean;
    isManual!: boolean;
    invoiceNumber!: string | undefined;
    invoiceDate!: moment.Moment;
    serviceId!: number | undefined;
    applicationId!: number | undefined;
    transactionId!: number | undefined;
    planId!: number | undefined;
    tenantId!: number | undefined;
    notes!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppTenantsActivitiesLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.activityDate = _data["activityDate"] ? moment(_data["activityDate"].toString()) : <any>undefined;
            this.units = _data["units"];
            this.unitPrice = _data["unitPrice"];
            this.amount = _data["amount"];
            this.billed = _data["billed"];
            this.isManual = _data["isManual"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.serviceId = _data["serviceId"];
            this.applicationId = _data["applicationId"];
            this.transactionId = _data["transactionId"];
            this.planId = _data["planId"];
            this.tenantId = _data["tenantId"];
            this.notes = _data["notes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppTenantsActivitiesLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantsActivitiesLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["units"] = this.units;
        data["unitPrice"] = this.unitPrice;
        data["amount"] = this.amount;
        data["billed"] = this.billed;
        data["isManual"] = this.isManual;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["serviceId"] = this.serviceId;
        data["applicationId"] = this.applicationId;
        data["transactionId"] = this.transactionId;
        data["planId"] = this.planId;
        data["tenantId"] = this.tenantId;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppTenantsActivitiesLogDto {
    activityDate: moment.Moment;
    units: number;
    unitPrice: number;
    amount: number;
    billed: boolean;
    isManual: boolean;
    invoiceNumber: string | undefined;
    invoiceDate: moment.Moment;
    serviceId: number | undefined;
    applicationId: number | undefined;
    transactionId: number | undefined;
    planId: number | undefined;
    tenantId: number | undefined;
    notes: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetAppTenantsActivitiesLogForViewDto implements IGetAppTenantsActivitiesLogForViewDto {
    appTenantsActivitiesLog!: AppTenantsActivitiesLogDto;
    sycServiceCode!: string | undefined;
    sycApplicationName!: string | undefined;
    appTransactionCode!: string | undefined;
    sycPlanName!: string | undefined;
    tenancyName!: string | undefined;
    notes!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppTenantsActivitiesLogForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appTenantsActivitiesLog = _data["appTenantsActivitiesLog"] ? AppTenantsActivitiesLogDto.fromJS(_data["appTenantsActivitiesLog"]) : <any>undefined;
            this.sycServiceCode = _data["sycServiceCode"];
            this.sycApplicationName = _data["sycApplicationName"];
            this.appTransactionCode = _data["appTransactionCode"];
            this.sycPlanName = _data["sycPlanName"];
            this.tenancyName = _data["tenancyName"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): GetAppTenantsActivitiesLogForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppTenantsActivitiesLogForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appTenantsActivitiesLog"] = this.appTenantsActivitiesLog ? this.appTenantsActivitiesLog.toJSON() : <any>undefined;
        data["sycServiceCode"] = this.sycServiceCode;
        data["sycApplicationName"] = this.sycApplicationName;
        data["appTransactionCode"] = this.appTransactionCode;
        data["sycPlanName"] = this.sycPlanName;
        data["tenancyName"] = this.tenancyName;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IGetAppTenantsActivitiesLogForViewDto {
    appTenantsActivitiesLog: AppTenantsActivitiesLogDto;
    sycServiceCode: string | undefined;
    sycApplicationName: string | undefined;
    appTransactionCode: string | undefined;
    sycPlanName: string | undefined;
    tenancyName: string | undefined;
    notes: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto implements IPagedResultDtoOfGetAppTenantsActivitiesLogForViewDto {
    totalCount!: number;
    items!: GetAppTenantsActivitiesLogForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppTenantsActivitiesLogForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppTenantsActivitiesLogForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppTenantsActivitiesLogForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppTenantsActivitiesLogForViewDto {
    totalCount: number;
    items: GetAppTenantsActivitiesLogForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppTenantsActivitiesLogDto implements ICreateOrEditAppTenantsActivitiesLogDto {
    activityDate!: moment.Moment;
    units!: number;
    unitPrice!: number;
    amount!: number;
    billed!: boolean;
    isManual!: boolean;
    invoiceNumber!: string | undefined;
    invoiceDate!: moment.Moment;
    serviceId!: number | undefined;
    applicationId!: number | undefined;
    transactionId!: number | undefined;
    planId!: number | undefined;
    tenantId!: number | undefined;
    notes!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppTenantsActivitiesLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.activityDate = _data["activityDate"] ? moment(_data["activityDate"].toString()) : <any>undefined;
            this.units = _data["units"];
            this.unitPrice = _data["unitPrice"];
            this.amount = _data["amount"];
            this.billed = _data["billed"];
            this.isManual = _data["isManual"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.serviceId = _data["serviceId"];
            this.applicationId = _data["applicationId"];
            this.transactionId = _data["transactionId"];
            this.planId = _data["planId"];
            this.tenantId = _data["tenantId"];
            this.notes = _data["notes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppTenantsActivitiesLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppTenantsActivitiesLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["units"] = this.units;
        data["unitPrice"] = this.unitPrice;
        data["amount"] = this.amount;
        data["billed"] = this.billed;
        data["isManual"] = this.isManual;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["serviceId"] = this.serviceId;
        data["applicationId"] = this.applicationId;
        data["transactionId"] = this.transactionId;
        data["planId"] = this.planId;
        data["tenantId"] = this.tenantId;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppTenantsActivitiesLogDto {
    activityDate: moment.Moment;
    units: number;
    unitPrice: number;
    amount: number;
    billed: boolean;
    isManual: boolean;
    invoiceNumber: string | undefined;
    invoiceDate: moment.Moment;
    serviceId: number | undefined;
    applicationId: number | undefined;
    transactionId: number | undefined;
    planId: number | undefined;
    tenantId: number | undefined;
    notes: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppTenantsActivitiesLogForEditOutput implements IGetAppTenantsActivitiesLogForEditOutput {
    appTenantsActivitiesLog!: CreateOrEditAppTenantsActivitiesLogDto;
    sycServiceCode!: string | undefined;
    sycApplicationName!: string | undefined;
    appTransactionCode!: string | undefined;
    sycPlanName!: string | undefined;
    tenancyName!: string | undefined;
    notes!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAppTenantsActivitiesLogForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appTenantsActivitiesLog = _data["appTenantsActivitiesLog"] ? CreateOrEditAppTenantsActivitiesLogDto.fromJS(_data["appTenantsActivitiesLog"]) : <any>undefined;
            this.sycServiceCode = _data["sycServiceCode"];
            this.sycApplicationName = _data["sycApplicationName"];
            this.appTransactionCode = _data["appTransactionCode"];
            this.sycPlanName = _data["sycPlanName"];
            this.tenancyName = _data["tenancyName"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): GetAppTenantsActivitiesLogForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppTenantsActivitiesLogForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appTenantsActivitiesLog"] = this.appTenantsActivitiesLog ? this.appTenantsActivitiesLog.toJSON() : <any>undefined;
        data["sycServiceCode"] = this.sycServiceCode;
        data["sycApplicationName"] = this.sycApplicationName;
        data["appTransactionCode"] = this.appTransactionCode;
        data["sycPlanName"] = this.sycPlanName;
        data["tenancyName"] = this.tenancyName;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IGetAppTenantsActivitiesLogForEditOutput {
    appTenantsActivitiesLog: CreateOrEditAppTenantsActivitiesLogDto;
    sycServiceCode: string | undefined;
    sycApplicationName: string | undefined;
    appTransactionCode: string | undefined;
    sycPlanName: string | undefined;
    tenancyName: string | undefined;
    notes: string | undefined;

    [key: string]: any;
}

export class AppTenantsActivitiesLogSycServiceLookupTableDto implements IAppTenantsActivitiesLogSycServiceLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppTenantsActivitiesLogSycServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppTenantsActivitiesLogSycServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantsActivitiesLogSycServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppTenantsActivitiesLogSycServiceLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AppTenantsActivitiesLogSycApplicationLookupTableDto implements IAppTenantsActivitiesLogSycApplicationLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppTenantsActivitiesLogSycApplicationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppTenantsActivitiesLogSycApplicationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantsActivitiesLogSycApplicationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppTenantsActivitiesLogSycApplicationLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AppTenantsActivitiesLogAppTransactionLookupTableDto implements IAppTenantsActivitiesLogAppTransactionLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppTenantsActivitiesLogAppTransactionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppTenantsActivitiesLogAppTransactionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantsActivitiesLogAppTransactionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppTenantsActivitiesLogAppTransactionLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AppTenantsActivitiesLogSycPlanLookupTableDto implements IAppTenantsActivitiesLogSycPlanLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppTenantsActivitiesLogSycPlanLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppTenantsActivitiesLogSycPlanLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantsActivitiesLogSycPlanLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppTenantsActivitiesLogSycPlanLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AppTenantsActivitiesLogTenantLookupTableDto implements IAppTenantsActivitiesLogTenantLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: IAppTenantsActivitiesLogTenantLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AppTenantsActivitiesLogTenantLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTenantsActivitiesLogTenantLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAppTenantsActivitiesLogTenantLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class AppTransactionsDetailDto implements IAppTransactionsDetailDto {
    transactionCode!: string | undefined;
    lineNo!: number;
    quantity!: number;
    grossPrice!: number;
    netPrice!: number;
    discount!: number;
    amount!: number;
    itemId!: number;
    itemCode!: string | undefined;
    itemDescription!: string | undefined;
    note!: string | undefined;
    ssin!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: IAppTransactionsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.transactionCode = _data["transactionCode"];
            this.lineNo = _data["lineNo"];
            this.quantity = _data["quantity"];
            this.grossPrice = _data["grossPrice"];
            this.netPrice = _data["netPrice"];
            this.discount = _data["discount"];
            this.amount = _data["amount"];
            this.itemId = _data["itemId"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.note = _data["note"];
            this.ssin = _data["ssin"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppTransactionsDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTransactionsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["transactionCode"] = this.transactionCode;
        data["lineNo"] = this.lineNo;
        data["quantity"] = this.quantity;
        data["grossPrice"] = this.grossPrice;
        data["netPrice"] = this.netPrice;
        data["discount"] = this.discount;
        data["amount"] = this.amount;
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["note"] = this.note;
        data["ssin"] = this.ssin;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppTransactionsDetailDto {
    transactionCode: string | undefined;
    lineNo: number;
    quantity: number;
    grossPrice: number;
    netPrice: number;
    discount: number;
    amount: number;
    itemId: number;
    itemCode: string | undefined;
    itemDescription: string | undefined;
    note: string | undefined;
    ssin: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class CreateOrEditAppTransactionsDto implements ICreateOrEditAppTransactionsDto {
    enteredByUserRole!: string | undefined;
    buyerId!: number | undefined;
    buyerName!: string | undefined;
    sellerId!: number | undefined;
    sellerName!: string | undefined;
    buyerEMailAddress!: string | undefined;
    languageId!: number | undefined;
    languageCode!: string | undefined;
    currencyId!: number | undefined;
    currencyCode!: string | undefined;
    sellerEMailAddress!: string | undefined;
    buyerPhoneNumber!: string | undefined;
    sellerPhoneNumber!: string | undefined;
    buyerCompanyName!: string | undefined;
    sellerCompanyName!: string | undefined;
    priceLevel!: string | undefined;
    buyerContactId!: number | undefined;
    buyerContactName!: string | undefined;
    sellerContactId!: number | undefined;
    sellerContactName!: string | undefined;
    appTransactionsDetails!: AppTransactionsDetailDto[] | undefined;
    tenantId!: number | undefined;
    attachmentSourceTenantId!: number | undefined;
    name!: string | undefined;
    code!: string | undefined;
    notes!: string | undefined;
    isHostRecord!: boolean;
    addFromAttachments!: boolean;
    relatedEntityId!: number | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeCode!: string | undefined;
    entityObjectStatusId!: number | undefined;
    objectId!: number;
    entityAddresses!: AppEntityAddressDto[] | undefined;
    entityCategories!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    entitiesRelationships!: AppEntitiesRelationshipDto[] | undefined;
    relatedEntitiesRelationships!: AppEntitiesRelationshipDto[] | undefined;
    appEntityTypes!: AppEntityTypes;
    ssin!: string | undefined;
    tenantOwner!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppTransactionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enteredByUserRole = _data["enteredByUserRole"];
            this.buyerId = _data["buyerId"];
            this.buyerName = _data["buyerName"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.buyerEMailAddress = _data["buyerEMailAddress"];
            this.languageId = _data["languageId"];
            this.languageCode = _data["languageCode"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.sellerEMailAddress = _data["sellerEMailAddress"];
            this.buyerPhoneNumber = _data["buyerPhoneNumber"];
            this.sellerPhoneNumber = _data["sellerPhoneNumber"];
            this.buyerCompanyName = _data["buyerCompanyName"];
            this.sellerCompanyName = _data["sellerCompanyName"];
            this.priceLevel = _data["priceLevel"];
            this.buyerContactId = _data["buyerContactId"];
            this.buyerContactName = _data["buyerContactName"];
            this.sellerContactId = _data["sellerContactId"];
            this.sellerContactName = _data["sellerContactName"];
            if (Array.isArray(_data["appTransactionsDetails"])) {
                this.appTransactionsDetails = [] as any;
                for (let item of _data["appTransactionsDetails"])
                    this.appTransactionsDetails!.push(AppTransactionsDetailDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.attachmentSourceTenantId = _data["attachmentSourceTenantId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.notes = _data["notes"];
            this.isHostRecord = _data["isHostRecord"];
            this.addFromAttachments = _data["addFromAttachments"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.entityObjectStatusId = _data["entityObjectStatusId"];
            this.objectId = _data["objectId"];
            if (Array.isArray(_data["entityAddresses"])) {
                this.entityAddresses = [] as any;
                for (let item of _data["entityAddresses"])
                    this.entityAddresses!.push(AppEntityAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategories"])) {
                this.entityCategories = [] as any;
                for (let item of _data["entityCategories"])
                    this.entityCategories!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassifications"])) {
                this.entityClassifications = [] as any;
                for (let item of _data["entityClassifications"])
                    this.entityClassifications!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["entitiesRelationships"])) {
                this.entitiesRelationships = [] as any;
                for (let item of _data["entitiesRelationships"])
                    this.entitiesRelationships!.push(AppEntitiesRelationshipDto.fromJS(item));
            }
            if (Array.isArray(_data["relatedEntitiesRelationships"])) {
                this.relatedEntitiesRelationships = [] as any;
                for (let item of _data["relatedEntitiesRelationships"])
                    this.relatedEntitiesRelationships!.push(AppEntitiesRelationshipDto.fromJS(item));
            }
            this.appEntityTypes = _data["appEntityTypes"];
            this.ssin = _data["ssin"];
            this.tenantOwner = _data["tenantOwner"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppTransactionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppTransactionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enteredByUserRole"] = this.enteredByUserRole;
        data["buyerId"] = this.buyerId;
        data["buyerName"] = this.buyerName;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["buyerEMailAddress"] = this.buyerEMailAddress;
        data["languageId"] = this.languageId;
        data["languageCode"] = this.languageCode;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["sellerEMailAddress"] = this.sellerEMailAddress;
        data["buyerPhoneNumber"] = this.buyerPhoneNumber;
        data["sellerPhoneNumber"] = this.sellerPhoneNumber;
        data["buyerCompanyName"] = this.buyerCompanyName;
        data["sellerCompanyName"] = this.sellerCompanyName;
        data["priceLevel"] = this.priceLevel;
        data["buyerContactId"] = this.buyerContactId;
        data["buyerContactName"] = this.buyerContactName;
        data["sellerContactId"] = this.sellerContactId;
        data["sellerContactName"] = this.sellerContactName;
        if (Array.isArray(this.appTransactionsDetails)) {
            data["appTransactionsDetails"] = [];
            for (let item of this.appTransactionsDetails)
                data["appTransactionsDetails"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["attachmentSourceTenantId"] = this.attachmentSourceTenantId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["notes"] = this.notes;
        data["isHostRecord"] = this.isHostRecord;
        data["addFromAttachments"] = this.addFromAttachments;
        data["relatedEntityId"] = this.relatedEntityId;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["entityObjectStatusId"] = this.entityObjectStatusId;
        data["objectId"] = this.objectId;
        if (Array.isArray(this.entityAddresses)) {
            data["entityAddresses"] = [];
            for (let item of this.entityAddresses)
                data["entityAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategories)) {
            data["entityCategories"] = [];
            for (let item of this.entityCategories)
                data["entityCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassifications)) {
            data["entityClassifications"] = [];
            for (let item of this.entityClassifications)
                data["entityClassifications"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.entitiesRelationships)) {
            data["entitiesRelationships"] = [];
            for (let item of this.entitiesRelationships)
                data["entitiesRelationships"].push(item.toJSON());
        }
        if (Array.isArray(this.relatedEntitiesRelationships)) {
            data["relatedEntitiesRelationships"] = [];
            for (let item of this.relatedEntitiesRelationships)
                data["relatedEntitiesRelationships"].push(item.toJSON());
        }
        data["appEntityTypes"] = this.appEntityTypes;
        data["ssin"] = this.ssin;
        data["tenantOwner"] = this.tenantOwner;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppTransactionsDto {
    enteredByUserRole: string | undefined;
    buyerId: number | undefined;
    buyerName: string | undefined;
    sellerId: number | undefined;
    sellerName: string | undefined;
    buyerEMailAddress: string | undefined;
    languageId: number | undefined;
    languageCode: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    sellerEMailAddress: string | undefined;
    buyerPhoneNumber: string | undefined;
    sellerPhoneNumber: string | undefined;
    buyerCompanyName: string | undefined;
    sellerCompanyName: string | undefined;
    priceLevel: string | undefined;
    buyerContactId: number | undefined;
    buyerContactName: string | undefined;
    sellerContactId: number | undefined;
    sellerContactName: string | undefined;
    appTransactionsDetails: AppTransactionsDetailDto[] | undefined;
    tenantId: number | undefined;
    attachmentSourceTenantId: number | undefined;
    name: string | undefined;
    code: string | undefined;
    notes: string | undefined;
    isHostRecord: boolean;
    addFromAttachments: boolean;
    relatedEntityId: number | undefined;
    entityObjectTypeId: number;
    entityObjectTypeCode: string | undefined;
    entityObjectStatusId: number | undefined;
    objectId: number;
    entityAddresses: AppEntityAddressDto[] | undefined;
    entityCategories: AppEntityCategoryDto[] | undefined;
    entityClassifications: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    entitiesRelationships: AppEntitiesRelationshipDto[] | undefined;
    relatedEntitiesRelationships: AppEntitiesRelationshipDto[] | undefined;
    appEntityTypes: AppEntityTypes;
    ssin: string | undefined;
    tenantOwner: number;
    id: number;

    [key: string]: any;
}

export class GetAppTransactionsForViewDto implements IGetAppTransactionsForViewDto {
    enteredByUserRole!: string | undefined;
    buyerId!: number | undefined;
    buyerName!: string | undefined;
    sellerId!: number | undefined;
    sellerName!: string | undefined;
    buyerEMailAddress!: string | undefined;
    languageId!: number | undefined;
    languageCode!: string | undefined;
    currencyId!: number | undefined;
    currencyCode!: string | undefined;
    sellerEMailAddress!: string | undefined;
    buyerPhoneNumber!: string | undefined;
    sellerPhoneNumber!: string | undefined;
    buyerCompanyName!: string | undefined;
    sellerCompanyName!: string | undefined;
    priceLevel!: string | undefined;
    buyerContactId!: number | undefined;
    buyerContactName!: string | undefined;
    sellerContactId!: number | undefined;
    sellerContactName!: string | undefined;
    appTransactionsDetails!: AppTransactionsDetailDto[] | undefined;
    tenantId!: number | undefined;
    attachmentSourceTenantId!: number | undefined;
    name!: string | undefined;
    code!: string | undefined;
    notes!: string | undefined;
    isHostRecord!: boolean;
    addFromAttachments!: boolean;
    relatedEntityId!: number | undefined;
    entityObjectTypeId!: number;
    entityObjectTypeCode!: string | undefined;
    entityObjectStatusId!: number | undefined;
    objectId!: number;
    entityAddresses!: AppEntityAddressDto[] | undefined;
    entityCategories!: AppEntityCategoryDto[] | undefined;
    entityClassifications!: AppEntityClassificationDto[] | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    entityExtraData!: AppEntityExtraDataDto[] | undefined;
    entitiesRelationships!: AppEntitiesRelationshipDto[] | undefined;
    relatedEntitiesRelationships!: AppEntitiesRelationshipDto[] | undefined;
    appEntityTypes!: AppEntityTypes;
    ssin!: string | undefined;
    tenantOwner!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IGetAppTransactionsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enteredByUserRole = _data["enteredByUserRole"];
            this.buyerId = _data["buyerId"];
            this.buyerName = _data["buyerName"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.buyerEMailAddress = _data["buyerEMailAddress"];
            this.languageId = _data["languageId"];
            this.languageCode = _data["languageCode"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.sellerEMailAddress = _data["sellerEMailAddress"];
            this.buyerPhoneNumber = _data["buyerPhoneNumber"];
            this.sellerPhoneNumber = _data["sellerPhoneNumber"];
            this.buyerCompanyName = _data["buyerCompanyName"];
            this.sellerCompanyName = _data["sellerCompanyName"];
            this.priceLevel = _data["priceLevel"];
            this.buyerContactId = _data["buyerContactId"];
            this.buyerContactName = _data["buyerContactName"];
            this.sellerContactId = _data["sellerContactId"];
            this.sellerContactName = _data["sellerContactName"];
            if (Array.isArray(_data["appTransactionsDetails"])) {
                this.appTransactionsDetails = [] as any;
                for (let item of _data["appTransactionsDetails"])
                    this.appTransactionsDetails!.push(AppTransactionsDetailDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.attachmentSourceTenantId = _data["attachmentSourceTenantId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.notes = _data["notes"];
            this.isHostRecord = _data["isHostRecord"];
            this.addFromAttachments = _data["addFromAttachments"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.entityObjectTypeId = _data["entityObjectTypeId"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.entityObjectStatusId = _data["entityObjectStatusId"];
            this.objectId = _data["objectId"];
            if (Array.isArray(_data["entityAddresses"])) {
                this.entityAddresses = [] as any;
                for (let item of _data["entityAddresses"])
                    this.entityAddresses!.push(AppEntityAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["entityCategories"])) {
                this.entityCategories = [] as any;
                for (let item of _data["entityCategories"])
                    this.entityCategories!.push(AppEntityCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["entityClassifications"])) {
                this.entityClassifications = [] as any;
                for (let item of _data["entityClassifications"])
                    this.entityClassifications!.push(AppEntityClassificationDto.fromJS(item));
            }
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["entityExtraData"])) {
                this.entityExtraData = [] as any;
                for (let item of _data["entityExtraData"])
                    this.entityExtraData!.push(AppEntityExtraDataDto.fromJS(item));
            }
            if (Array.isArray(_data["entitiesRelationships"])) {
                this.entitiesRelationships = [] as any;
                for (let item of _data["entitiesRelationships"])
                    this.entitiesRelationships!.push(AppEntitiesRelationshipDto.fromJS(item));
            }
            if (Array.isArray(_data["relatedEntitiesRelationships"])) {
                this.relatedEntitiesRelationships = [] as any;
                for (let item of _data["relatedEntitiesRelationships"])
                    this.relatedEntitiesRelationships!.push(AppEntitiesRelationshipDto.fromJS(item));
            }
            this.appEntityTypes = _data["appEntityTypes"];
            this.ssin = _data["ssin"];
            this.tenantOwner = _data["tenantOwner"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAppTransactionsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppTransactionsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enteredByUserRole"] = this.enteredByUserRole;
        data["buyerId"] = this.buyerId;
        data["buyerName"] = this.buyerName;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["buyerEMailAddress"] = this.buyerEMailAddress;
        data["languageId"] = this.languageId;
        data["languageCode"] = this.languageCode;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["sellerEMailAddress"] = this.sellerEMailAddress;
        data["buyerPhoneNumber"] = this.buyerPhoneNumber;
        data["sellerPhoneNumber"] = this.sellerPhoneNumber;
        data["buyerCompanyName"] = this.buyerCompanyName;
        data["sellerCompanyName"] = this.sellerCompanyName;
        data["priceLevel"] = this.priceLevel;
        data["buyerContactId"] = this.buyerContactId;
        data["buyerContactName"] = this.buyerContactName;
        data["sellerContactId"] = this.sellerContactId;
        data["sellerContactName"] = this.sellerContactName;
        if (Array.isArray(this.appTransactionsDetails)) {
            data["appTransactionsDetails"] = [];
            for (let item of this.appTransactionsDetails)
                data["appTransactionsDetails"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["attachmentSourceTenantId"] = this.attachmentSourceTenantId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["notes"] = this.notes;
        data["isHostRecord"] = this.isHostRecord;
        data["addFromAttachments"] = this.addFromAttachments;
        data["relatedEntityId"] = this.relatedEntityId;
        data["entityObjectTypeId"] = this.entityObjectTypeId;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["entityObjectStatusId"] = this.entityObjectStatusId;
        data["objectId"] = this.objectId;
        if (Array.isArray(this.entityAddresses)) {
            data["entityAddresses"] = [];
            for (let item of this.entityAddresses)
                data["entityAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.entityCategories)) {
            data["entityCategories"] = [];
            for (let item of this.entityCategories)
                data["entityCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClassifications)) {
            data["entityClassifications"] = [];
            for (let item of this.entityClassifications)
                data["entityClassifications"].push(item.toJSON());
        }
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        if (Array.isArray(this.entityExtraData)) {
            data["entityExtraData"] = [];
            for (let item of this.entityExtraData)
                data["entityExtraData"].push(item.toJSON());
        }
        if (Array.isArray(this.entitiesRelationships)) {
            data["entitiesRelationships"] = [];
            for (let item of this.entitiesRelationships)
                data["entitiesRelationships"].push(item.toJSON());
        }
        if (Array.isArray(this.relatedEntitiesRelationships)) {
            data["relatedEntitiesRelationships"] = [];
            for (let item of this.relatedEntitiesRelationships)
                data["relatedEntitiesRelationships"].push(item.toJSON());
        }
        data["appEntityTypes"] = this.appEntityTypes;
        data["ssin"] = this.ssin;
        data["tenantOwner"] = this.tenantOwner;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAppTransactionsForViewDto {
    enteredByUserRole: string | undefined;
    buyerId: number | undefined;
    buyerName: string | undefined;
    sellerId: number | undefined;
    sellerName: string | undefined;
    buyerEMailAddress: string | undefined;
    languageId: number | undefined;
    languageCode: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    sellerEMailAddress: string | undefined;
    buyerPhoneNumber: string | undefined;
    sellerPhoneNumber: string | undefined;
    buyerCompanyName: string | undefined;
    sellerCompanyName: string | undefined;
    priceLevel: string | undefined;
    buyerContactId: number | undefined;
    buyerContactName: string | undefined;
    sellerContactId: number | undefined;
    sellerContactName: string | undefined;
    appTransactionsDetails: AppTransactionsDetailDto[] | undefined;
    tenantId: number | undefined;
    attachmentSourceTenantId: number | undefined;
    name: string | undefined;
    code: string | undefined;
    notes: string | undefined;
    isHostRecord: boolean;
    addFromAttachments: boolean;
    relatedEntityId: number | undefined;
    entityObjectTypeId: number;
    entityObjectTypeCode: string | undefined;
    entityObjectStatusId: number | undefined;
    objectId: number;
    entityAddresses: AppEntityAddressDto[] | undefined;
    entityCategories: AppEntityCategoryDto[] | undefined;
    entityClassifications: AppEntityClassificationDto[] | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    entityExtraData: AppEntityExtraDataDto[] | undefined;
    entitiesRelationships: AppEntitiesRelationshipDto[] | undefined;
    relatedEntitiesRelationships: AppEntitiesRelationshipDto[] | undefined;
    appEntityTypes: AppEntityTypes;
    ssin: string | undefined;
    tenantOwner: number;
    id: number;

    [key: string]: any;
}

export class GetAccountInformationOutputDto implements IGetAccountInformationOutputDto {
    id!: number;
    name!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAccountInformationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetAccountInformationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountInformationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetAccountInformationOutputDto {
    id: number;
    name: string | undefined;

    [key: string]: any;
}

export class GetContactInformationDto implements IGetContactInformationDto {
    id!: number;
    name!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetContactInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): GetContactInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IGetContactInformationDto {
    id: number;
    name: string | undefined;
    email: string | undefined;
    phone: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetAccountInformationOutputDto implements IPagedResultDtoOfGetAccountInformationOutputDto {
    totalCount!: number;
    items!: GetAccountInformationOutputDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAccountInformationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAccountInformationOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAccountInformationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAccountInformationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAccountInformationOutputDto {
    totalCount: number;
    items: GetAccountInformationOutputDto[] | undefined;

    [key: string]: any;
}

export class AppTransactionDto implements IAppTransactionDto {
    code!: string | undefined;
    date!: moment.Moment;
    addDate!: moment.Moment;
    endDate!: moment.Moment;
    id!: number;

    [key: string]: any;

    constructor(data?: IAppTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.addDate = _data["addDate"] ? moment(_data["addDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IAppTransactionDto {
    code: string | undefined;
    date: moment.Moment;
    addDate: moment.Moment;
    endDate: moment.Moment;
    id: number;

    [key: string]: any;
}

export class GetAppTransactionForViewDto implements IGetAppTransactionForViewDto {
    appTransaction!: AppTransactionDto;

    [key: string]: any;

    constructor(data?: IGetAppTransactionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appTransaction = _data["appTransaction"] ? AppTransactionDto.fromJS(_data["appTransaction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppTransactionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppTransactionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appTransaction"] = this.appTransaction ? this.appTransaction.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppTransactionForViewDto {
    appTransaction: AppTransactionDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetAppTransactionForViewDto implements IPagedResultDtoOfGetAppTransactionForViewDto {
    totalCount!: number;
    items!: GetAppTransactionForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAppTransactionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAppTransactionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAppTransactionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAppTransactionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAppTransactionForViewDto {
    totalCount: number;
    items: GetAppTransactionForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditAppTransactionDto implements ICreateOrEditAppTransactionDto {
    code!: string;
    date!: moment.Moment;
    addDate!: moment.Moment;
    endDate!: moment.Moment;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAppTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.addDate = _data["addDate"] ? moment(_data["addDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAppTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAppTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAppTransactionDto {
    code: string;
    date: moment.Moment;
    addDate: moment.Moment;
    endDate: moment.Moment;
    id: number | undefined;

    [key: string]: any;
}

export class GetAppTransactionForEditOutput implements IGetAppTransactionForEditOutput {
    appTransaction!: CreateOrEditAppTransactionDto;

    [key: string]: any;

    constructor(data?: IGetAppTransactionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appTransaction = _data["appTransaction"] ? CreateOrEditAppTransactionDto.fromJS(_data["appTransaction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppTransactionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppTransactionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appTransaction"] = this.appTransaction ? this.appTransaction.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAppTransactionForEditOutput {
    appTransaction: CreateOrEditAppTransactionDto;

    [key: string]: any;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;

    [key: string]: any;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    [key: string]: any;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;

    [key: string]: any;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? moment(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            (<any>this).changeTypeName = _data["changeTypeName"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;

    [key: string]: any;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;

    [key: string]: any;
}

export class AutotaskQueueDto implements IAutotaskQueueDto {
    refQueueID!: number;
    name!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IAutotaskQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.refQueueID = _data["refQueueID"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AutotaskQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutotaskQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["refQueueID"] = this.refQueueID;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IAutotaskQueueDto {
    refQueueID: number;
    name: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetAutotaskQueueForViewDto implements IGetAutotaskQueueForViewDto {
    autotaskQueue!: AutotaskQueueDto;

    [key: string]: any;

    constructor(data?: IGetAutotaskQueueForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.autotaskQueue = _data["autotaskQueue"] ? AutotaskQueueDto.fromJS(_data["autotaskQueue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAutotaskQueueForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAutotaskQueueForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["autotaskQueue"] = this.autotaskQueue ? this.autotaskQueue.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAutotaskQueueForViewDto {
    autotaskQueue: AutotaskQueueDto;

    [key: string]: any;
}

export class CreateOrEditAutotaskQueueDto implements ICreateOrEditAutotaskQueueDto {
    refQueueID!: number;
    name!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditAutotaskQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.refQueueID = _data["refQueueID"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAutotaskQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAutotaskQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["refQueueID"] = this.refQueueID;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAutotaskQueueDto {
    refQueueID: number;
    name: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetAutotaskQueueForEditOutput implements IGetAutotaskQueueForEditOutput {
    autotaskQueue!: CreateOrEditAutotaskQueueDto;

    [key: string]: any;

    constructor(data?: IGetAutotaskQueueForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.autotaskQueue = _data["autotaskQueue"] ? CreateOrEditAutotaskQueueDto.fromJS(_data["autotaskQueue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAutotaskQueueForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAutotaskQueueForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["autotaskQueue"] = this.autotaskQueue ? this.autotaskQueue.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAutotaskQueueForEditOutput {
    autotaskQueue: CreateOrEditAutotaskQueueDto;

    [key: string]: any;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    [key: string]: any;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface ICacheDto {
    name: string | undefined;

    [key: string]: any;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;

    [key: string]: any;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    [key: string]: any;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;

    [key: string]: any;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    [key: string]: any;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureId = _data["friendProfilePictureId"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data;
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;

    [key: string]: any;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment;
    friends!: FriendDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.serverTime = _data["serverTime"] ? moment(_data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment;
    friends: FriendDto[] | undefined;

    [key: string]: any;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: moment.Moment;
    sharedMessageId!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.side = _data["side"];
            this.readState = _data["readState"];
            this.receiverReadState = _data["receiverReadState"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = _data["sharedMessageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data;
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: moment.Moment;
    sharedMessageId: string | undefined;
    id: number;

    [key: string]: any;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;

    [key: string]: any;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    [key: string]: any;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;

    [key: string]: any;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    [key: string]: any;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isFree = _data["isFree"];
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;

    [key: string]: any;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;

    [key: string]: any;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    excludeCurrentUser!: boolean;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    [key: string]: any;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.excludeCurrentUser = _data["excludeCurrentUser"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["excludeCurrentUser"] = this.excludeCurrentUser;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    excludeCurrentUser: boolean;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;

    [key: string]: any;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;

    [key: string]: any;
}

export class Widget implements IWidget {
    widgetId!: string | undefined;
    height!: number;
    width!: number;
    positionX!: number;
    positionY!: number;

    [key: string]: any;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.widgetId = _data["widgetId"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;

    [key: string]: any;
}

export class Page implements IPage {
    id!: string | undefined;
    name!: string | undefined;
    widgets!: Widget[] | undefined;

    [key: string]: any;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;

    [key: string]: any;
}

export class Dashboard implements IDashboard {
    dashboardName!: string | undefined;
    pages!: Page[] | undefined;

    [key: string]: any;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dashboardName = _data["dashboardName"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dashboardName"] = this.dashboardName;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;

    [key: string]: any;
}

export class SavePageInput implements ISavePageInput {
    dashboardName!: string | undefined;
    application!: string | undefined;
    pages!: Page[] | undefined;

    [key: string]: any;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dashboardName = _data["dashboardName"];
            this.application = _data["application"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;

    [key: string]: any;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName!: string | undefined;
    id!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    [key: string]: any;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dashboardName = _data["dashboardName"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;

    [key: string]: any;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    [key: string]: any;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dashboardName = _data["dashboardName"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;

    [key: string]: any;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId!: string | undefined;

    [key: string]: any;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pageId"] = this.pageId;
        return data;
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;

    [key: string]: any;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId!: string | undefined;
    pageId!: string | undefined;
    dashboardName!: string | undefined;
    width!: number;
    height!: number;
    application!: string | undefined;

    [key: string]: any;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.widgetId = _data["widgetId"];
            this.pageId = _data["pageId"];
            this.dashboardName = _data["dashboardName"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;

    [key: string]: any;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id!: string | undefined;
    name!: string | undefined;

    [key: string]: any;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;

    [key: string]: any;
}

export class WidgetOutput implements IWidgetOutput {
    id!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    filters!: WidgetFilterOutput[] | undefined;

    [key: string]: any;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;

    [key: string]: any;
}

export class DashboardOutput implements IDashboardOutput {
    name!: string | undefined;
    widgets!: WidgetOutput[] | undefined;

    [key: string]: any;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;

    [key: string]: any;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    [key: string]: any;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dateString = _data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dateString"] = this.dateString;
        return data;
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;

    [key: string]: any;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    [key: string]: any;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;

    [key: string]: any;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    [key: string]: any;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["output"] = this.output;
        return data;
    }
}

export interface IStringOutput {
    output: string | undefined;

    [key: string]: any;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.trialDayCount = _data["trialDayCount"];
            this.expiringEditionDisplayName = _data["expiringEditionDisplayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;

    [key: string]: any;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;

    [key: string]: any;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    [key: string]: any;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;

    [key: string]: any;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    [key: string]: any;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    [key: string]: any;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    [key: string]: any;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    [key: string]: any;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;
    itemSource!: LocalizableComboboxItemSourceDto;

    [key: string]: any;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;

    [key: string]: any;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto;

    [key: string]: any;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;

    [key: string]: any;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    [key: string]: any;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    [key: string]: any;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;

    [key: string]: any;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    [key: string]: any;

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.edition = _data["edition"] ? EditionCreateDto.fromJS(_data["edition"]) : new EditionCreateDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];

    [key: string]: any;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    [key: string]: any;

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];

    [key: string]: any;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number;
    targetEditionId!: number;

    [key: string]: any;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sourceEditionId = _data["sourceEditionId"];
            this.targetEditionId = _data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;

    [key: string]: any;
}

export class EmailTemplateReturnDto implements IEmailTemplateReturnDto {
    messageSubject!: string | undefined;
    messageBody!: string | undefined;

    [key: string]: any;

    constructor(data?: IEmailTemplateReturnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.messageSubject = _data["messageSubject"];
            this.messageBody = _data["messageBody"];
        }
    }

    static fromJS(data: any): EmailTemplateReturnDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateReturnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["messageSubject"] = this.messageSubject;
        data["messageBody"] = this.messageBody;
        return data;
    }
}

export interface IEmailTemplateReturnDto {
    messageSubject: string | undefined;
    messageBody: string | undefined;

    [key: string]: any;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;

    [key: string]: any;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    [key: string]: any;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;

    [key: string]: any;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    [key: string]: any;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;

    [key: string]: any;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    [key: string]: any;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;

    [key: string]: any;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    [key: string]: any;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;

    [key: string]: any;
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;

    [key: string]: any;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newTenantsCount = _data["newTenantsCount"];
            this.newSubscriptionAmount = _data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = _data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = _data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data;
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;

    [key: string]: any;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: moment.Moment;

    [key: string]: any;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: moment.Moment;

    [key: string]: any;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenantsDayCount!: number;
    maxRecentTenantsShownCount!: number;
    tenantCreationStartDate!: moment.Moment;
    recentTenants!: RecentTenant[] | undefined;

    [key: string]: any;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.recentTenantsDayCount = _data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = _data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = _data["tenantCreationStartDate"] ? moment(_data["tenantCreationStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of _data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRecentTenantsOutput {
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: moment.Moment;
    recentTenants: RecentTenant[] | undefined;

    [key: string]: any;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    [key: string]: any;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantName = _data["tenantName"];
            this.remainingDayCount = _data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;

    [key: string]: any;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants!: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount!: number;
    maxExpiringTenantsShownCount!: number;
    subscriptionEndDateStart!: moment.Moment;
    subscriptionEndDateEnd!: moment.Moment;

    [key: string]: any;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of _data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = _data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = _data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = _data["subscriptionEndDateStart"] ? moment(_data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = _data["subscriptionEndDateEnd"] ? moment(_data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: moment.Moment;
    subscriptionEndDateEnd: moment.Moment;

    [key: string]: any;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment;
    amount!: number;

    [key: string]: any;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.label = _data["label"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment;
    amount: number;

    [key: string]: any;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    [key: string]: any;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of _data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;

    [key: string]: any;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    [key: string]: any;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;

    [key: string]: any;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    [key: string]: any;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of _data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;

    [key: string]: any;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    [key: string]: any;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;

    [key: string]: any;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean;
    timeOutSecond!: number;
    showTimeOutNotificationSecond!: number;
    showLockScreenWhenTimedOut!: boolean;

    [key: string]: any;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isEnabled = _data["isEnabled"];
            this.timeOutSecond = _data["timeOutSecond"];
            this.showTimeOutNotificationSecond = _data["showTimeOutNotificationSecond"];
            this.showLockScreenWhenTimedOut = _data["showLockScreenWhenTimedOut"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        data["showLockScreenWhenTimedOut"] = this.showLockScreenWhenTimedOut;
        return data;
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
    showLockScreenWhenTimedOut: boolean;

    [key: string]: any;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    useCaptchaOnLogin!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    [key: string]: any;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;

    [key: string]: any;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    [key: string]: any;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;

    [key: string]: any;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    [key: string]: any;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;

    [key: string]: any;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    [key: string]: any;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;

    [key: string]: any;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number;
    defaultAccountLockoutSeconds!: number;

    [key: string]: any;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;

    [key: string]: any;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    [key: string]: any;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;

    [key: string]: any;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;
    userLockOut!: UserLockOutSettingsEditDto;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto;

    [key: string]: any;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;

    [key: string]: any;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    [key: string]: any;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.legalName = _data["legalName"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    [key: string]: any;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    [key: string]: any;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;

    [key: string]: any;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto;
    otherSettings!: OtherSettingsEditDto;

    [key: string]: any;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? HostBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? OtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;

    [key: string]: any;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    [key: string]: any;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;

    [key: string]: any;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto;
    billInfo!: HostBillingSettingsEditDto;

    [key: string]: any;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.connectionString = _data["connectionString"];
            this.adminPassword = _data["adminPassword"];
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverUrl = _data["serverUrl"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.smtpSettings = _data["smtpSettings"] ? EmailSettingsEditDto.fromJS(_data["smtpSettings"]) : <any>undefined;
            this.billInfo = _data["billInfo"] ? HostBillingSettingsEditDto.fromJS(_data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;

    [key: string]: any;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    [key: string]: any;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;

    [key: string]: any;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    [key: string]: any;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverSiteUrl = _data["serverSiteUrl"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;

    [key: string]: any;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean;

    [key: string]: any;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isDatabaseExist = _data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;

    [key: string]: any;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    [key: string]: any;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.amount = _data["amount"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = _data["tenantLegalName"];
            if (Array.isArray(_data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of _data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = _data["tenantTaxNo"];
            this.hostLegalName = _data["hostLegalName"];
            if (Array.isArray(_data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of _data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data;
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;

    [key: string]: any;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number;

    [key: string]: any;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.subscriptionPaymentId = _data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;

    [key: string]: any;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;

    [key: string]: any;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    [key: string]: any;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;

    [key: string]: any;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    [key: string]: any;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;

    [key: string]: any;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;

    [key: string]: any;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;

    [key: string]: any;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    [key: string]: any;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;

    [key: string]: any;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    [key: string]: any;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;

    [key: string]: any;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    [key: string]: any;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;

    [key: string]: any;
}

export class MaintainanceDto implements IMaintainanceDto {
    name!: string | undefined;
    description!: string | undefined;
    from!: moment.Moment;
    to!: moment.Moment;
    published!: boolean;
    dismissIds!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IMaintainanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.from = _data["from"] ? moment(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
            this.published = _data["published"];
            this.dismissIds = _data["dismissIds"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaintainanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintainanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["published"] = this.published;
        data["dismissIds"] = this.dismissIds;
        data["id"] = this.id;
        return data;
    }
}

export interface IMaintainanceDto {
    name: string | undefined;
    description: string | undefined;
    from: moment.Moment;
    to: moment.Moment;
    published: boolean;
    dismissIds: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetMaintainanceForViewDto implements IGetMaintainanceForViewDto {
    maintainance!: MaintainanceDto;

    [key: string]: any;

    constructor(data?: IGetMaintainanceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.maintainance = _data["maintainance"] ? MaintainanceDto.fromJS(_data["maintainance"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMaintainanceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaintainanceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["maintainance"] = this.maintainance ? this.maintainance.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMaintainanceForViewDto {
    maintainance: MaintainanceDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetMaintainanceForViewDto implements IPagedResultDtoOfGetMaintainanceForViewDto {
    totalCount!: number;
    items!: GetMaintainanceForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetMaintainanceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMaintainanceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaintainanceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaintainanceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMaintainanceForViewDto {
    totalCount: number;
    items: GetMaintainanceForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditMaintainanceDto implements ICreateOrEditMaintainanceDto {
    name!: string;
    description!: string | undefined;
    from!: moment.Moment;
    to!: moment.Moment;
    published!: boolean;
    dismissIds!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditMaintainanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.from = _data["from"] ? moment(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
            this.published = _data["published"];
            this.dismissIds = _data["dismissIds"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMaintainanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMaintainanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["published"] = this.published;
        data["dismissIds"] = this.dismissIds;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMaintainanceDto {
    name: string;
    description: string | undefined;
    from: moment.Moment;
    to: moment.Moment;
    published: boolean;
    dismissIds: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetMaintainanceForEditOutput implements IGetMaintainanceForEditOutput {
    maintainance!: CreateOrEditMaintainanceDto;

    [key: string]: any;

    constructor(data?: IGetMaintainanceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.maintainance = _data["maintainance"] ? CreateOrEditMaintainanceDto.fromJS(_data["maintainance"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMaintainanceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaintainanceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["maintainance"] = this.maintainance ? this.maintainance.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMaintainanceForEditOutput {
    maintainance: CreateOrEditMaintainanceDto;

    [key: string]: any;
}

export enum MesasgeObjectType {
    Message = 0,
    Comment = 1,
}

export class MessagesDto implements IMessagesDto {
    parentFKList!: MessagesDto[] | undefined;
    hasChildren!: boolean;
    tenantId!: number | undefined;
    senderId!: number | undefined;
    entityObjectTypeCode!: string | undefined;
    to!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    bodyFormat!: string | undefined;
    sendDate!: moment.Moment;
    receiveDate!: moment.Moment;
    entityId!: number | undefined;
    entityCode!: string | undefined;
    parentId!: number | undefined;
    parentCode!: string | undefined;
    threadId!: number | undefined;
    userId!: number | undefined;
    senderName!: string | undefined;
    toName!: string | undefined;
    isFavorite!: boolean;
    entityObjectStatusCode!: string | undefined;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;
    recipientsName!: string | undefined;
    mesasgeObjectType!: MesasgeObjectType;
    relatedEntityId!: number | undefined;
    profilePictureId!: string;
    userImage!: GetProfilePictureOutput;
    profilePictureUrl!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IMessagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["parentFKList"])) {
                this.parentFKList = [] as any;
                for (let item of _data["parentFKList"])
                    this.parentFKList!.push(MessagesDto.fromJS(item));
            }
            this.hasChildren = _data["hasChildren"];
            this.tenantId = _data["tenantId"];
            this.senderId = _data["senderId"];
            this.entityObjectTypeCode = _data["entityObjectTypeCode"];
            this.to = _data["to"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.bodyFormat = _data["bodyFormat"];
            this.sendDate = _data["sendDate"] ? moment(_data["sendDate"].toString()) : <any>undefined;
            this.receiveDate = _data["receiveDate"] ? moment(_data["receiveDate"].toString()) : <any>undefined;
            this.entityId = _data["entityId"];
            this.entityCode = _data["entityCode"];
            this.parentId = _data["parentId"];
            this.parentCode = _data["parentCode"];
            this.threadId = _data["threadId"];
            this.userId = _data["userId"];
            this.senderName = _data["senderName"];
            this.toName = _data["toName"];
            this.isFavorite = _data["isFavorite"];
            this.entityObjectStatusCode = _data["entityObjectStatusCode"];
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
            this.recipientsName = _data["recipientsName"];
            this.mesasgeObjectType = _data["mesasgeObjectType"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.profilePictureId = _data["profilePictureId"];
            this.userImage = _data["userImage"] ? GetProfilePictureOutput.fromJS(_data["userImage"]) : <any>undefined;
            this.profilePictureUrl = _data["profilePictureUrl"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.parentFKList)) {
            data["parentFKList"] = [];
            for (let item of this.parentFKList)
                data["parentFKList"].push(item.toJSON());
        }
        data["hasChildren"] = this.hasChildren;
        data["tenantId"] = this.tenantId;
        data["senderId"] = this.senderId;
        data["entityObjectTypeCode"] = this.entityObjectTypeCode;
        data["to"] = this.to;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["bodyFormat"] = this.bodyFormat;
        data["sendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["receiveDate"] = this.receiveDate ? this.receiveDate.toISOString() : <any>undefined;
        data["entityId"] = this.entityId;
        data["entityCode"] = this.entityCode;
        data["parentId"] = this.parentId;
        data["parentCode"] = this.parentCode;
        data["threadId"] = this.threadId;
        data["userId"] = this.userId;
        data["senderName"] = this.senderName;
        data["toName"] = this.toName;
        data["isFavorite"] = this.isFavorite;
        data["entityObjectStatusCode"] = this.entityObjectStatusCode;
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        data["recipientsName"] = this.recipientsName;
        data["mesasgeObjectType"] = this.mesasgeObjectType;
        data["relatedEntityId"] = this.relatedEntityId;
        data["profilePictureId"] = this.profilePictureId;
        data["userImage"] = this.userImage ? this.userImage.toJSON() : <any>undefined;
        data["profilePictureUrl"] = this.profilePictureUrl;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessagesDto {
    parentFKList: MessagesDto[] | undefined;
    hasChildren: boolean;
    tenantId: number | undefined;
    senderId: number | undefined;
    entityObjectTypeCode: string | undefined;
    to: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    bodyFormat: string | undefined;
    sendDate: moment.Moment;
    receiveDate: moment.Moment;
    entityId: number | undefined;
    entityCode: string | undefined;
    parentId: number | undefined;
    parentCode: string | undefined;
    threadId: number | undefined;
    userId: number | undefined;
    senderName: string | undefined;
    toName: string | undefined;
    isFavorite: boolean;
    entityObjectStatusCode: string | undefined;
    entityAttachments: AppEntityAttachmentDto[] | undefined;
    recipientsName: string | undefined;
    mesasgeObjectType: MesasgeObjectType;
    relatedEntityId: number | undefined;
    profilePictureId: string;
    userImage: GetProfilePictureOutput;
    profilePictureUrl: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetMessagesForViewDto implements IGetMessagesForViewDto {
    messages!: MessagesDto;

    [key: string]: any;

    constructor(data?: IGetMessagesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.messages = _data["messages"] ? MessagesDto.fromJS(_data["messages"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMessagesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMessagesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["messages"] = this.messages ? this.messages.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMessagesForViewDto {
    messages: MessagesDto;

    [key: string]: any;
}

export class MessagePagedResultDto implements IMessagePagedResultDto {
    totalUnread!: number;
    totalCount!: number;
    items!: GetMessagesForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IMessagePagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalUnread = _data["totalUnread"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMessagesForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MessagePagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessagePagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalUnread"] = this.totalUnread;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMessagePagedResultDto {
    totalUnread: number;
    totalCount: number;
    items: GetMessagesForViewDto[] | undefined;

    [key: string]: any;
}

export class GetUsersForMessageDto implements IGetUsersForMessageDto {
    users!: NameValueOfString;
    tenantId!: number | undefined;
    tenantName!: string | undefined;
    emailAddress!: string | undefined;
    surname!: string | undefined;
    profilePictureId!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetUsersForMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.users = _data["users"] ? NameValueOfString.fromJS(_data["users"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.emailAddress = _data["emailAddress"];
            this.surname = _data["surname"];
            this.profilePictureId = _data["profilePictureId"];
        }
    }

    static fromJS(data: any): GetUsersForMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersForMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["users"] = this.users ? this.users.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["emailAddress"] = this.emailAddress;
        data["surname"] = this.surname;
        data["profilePictureId"] = this.profilePictureId;
        return data;
    }
}

export interface IGetUsersForMessageDto {
    users: NameValueOfString;
    tenantId: number | undefined;
    tenantName: string | undefined;
    emailAddress: string | undefined;
    surname: string | undefined;
    profilePictureId: string | undefined;

    [key: string]: any;
}

export class CreateMessageInput implements ICreateMessageInput {
    relatedEntityId!: number | undefined;
    code!: string | undefined;
    senderId!: number | undefined;
    to!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    bodyFormat!: string | undefined;
    sendDate!: moment.Moment;
    receiveDate!: moment.Moment;
    parentId!: number | undefined;
    threadId!: number | undefined;
    mesasgeObjectType!: MesasgeObjectType;
    entityAttachments!: AppEntityAttachmentDto[] | undefined;

    [key: string]: any;

    constructor(data?: ICreateMessageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.relatedEntityId = _data["relatedEntityId"];
            this.code = _data["code"];
            this.senderId = _data["senderId"];
            this.to = _data["to"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.bodyFormat = _data["bodyFormat"];
            this.sendDate = _data["sendDate"] ? moment(_data["sendDate"].toString()) : <any>undefined;
            this.receiveDate = _data["receiveDate"] ? moment(_data["receiveDate"].toString()) : <any>undefined;
            this.parentId = _data["parentId"];
            this.threadId = _data["threadId"];
            this.mesasgeObjectType = _data["mesasgeObjectType"];
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AppEntityAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMessageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["relatedEntityId"] = this.relatedEntityId;
        data["code"] = this.code;
        data["senderId"] = this.senderId;
        data["to"] = this.to;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["bodyFormat"] = this.bodyFormat;
        data["sendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["receiveDate"] = this.receiveDate ? this.receiveDate.toISOString() : <any>undefined;
        data["parentId"] = this.parentId;
        data["threadId"] = this.threadId;
        data["mesasgeObjectType"] = this.mesasgeObjectType;
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMessageInput {
    relatedEntityId: number | undefined;
    code: string | undefined;
    senderId: number | undefined;
    to: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    bodyFormat: string | undefined;
    sendDate: moment.Moment;
    receiveDate: moment.Moment;
    parentId: number | undefined;
    threadId: number | undefined;
    mesasgeObjectType: MesasgeObjectType;
    entityAttachments: AppEntityAttachmentDto[] | undefined;

    [key: string]: any;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: moment.Moment;
    id!: string;

    [key: string]: any;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"];
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
    id: string;

    [key: string]: any;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    targetNotifiers!: string | undefined;
    readonly targetNotifiersList!: string[] | undefined;
    id!: string;

    [key: string]: any;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.targetNotifiers = _data["targetNotifiers"];
            if (Array.isArray(_data["targetNotifiersList"])) {
                (<any>this).targetNotifiersList = [] as any;
                for (let item of _data["targetNotifiersList"])
                    (<any>this).targetNotifiersList!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["targetNotifiers"] = this.targetNotifiers;
        if (Array.isArray(this.targetNotifiersList)) {
            data["targetNotifiersList"] = [];
            for (let item of this.targetNotifiersList)
                data["targetNotifiersList"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    targetNotifiers: string | undefined;
    targetNotifiersList: string[] | undefined;
    id: string;

    [key: string]: any;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number;
    totalCount!: number;
    items!: UserNotification[] | undefined;

    [key: string]: any;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.unreadCount = _data["unreadCount"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;

    [key: string]: any;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    [key: string]: any;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfGuid {
    id: string;

    [key: string]: any;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;

    [key: string]: any;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;

    [key: string]: any;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    [key: string]: any;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    [key: string]: any;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;

    [key: string]: any;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    [key: string]: any;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;

    [key: string]: any;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;

    [key: string]: any;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment;
    id!: number;

    [key: string]: any;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? moment(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;

    [key: string]: any;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment;
    id!: number;

    [key: string]: any;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? moment(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;

    [key: string]: any;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    [key: string]: any;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;

    [key: string]: any;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    [key: string]: any;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;

    [key: string]: any;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    [key: string]: any;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;

    [key: string]: any;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    [key: string]: any;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;

    [key: string]: any;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    [key: string]: any;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;

    [key: string]: any;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    [key: string]: any;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;

    [key: string]: any;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    [key: string]: any;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;

    [key: string]: any;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean;
    additionalData!: AdditionalData | undefined;

    [key: string]: any;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.isFree = _data["isFree"];
            this.additionalData = _data["additionalData"] ? AdditionalData.fromJS(_data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
    additionalData: AdditionalData | undefined;

    [key: string]: any;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto;
    additionalPrice!: number;

    [key: string]: any;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            this.additionalPrice = _data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;

    [key: string]: any;
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number;
    editionPaymentType!: EditionPaymentType;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled!: boolean;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    [key: string]: any;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.editionId = _data["editionId"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = _data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = _data["recurringPaymentEnabled"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data;
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;

    [key: string]: any;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;

    [key: string]: any;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.gateway = _data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data;
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;

    [key: string]: any;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number;
    editionId!: number;
    dayCount!: number;
    paymentPeriodType!: string | undefined;
    externalPaymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.payerId = _data["payerId"];
            this.status = _data["status"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.tenantId = _data["tenantId"];
            this.invoiceNo = _data["invoiceNo"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["externalPaymentId"] = this.externalPaymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    externalPaymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number;
    items!: SubscriptionPaymentListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;

    [key: string]: any;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType;
    supportsRecurringPayments!: boolean;

    [key: string]: any;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.gatewayType = _data["gatewayType"];
            this.supportsRecurringPayments = _data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data;
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;

    [key: string]: any;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;
    amount!: number;
    editionId!: number;
    tenantId!: number;
    dayCount!: number;
    paymentPeriodType!: PaymentPeriodType;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number;
    status!: SubscriptionPaymentStatus;
    isRecurring!: boolean;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    editionPaymentType!: EditionPaymentType;
    id!: number;

    [key: string]: any;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.tenantId = _data["tenantId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.status = _data["status"];
            this.isRecurring = _data["isRecurring"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["editionPaymentType"] = this.editionPaymentType;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    editionPaymentType: EditionPaymentType;
    id: number;

    [key: string]: any;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    [key: string]: any;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.clientId = _data["clientId"];
            this.demoUsername = _data["demoUsername"];
            this.demoPassword = _data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data;
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;

    [key: string]: any;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    [key: string]: any;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    [key: string]: any;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    [key: string]: any;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;

    [key: string]: any;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;

    [key: string]: any;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    [key: string]: any;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;

    [key: string]: any;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    [key: string]: any;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;

    [key: string]: any;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    [key: string]: any;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;

    [key: string]: any;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    [key: string]: any;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    [key: string]: any;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string;
    x!: number;
    y!: number;
    width!: number;
    height!: number;

    [key: string]: any;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fileToken = _data["fileToken"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number;
    y: number;
    width: number;
    height: number;

    [key: string]: any;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting;

    [key: string]: any;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;

    [key: string]: any;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    [key: string]: any;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;

    [key: string]: any;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: moment.Moment;
    id!: number;

    [key: string]: any;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    [key: string]: any;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    [key: string]: any;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    [key: string]: any;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;

    [key: string]: any;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    [key: string]: any;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    [key: string]: any;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    [key: string]: any;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    [key: string]: any;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    [key: string]: any;

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : new RoleEditDto();
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];

    [key: string]: any;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    memberId!: number;
    accountId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.memberId = _data["memberId"];
            this.accountId = _data["accountId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["memberId"] = this.memberId;
        data["accountId"] = this.accountId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    memberId: number;
    accountId: number | undefined;
    id: number;

    [key: string]: any;
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean;
    isFree!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            this.trialDayCount = _data["trialDayCount"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.isHighestEdition = _data["isHighestEdition"];
            this.isFree = _data["isFree"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;

    [key: string]: any;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean;
    subscriptionPaymentType!: SubscriptionPaymentType;
    edition!: EditionInfoDto;
    creationTime!: moment.Moment;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    currencyInfoDto!: CurrencyInfoDto;
    id!: number;

    [key: string]: any;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.logoId = _data["logoId"];
            this.logoFileType = _data["logoFileType"];
            this.customCssId = _data["customCssId"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? moment(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.subscriptionPaymentType = _data["subscriptionPaymentType"];
            this.edition = _data["edition"] ? EditionInfoDto.fromJS(_data["edition"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionDateString = _data["subscriptionDateString"];
            this.creationTimeString = _data["creationTimeString"];
            this.currencyInfoDto = _data["currencyInfoDto"] ? CurrencyInfoDto.fromJS(_data["currencyInfoDto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["currencyInfoDto"] = this.currencyInfoDto ? this.currencyInfoDto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    currencyInfoDto: CurrencyInfoDto;
    id: number;

    [key: string]: any;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean;
    userDelegationIsEnabled!: boolean;
    features!: { [key: string]: boolean; } | undefined;

    [key: string]: any;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currencySign = _data["currencySign"];
            this.allowTenantsToChangeEmailSettings = _data["allowTenantsToChangeEmailSettings"];
            this.userDelegationIsEnabled = _data["userDelegationIsEnabled"];
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        data["userDelegationIsEnabled"] = this.userDelegationIsEnabled;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    userDelegationIsEnabled: boolean;
    features: { [key: string]: boolean; } | undefined;

    [key: string]: any;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    [key: string]: any;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.layoutType = _data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["layoutType"] = this.layoutType;
        return data;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;

    [key: string]: any;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean;
    mobileFixedHeader!: boolean;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;
    headerMenuArrows!: boolean;

    [key: string]: any;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.desktopFixedHeader = _data["desktopFixedHeader"];
            this.mobileFixedHeader = _data["mobileFixedHeader"];
            this.headerSkin = _data["headerSkin"];
            this.minimizeDesktopHeaderType = _data["minimizeDesktopHeaderType"];
            this.headerMenuArrows = _data["headerMenuArrows"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        data["headerMenuArrows"] = this.headerMenuArrows;
        return data;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean;

    [key: string]: any;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean;
    subheaderStyle!: string | undefined;

    [key: string]: any;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fixedSubHeader = _data["fixedSubHeader"];
            this.subheaderStyle = _data["subheaderStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        return data;
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;

    [key: string]: any;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    submenuToggle!: string | undefined;
    searchActive!: boolean;

    [key: string]: any;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.position = _data["position"];
            this.asideSkin = _data["asideSkin"];
            this.fixedAside = _data["fixedAside"];
            this.allowAsideMinimizing = _data["allowAsideMinimizing"];
            this.defaultMinimizedAside = _data["defaultMinimizedAside"];
            this.submenuToggle = _data["submenuToggle"];
            this.searchActive = _data["searchActive"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        return data;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;

    [key: string]: any;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    [key: string]: any;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fixedFooter = _data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fixedFooter"] = this.fixedFooter;
        return data;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;

    [key: string]: any;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto;
    header!: ThemeHeaderSettingsDto;
    subHeader!: ThemeSubHeaderSettingsDto;
    menu!: ThemeMenuSettingsDto;
    footer!: ThemeFooterSettingsDto;

    [key: string]: any;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.theme = _data["theme"];
            this.layout = _data["layout"] ? ThemeLayoutSettingsDto.fromJS(_data["layout"]) : <any>undefined;
            this.header = _data["header"] ? ThemeHeaderSettingsDto.fromJS(_data["header"]) : <any>undefined;
            this.subHeader = _data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(_data["subHeader"]) : <any>undefined;
            this.menu = _data["menu"] ? ThemeMenuSettingsDto.fromJS(_data["menu"]) : <any>undefined;
            this.footer = _data["footer"] ? ThemeFooterSettingsDto.fromJS(_data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;

    [key: string]: any;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    [key: string]: any;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.baseSettings = _data["baseSettings"] ? ThemeSettingsDto.fromJS(_data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = _data["isLeftMenuUsed"];
            this.isTopMenuUsed = _data["isTopMenuUsed"];
            this.isTabMenuUsed = _data["isTabMenuUsed"];
            this.allowMenuScroll = _data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;

    [key: string]: any;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;

    [key: string]: any;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;

    [key: string]: any;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    [key: string]: any;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;

    [key: string]: any;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    [key: string]: any;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.publishableKey = _data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["publishableKey"] = this.publishableKey;
        return data;
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;

    [key: string]: any;
}

export class StripeCreatePaymentSessionInput implements IStripeCreatePaymentSessionInput {
    paymentId!: number;
    successUrl!: string | undefined;
    cancelUrl!: string | undefined;

    [key: string]: any;

    constructor(data?: IStripeCreatePaymentSessionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.successUrl = _data["successUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): StripeCreatePaymentSessionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreatePaymentSessionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["successUrl"] = this.successUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data;
    }
}

export interface IStripeCreatePaymentSessionInput {
    paymentId: number;
    successUrl: string | undefined;
    cancelUrl: string | undefined;

    [key: string]: any;
}

export class StripePaymentResultOutput implements IStripePaymentResultOutput {
    paymentDone!: boolean;

    [key: string]: any;

    constructor(data?: IStripePaymentResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentDone = _data["paymentDone"];
        }
    }

    static fromJS(data: any): StripePaymentResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StripePaymentResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentDone"] = this.paymentDone;
        return data;
    }
}

export interface IStripePaymentResultOutput {
    paymentDone: boolean;

    [key: string]: any;
}

export class SuiIconDto implements ISuiIconDto {
    name!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISuiIconDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SuiIconDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuiIconDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ISuiIconDto {
    name: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetSuiIconForViewDto implements IGetSuiIconForViewDto {
    suiIcon!: SuiIconDto;

    [key: string]: any;

    constructor(data?: IGetSuiIconForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.suiIcon = _data["suiIcon"] ? SuiIconDto.fromJS(_data["suiIcon"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSuiIconForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSuiIconForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["suiIcon"] = this.suiIcon ? this.suiIcon.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSuiIconForViewDto {
    suiIcon: SuiIconDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetSuiIconForViewDto implements IPagedResultDtoOfGetSuiIconForViewDto {
    totalCount!: number;
    items!: GetSuiIconForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSuiIconForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSuiIconForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSuiIconForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSuiIconForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSuiIconForViewDto {
    totalCount: number;
    items: GetSuiIconForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSuiIconDto implements ICreateOrEditSuiIconDto {
    name!: string;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSuiIconDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSuiIconDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSuiIconDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSuiIconDto {
    name: string;
    id: number | undefined;

    [key: string]: any;
}

export class GetSuiIconForEditOutput implements IGetSuiIconForEditOutput {
    suiIcon!: CreateOrEditSuiIconDto;

    [key: string]: any;

    constructor(data?: IGetSuiIconForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.suiIcon = _data["suiIcon"] ? CreateOrEditSuiIconDto.fromJS(_data["suiIcon"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSuiIconForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSuiIconForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["suiIcon"] = this.suiIcon ? this.suiIcon.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSuiIconForEditOutput {
    suiIcon: CreateOrEditSuiIconDto;

    [key: string]: any;
}

export class SycApplicationDto implements ISycApplicationDto {
    code!: string | undefined;
    name!: string | undefined;
    notes!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycApplicationDto {
    code: string | undefined;
    name: string | undefined;
    notes: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycApplicationForViewDto implements IGetSycApplicationForViewDto {
    sycApplication!: SycApplicationDto;

    [key: string]: any;

    constructor(data?: IGetSycApplicationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycApplication = _data["sycApplication"] ? SycApplicationDto.fromJS(_data["sycApplication"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycApplicationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycApplicationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycApplication"] = this.sycApplication ? this.sycApplication.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycApplicationForViewDto {
    sycApplication: SycApplicationDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycApplicationForViewDto implements IPagedResultDtoOfGetSycApplicationForViewDto {
    totalCount!: number;
    items!: GetSycApplicationForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycApplicationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycApplicationForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycApplicationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycApplicationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycApplicationForViewDto {
    totalCount: number;
    items: GetSycApplicationForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycApplicationDto implements ICreateOrEditSycApplicationDto {
    code!: string;
    name!: string | undefined;
    notes!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycApplicationDto {
    code: string;
    name: string | undefined;
    notes: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycApplicationForEditOutput implements IGetSycApplicationForEditOutput {
    sycApplication!: CreateOrEditSycApplicationDto;

    [key: string]: any;

    constructor(data?: IGetSycApplicationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycApplication = _data["sycApplication"] ? CreateOrEditSycApplicationDto.fromJS(_data["sycApplication"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycApplicationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycApplicationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycApplication"] = this.sycApplication ? this.sycApplication.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycApplicationForEditOutput {
    sycApplication: CreateOrEditSycApplicationDto;

    [key: string]: any;
}

export class SycAttachmentTypeDto implements ISycAttachmentTypeDto {
    name!: string | undefined;
    type!: AttachmentType;
    extension!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycAttachmentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.type = _data["type"];
            this.extension = _data["extension"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycAttachmentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycAttachmentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["type"] = this.type;
        data["extension"] = this.extension;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycAttachmentTypeDto {
    name: string | undefined;
    type: AttachmentType;
    extension: string | undefined;
    id: number;

    [key: string]: any;
}

export class SycAttachmentCategoryDto implements ISycAttachmentCategoryDto {
    code!: string | undefined;
    name!: string | undefined;
    attributes!: string | undefined;
    parentCode!: string | undefined;
    parentId!: number | undefined;
    aspectRatio!: string | undefined;
    message!: string | undefined;
    maxFileSize!: number | undefined;
    type!: AttachmentType;
    sycAttachmentTypeDto!: SycAttachmentTypeDto[] | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycAttachmentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.attributes = _data["attributes"];
            this.parentCode = _data["parentCode"];
            this.parentId = _data["parentId"];
            this.aspectRatio = _data["aspectRatio"];
            this.message = _data["message"];
            this.maxFileSize = _data["maxFileSize"];
            this.type = _data["type"];
            if (Array.isArray(_data["sycAttachmentTypeDto"])) {
                this.sycAttachmentTypeDto = [] as any;
                for (let item of _data["sycAttachmentTypeDto"])
                    this.sycAttachmentTypeDto!.push(SycAttachmentTypeDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycAttachmentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycAttachmentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["attributes"] = this.attributes;
        data["parentCode"] = this.parentCode;
        data["parentId"] = this.parentId;
        data["aspectRatio"] = this.aspectRatio;
        data["message"] = this.message;
        data["maxFileSize"] = this.maxFileSize;
        data["type"] = this.type;
        if (Array.isArray(this.sycAttachmentTypeDto)) {
            data["sycAttachmentTypeDto"] = [];
            for (let item of this.sycAttachmentTypeDto)
                data["sycAttachmentTypeDto"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ISycAttachmentCategoryDto {
    code: string | undefined;
    name: string | undefined;
    attributes: string | undefined;
    parentCode: string | undefined;
    parentId: number | undefined;
    aspectRatio: string | undefined;
    message: string | undefined;
    maxFileSize: number | undefined;
    type: AttachmentType;
    sycAttachmentTypeDto: SycAttachmentTypeDto[] | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycAttachmentCategoryForViewDto implements IGetSycAttachmentCategoryForViewDto {
    sycAttachmentCategory!: SycAttachmentCategoryDto;
    sycAttachmentCategoryName!: string | undefined;
    imgURL!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycAttachmentCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycAttachmentCategory = _data["sycAttachmentCategory"] ? SycAttachmentCategoryDto.fromJS(_data["sycAttachmentCategory"]) : <any>undefined;
            this.sycAttachmentCategoryName = _data["sycAttachmentCategoryName"];
            this.imgURL = _data["imgURL"];
        }
    }

    static fromJS(data: any): GetSycAttachmentCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycAttachmentCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycAttachmentCategory"] = this.sycAttachmentCategory ? this.sycAttachmentCategory.toJSON() : <any>undefined;
        data["sycAttachmentCategoryName"] = this.sycAttachmentCategoryName;
        data["imgURL"] = this.imgURL;
        return data;
    }
}

export interface IGetSycAttachmentCategoryForViewDto {
    sycAttachmentCategory: SycAttachmentCategoryDto;
    sycAttachmentCategoryName: string | undefined;
    imgURL: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycAttachmentCategoryForViewDto implements IPagedResultDtoOfGetSycAttachmentCategoryForViewDto {
    totalCount!: number;
    items!: GetSycAttachmentCategoryForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycAttachmentCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycAttachmentCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycAttachmentCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycAttachmentCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycAttachmentCategoryForViewDto {
    totalCount: number;
    items: GetSycAttachmentCategoryForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycAttachmentCategoryDto implements ICreateOrEditSycAttachmentCategoryDto {
    code!: string;
    name!: string;
    attributes!: string | undefined;
    parentCode!: string | undefined;
    parentId!: number | undefined;
    aspectRatio!: string | undefined;
    message!: string | undefined;
    maxFileSize!: number | undefined;
    type!: AttachmentType;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycAttachmentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.attributes = _data["attributes"];
            this.parentCode = _data["parentCode"];
            this.parentId = _data["parentId"];
            this.aspectRatio = _data["aspectRatio"];
            this.message = _data["message"];
            this.maxFileSize = _data["maxFileSize"];
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycAttachmentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycAttachmentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["attributes"] = this.attributes;
        data["parentCode"] = this.parentCode;
        data["parentId"] = this.parentId;
        data["aspectRatio"] = this.aspectRatio;
        data["message"] = this.message;
        data["maxFileSize"] = this.maxFileSize;
        data["type"] = this.type;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycAttachmentCategoryDto {
    code: string;
    name: string;
    attributes: string | undefined;
    parentCode: string | undefined;
    parentId: number | undefined;
    aspectRatio: string | undefined;
    message: string | undefined;
    maxFileSize: number | undefined;
    type: AttachmentType;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycAttachmentCategoryForEditOutput implements IGetSycAttachmentCategoryForEditOutput {
    sycAttachmentCategory!: CreateOrEditSycAttachmentCategoryDto;
    sycAttachmentCategoryName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycAttachmentCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycAttachmentCategory = _data["sycAttachmentCategory"] ? CreateOrEditSycAttachmentCategoryDto.fromJS(_data["sycAttachmentCategory"]) : <any>undefined;
            this.sycAttachmentCategoryName = _data["sycAttachmentCategoryName"];
        }
    }

    static fromJS(data: any): GetSycAttachmentCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycAttachmentCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycAttachmentCategory"] = this.sycAttachmentCategory ? this.sycAttachmentCategory.toJSON() : <any>undefined;
        data["sycAttachmentCategoryName"] = this.sycAttachmentCategoryName;
        return data;
    }
}

export interface IGetSycAttachmentCategoryForEditOutput {
    sycAttachmentCategory: CreateOrEditSycAttachmentCategoryDto;
    sycAttachmentCategoryName: string | undefined;

    [key: string]: any;
}

export class SycAttachmentCategorySycAttachmentCategoryLookupTableDto implements ISycAttachmentCategorySycAttachmentCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;
    code!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycAttachmentCategorySycAttachmentCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): SycAttachmentCategorySycAttachmentCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycAttachmentCategorySycAttachmentCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        return data;
    }
}

export interface ISycAttachmentCategorySycAttachmentCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
    code: string | undefined;

    [key: string]: any;
}

export class GetSycAttachmentTypeForViewDto implements IGetSycAttachmentTypeForViewDto {
    sycAttachmentType!: SycAttachmentTypeDto;

    [key: string]: any;

    constructor(data?: IGetSycAttachmentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycAttachmentType = _data["sycAttachmentType"] ? SycAttachmentTypeDto.fromJS(_data["sycAttachmentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycAttachmentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycAttachmentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycAttachmentType"] = this.sycAttachmentType ? this.sycAttachmentType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycAttachmentTypeForViewDto {
    sycAttachmentType: SycAttachmentTypeDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycAttachmentTypeForViewDto implements IPagedResultDtoOfGetSycAttachmentTypeForViewDto {
    totalCount!: number;
    items!: GetSycAttachmentTypeForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycAttachmentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycAttachmentTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycAttachmentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycAttachmentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycAttachmentTypeForViewDto {
    totalCount: number;
    items: GetSycAttachmentTypeForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycAttachmentTypeDto implements ICreateOrEditSycAttachmentTypeDto {
    name!: string;
    type!: AttachmentType;
    extension!: string;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycAttachmentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.type = _data["type"];
            this.extension = _data["extension"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycAttachmentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycAttachmentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["type"] = this.type;
        data["extension"] = this.extension;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycAttachmentTypeDto {
    name: string;
    type: AttachmentType;
    extension: string;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycAttachmentTypeForEditOutput implements IGetSycAttachmentTypeForEditOutput {
    sycAttachmentType!: CreateOrEditSycAttachmentTypeDto;

    [key: string]: any;

    constructor(data?: IGetSycAttachmentTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycAttachmentType = _data["sycAttachmentType"] ? CreateOrEditSycAttachmentTypeDto.fromJS(_data["sycAttachmentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycAttachmentTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycAttachmentTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycAttachmentType"] = this.sycAttachmentType ? this.sycAttachmentType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycAttachmentTypeForEditOutput {
    sycAttachmentType: CreateOrEditSycAttachmentTypeDto;

    [key: string]: any;
}

export class SycCounterDto implements ISycCounterDto {
    counter!: number;
    sycSegmentIdentifierDefinitionId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycCounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.counter = _data["counter"];
            this.sycSegmentIdentifierDefinitionId = _data["sycSegmentIdentifierDefinitionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycCounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycCounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["counter"] = this.counter;
        data["sycSegmentIdentifierDefinitionId"] = this.sycSegmentIdentifierDefinitionId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycCounterDto {
    counter: number;
    sycSegmentIdentifierDefinitionId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycCounterForViewDto implements IGetSycCounterForViewDto {
    sycCounter!: SycCounterDto;
    sycSegmentIdentifierDefinitionName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycCounterForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycCounter = _data["sycCounter"] ? SycCounterDto.fromJS(_data["sycCounter"]) : <any>undefined;
            this.sycSegmentIdentifierDefinitionName = _data["sycSegmentIdentifierDefinitionName"];
        }
    }

    static fromJS(data: any): GetSycCounterForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycCounterForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycCounter"] = this.sycCounter ? this.sycCounter.toJSON() : <any>undefined;
        data["sycSegmentIdentifierDefinitionName"] = this.sycSegmentIdentifierDefinitionName;
        return data;
    }
}

export interface IGetSycCounterForViewDto {
    sycCounter: SycCounterDto;
    sycSegmentIdentifierDefinitionName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycCounterForViewDto implements IPagedResultDtoOfGetSycCounterForViewDto {
    totalCount!: number;
    items!: GetSycCounterForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycCounterForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycCounterForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycCounterForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycCounterForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycCounterForViewDto {
    totalCount: number;
    items: GetSycCounterForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycCounterDto implements ICreateOrEditSycCounterDto {
    counter!: number;
    sycSegmentIdentifierDefinitionId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycCounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.counter = _data["counter"];
            this.sycSegmentIdentifierDefinitionId = _data["sycSegmentIdentifierDefinitionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycCounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycCounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["counter"] = this.counter;
        data["sycSegmentIdentifierDefinitionId"] = this.sycSegmentIdentifierDefinitionId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycCounterDto {
    counter: number;
    sycSegmentIdentifierDefinitionId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycCounterForEditOutput implements IGetSycCounterForEditOutput {
    sycCounter!: CreateOrEditSycCounterDto;
    sycSegmentIdentifierDefinitionName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycCounterForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycCounter = _data["sycCounter"] ? CreateOrEditSycCounterDto.fromJS(_data["sycCounter"]) : <any>undefined;
            this.sycSegmentIdentifierDefinitionName = _data["sycSegmentIdentifierDefinitionName"];
        }
    }

    static fromJS(data: any): GetSycCounterForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycCounterForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycCounter"] = this.sycCounter ? this.sycCounter.toJSON() : <any>undefined;
        data["sycSegmentIdentifierDefinitionName"] = this.sycSegmentIdentifierDefinitionName;
        return data;
    }
}

export interface IGetSycCounterForEditOutput {
    sycCounter: CreateOrEditSycCounterDto;
    sycSegmentIdentifierDefinitionName: string | undefined;

    [key: string]: any;
}

export class SycCounterSycSegmentIdentifierDefinitionLookupTableDto implements ISycCounterSycSegmentIdentifierDefinitionLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycCounterSycSegmentIdentifierDefinitionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycCounterSycSegmentIdentifierDefinitionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycCounterSycSegmentIdentifierDefinitionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycCounterSycSegmentIdentifierDefinitionLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto implements IPagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto {
    totalCount!: number;
    items!: SycCounterSycSegmentIdentifierDefinitionLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SycCounterSycSegmentIdentifierDefinitionLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSycCounterSycSegmentIdentifierDefinitionLookupTableDto {
    totalCount: number;
    items: SycCounterSycSegmentIdentifierDefinitionLookupTableDto[] | undefined;

    [key: string]: any;
}

export class SycEntityLocalization implements ISycEntityLocalization {
    id!: number;
    key!: string | undefined;
    string!: string | undefined;
    objectId!: number;
    language!: string | undefined;
    objectTypeId!: number;
    syObjectId!: SydObject;

    [key: string]: any;

    constructor(data?: ISycEntityLocalization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.key = _data["key"];
            this.string = _data["string"];
            this.objectId = _data["objectId"];
            this.language = _data["language"];
            this.objectTypeId = _data["objectTypeId"];
            this.syObjectId = _data["syObjectId"] ? SydObject.fromJS(_data["syObjectId"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SycEntityLocalization {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityLocalization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["key"] = this.key;
        data["string"] = this.string;
        data["objectId"] = this.objectId;
        data["language"] = this.language;
        data["objectTypeId"] = this.objectTypeId;
        data["syObjectId"] = this.syObjectId ? this.syObjectId.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISycEntityLocalization {
    id: number;
    key: string | undefined;
    string: string | undefined;
    objectId: number;
    language: string | undefined;
    objectTypeId: number;
    syObjectId: SydObject;

    [key: string]: any;
}

export class PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto implements IPagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto {
    totalCount!: number;
    items!: TreeNodeOfGetSycEntityObjectCategoryForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TreeNodeOfGetSycEntityObjectCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTreeNodeOfGetSycEntityObjectCategoryForViewDto {
    totalCount: number;
    items: TreeNodeOfGetSycEntityObjectCategoryForViewDto[] | undefined;

    [key: string]: any;
}

export class TreeviewItem implements ITreeviewItem {
    children!: TreeviewItem[] | undefined;
    text!: string | undefined;
    value!: number;
    checked!: boolean;

    [key: string]: any;

    constructor(data?: ITreeviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeviewItem.fromJS(item));
            }
            this.text = _data["text"];
            this.value = _data["value"];
            this.checked = _data["checked"];
        }
    }

    static fromJS(data: any): TreeviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new TreeviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["text"] = this.text;
        data["value"] = this.value;
        data["checked"] = this.checked;
        return data;
    }
}

export interface ITreeviewItem {
    children: TreeviewItem[] | undefined;
    text: string | undefined;
    value: number;
    checked: boolean;

    [key: string]: any;
}

export class PagedResultDtoOfTreeviewItem implements IPagedResultDtoOfTreeviewItem {
    totalCount!: number;
    items!: TreeviewItem[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTreeviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TreeviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreeviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreeviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTreeviewItem {
    totalCount: number;
    items: TreeviewItem[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycEntityObjectCategoryDto implements ICreateOrEditSycEntityObjectCategoryDto {
    code!: string;
    name!: string;
    objectId!: number;
    parentId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycEntityObjectCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycEntityObjectCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycEntityObjectCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycEntityObjectCategoryDto {
    code: string;
    name: string;
    objectId: number;
    parentId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycEntityObjectCategoryForEditOutput implements IGetSycEntityObjectCategoryForEditOutput {
    sycEntityObjectCategory!: CreateOrEditSycEntityObjectCategoryDto;
    sydObjectName!: string | undefined;
    sycEntityObjectCategoryName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectCategory = _data["sycEntityObjectCategory"] ? CreateOrEditSycEntityObjectCategoryDto.fromJS(_data["sycEntityObjectCategory"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
            this.sycEntityObjectCategoryName = _data["sycEntityObjectCategoryName"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectCategory"] = this.sycEntityObjectCategory ? this.sycEntityObjectCategory.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        data["sycEntityObjectCategoryName"] = this.sycEntityObjectCategoryName;
        return data;
    }
}

export interface IGetSycEntityObjectCategoryForEditOutput {
    sycEntityObjectCategory: CreateOrEditSycEntityObjectCategoryDto;
    sydObjectName: string | undefined;
    sycEntityObjectCategoryName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectCategorySydObjectLookupTableDto implements ISycEntityObjectCategorySydObjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectCategorySydObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectCategorySydObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectCategorySydObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectCategorySydObjectLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto implements ISycEntityObjectCategorySycEntityObjectCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectCategorySycEntityObjectCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectCategorySycEntityObjectCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectCategorySycEntityObjectCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto implements IPagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto {
    totalCount!: number;
    items!: TreeNodeOfGetSycEntityObjectClassificationForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TreeNodeOfGetSycEntityObjectClassificationForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTreeNodeOfGetSycEntityObjectClassificationForViewDto {
    totalCount: number;
    items: TreeNodeOfGetSycEntityObjectClassificationForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycEntityObjectClassificationDto implements ICreateOrEditSycEntityObjectClassificationDto {
    code!: string;
    name!: string;
    objectId!: number | undefined;
    parentId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycEntityObjectClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycEntityObjectClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycEntityObjectClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycEntityObjectClassificationDto {
    code: string;
    name: string;
    objectId: number | undefined;
    parentId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycEntityObjectClassificationForEditOutput implements IGetSycEntityObjectClassificationForEditOutput {
    sycEntityObjectClassification!: CreateOrEditSycEntityObjectClassificationDto;
    sydObjectName!: string | undefined;
    sycEntityObjectClassificationName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectClassificationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectClassification = _data["sycEntityObjectClassification"] ? CreateOrEditSycEntityObjectClassificationDto.fromJS(_data["sycEntityObjectClassification"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
            this.sycEntityObjectClassificationName = _data["sycEntityObjectClassificationName"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectClassificationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectClassificationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectClassification"] = this.sycEntityObjectClassification ? this.sycEntityObjectClassification.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        data["sycEntityObjectClassificationName"] = this.sycEntityObjectClassificationName;
        return data;
    }
}

export interface IGetSycEntityObjectClassificationForEditOutput {
    sycEntityObjectClassification: CreateOrEditSycEntityObjectClassificationDto;
    sydObjectName: string | undefined;
    sycEntityObjectClassificationName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectClassificationSydObjectLookupTableDto implements ISycEntityObjectClassificationSydObjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectClassificationSydObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectClassificationSydObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectClassificationSydObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectClassificationSydObjectLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto implements ISycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectClassificationSycEntityObjectClassificationLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectStatusDto implements ISycEntityObjectStatusDto {
    code!: string | undefined;
    name!: string | undefined;
    objectId!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectStatusDto {
    code: string | undefined;
    name: string | undefined;
    objectId: number;
    id: number;

    [key: string]: any;
}

export class GetSycEntityObjectStatusForViewDto implements IGetSycEntityObjectStatusForViewDto {
    sycEntityObjectStatus!: SycEntityObjectStatusDto;
    sydObjectName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectStatus = _data["sycEntityObjectStatus"] ? SycEntityObjectStatusDto.fromJS(_data["sycEntityObjectStatus"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectStatus"] = this.sycEntityObjectStatus ? this.sycEntityObjectStatus.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        return data;
    }
}

export interface IGetSycEntityObjectStatusForViewDto {
    sycEntityObjectStatus: SycEntityObjectStatusDto;
    sydObjectName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycEntityObjectStatusForViewDto implements IPagedResultDtoOfGetSycEntityObjectStatusForViewDto {
    totalCount!: number;
    items!: GetSycEntityObjectStatusForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycEntityObjectStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycEntityObjectStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycEntityObjectStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycEntityObjectStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycEntityObjectStatusForViewDto {
    totalCount: number;
    items: GetSycEntityObjectStatusForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycEntityObjectStatusDto implements ICreateOrEditSycEntityObjectStatusDto {
    code!: string | undefined;
    name!: string;
    objectId!: number;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycEntityObjectStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.objectId = _data["objectId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycEntityObjectStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycEntityObjectStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["objectId"] = this.objectId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycEntityObjectStatusDto {
    code: string | undefined;
    name: string;
    objectId: number;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycEntityObjectStatusForEditOutput implements IGetSycEntityObjectStatusForEditOutput {
    sycEntityObjectStatus!: CreateOrEditSycEntityObjectStatusDto;
    sydObjectName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectStatus = _data["sycEntityObjectStatus"] ? CreateOrEditSycEntityObjectStatusDto.fromJS(_data["sycEntityObjectStatus"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectStatus"] = this.sycEntityObjectStatus ? this.sycEntityObjectStatus.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        return data;
    }
}

export interface IGetSycEntityObjectStatusForEditOutput {
    sycEntityObjectStatus: CreateOrEditSycEntityObjectStatusDto;
    sydObjectName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectStatusSydObjectLookupTableDto implements ISycEntityObjectStatusSydObjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectStatusSydObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectStatusSydObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectStatusSydObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectStatusSydObjectLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class ItemExtraAttributes implements IItemExtraAttributes {
    extraAttributes!: ExtraAttribute[] | undefined;

    [key: string]: any;

    constructor(data?: IItemExtraAttributes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["extraAttributes"])) {
                this.extraAttributes = [] as any;
                for (let item of _data["extraAttributes"])
                    this.extraAttributes!.push(ExtraAttribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ItemExtraAttributes {
        data = typeof data === 'object' ? data : {};
        let result = new ItemExtraAttributes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.extraAttributes)) {
            data["extraAttributes"] = [];
            for (let item of this.extraAttributes)
                data["extraAttributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IItemExtraAttributes {
    extraAttributes: ExtraAttribute[] | undefined;

    [key: string]: any;
}

export class GetAllEntityObjectTypeOutput implements IGetAllEntityObjectTypeOutput {
    code!: string | undefined;
    name!: string | undefined;
    extraAttributesString!: string | undefined;
    extraAttributes!: ItemExtraAttributes;
    id!: number;

    [key: string]: any;

    constructor(data?: IGetAllEntityObjectTypeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.extraAttributesString = _data["extraAttributesString"];
            this.extraAttributes = _data["extraAttributes"] ? ItemExtraAttributes.fromJS(_data["extraAttributes"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllEntityObjectTypeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEntityObjectTypeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["extraAttributesString"] = this.extraAttributesString;
        data["extraAttributes"] = this.extraAttributes ? this.extraAttributes.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllEntityObjectTypeOutput {
    code: string | undefined;
    name: string | undefined;
    extraAttributesString: string | undefined;
    extraAttributes: ItemExtraAttributes;
    id: number;

    [key: string]: any;
}

export class SycEntityObjectTypeDto implements ISycEntityObjectTypeDto {
    code!: string | undefined;
    name!: string | undefined;
    extraAttributes!: string | undefined;
    objectId!: number;
    parentId!: number | undefined;
    sycIdentifierDefinitionId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycEntityObjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.extraAttributes = _data["extraAttributes"];
            this.objectId = _data["objectId"];
            this.parentId = _data["parentId"];
            this.sycIdentifierDefinitionId = _data["sycIdentifierDefinitionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycEntityObjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["extraAttributes"] = this.extraAttributes;
        data["objectId"] = this.objectId;
        data["parentId"] = this.parentId;
        data["sycIdentifierDefinitionId"] = this.sycIdentifierDefinitionId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycEntityObjectTypeDto {
    code: string | undefined;
    name: string | undefined;
    extraAttributes: string | undefined;
    objectId: number;
    parentId: number | undefined;
    sycIdentifierDefinitionId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycEntityObjectTypeForViewDto implements IGetSycEntityObjectTypeForViewDto {
    sycEntityObjectType!: SycEntityObjectTypeDto;
    sydObjectName!: string | undefined;
    sycEntityObjectTypeName!: string | undefined;
    identifierCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectType = _data["sycEntityObjectType"] ? SycEntityObjectTypeDto.fromJS(_data["sycEntityObjectType"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
            this.sycEntityObjectTypeName = _data["sycEntityObjectTypeName"];
            this.identifierCode = _data["identifierCode"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectType"] = this.sycEntityObjectType ? this.sycEntityObjectType.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        data["sycEntityObjectTypeName"] = this.sycEntityObjectTypeName;
        data["identifierCode"] = this.identifierCode;
        return data;
    }
}

export interface IGetSycEntityObjectTypeForViewDto {
    sycEntityObjectType: SycEntityObjectTypeDto;
    sydObjectName: string | undefined;
    sycEntityObjectTypeName: string | undefined;
    identifierCode: string | undefined;

    [key: string]: any;
}

export class TreeNodeOfGetSycEntityObjectTypeForViewDto implements ITreeNodeOfGetSycEntityObjectTypeForViewDto {
    data!: GetSycEntityObjectTypeForViewDto;
    children!: TreeNodeOfGetSycEntityObjectTypeForViewDto[] | undefined;
    leaf!: boolean;
    expanded!: boolean;
    label!: string | undefined;
    totalChildrenCount!: number | undefined;

    [key: string]: any;

    constructor(data?: ITreeNodeOfGetSycEntityObjectTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? GetSycEntityObjectTypeForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(item));
            }
            this.leaf = _data["leaf"];
            this.expanded = _data["expanded"];
            this.label = _data["label"];
            this.totalChildrenCount = _data["totalChildrenCount"];
        }
    }

    static fromJS(data: any): TreeNodeOfGetSycEntityObjectTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeOfGetSycEntityObjectTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["leaf"] = this.leaf;
        data["expanded"] = this.expanded;
        data["label"] = this.label;
        data["totalChildrenCount"] = this.totalChildrenCount;
        return data;
    }
}

export interface ITreeNodeOfGetSycEntityObjectTypeForViewDto {
    data: GetSycEntityObjectTypeForViewDto;
    children: TreeNodeOfGetSycEntityObjectTypeForViewDto[] | undefined;
    leaf: boolean;
    expanded: boolean;
    label: string | undefined;
    totalChildrenCount: number | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto implements IPagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto {
    totalCount!: number;
    items!: TreeNodeOfGetSycEntityObjectTypeForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TreeNodeOfGetSycEntityObjectTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTreeNodeOfGetSycEntityObjectTypeForViewDto {
    totalCount: number;
    items: TreeNodeOfGetSycEntityObjectTypeForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycEntityObjectTypeDto implements ICreateOrEditSycEntityObjectTypeDto {
    code!: string;
    name!: string;
    extraAttributes!: string | undefined;
    objectId!: number;
    parentId!: number | undefined;
    sycIdentifierDefinitionId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycEntityObjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.extraAttributes = _data["extraAttributes"];
            this.objectId = _data["objectId"];
            this.parentId = _data["parentId"];
            this.sycIdentifierDefinitionId = _data["sycIdentifierDefinitionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycEntityObjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycEntityObjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["extraAttributes"] = this.extraAttributes;
        data["objectId"] = this.objectId;
        data["parentId"] = this.parentId;
        data["sycIdentifierDefinitionId"] = this.sycIdentifierDefinitionId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycEntityObjectTypeDto {
    code: string;
    name: string;
    extraAttributes: string | undefined;
    objectId: number;
    parentId: number | undefined;
    sycIdentifierDefinitionId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycEntityObjectTypeForEditOutput implements IGetSycEntityObjectTypeForEditOutput {
    sycEntityObjectType!: CreateOrEditSycEntityObjectTypeDto;
    sydObjectName!: string | undefined;
    sycEntityObjectTypeName!: string | undefined;
    identifierCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycEntityObjectTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycEntityObjectType = _data["sycEntityObjectType"] ? CreateOrEditSycEntityObjectTypeDto.fromJS(_data["sycEntityObjectType"]) : <any>undefined;
            this.sydObjectName = _data["sydObjectName"];
            this.sycEntityObjectTypeName = _data["sycEntityObjectTypeName"];
            this.identifierCode = _data["identifierCode"];
        }
    }

    static fromJS(data: any): GetSycEntityObjectTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycEntityObjectTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycEntityObjectType"] = this.sycEntityObjectType ? this.sycEntityObjectType.toJSON() : <any>undefined;
        data["sydObjectName"] = this.sydObjectName;
        data["sycEntityObjectTypeName"] = this.sycEntityObjectTypeName;
        data["identifierCode"] = this.identifierCode;
        return data;
    }
}

export interface IGetSycEntityObjectTypeForEditOutput {
    sycEntityObjectType: CreateOrEditSycEntityObjectTypeDto;
    sydObjectName: string | undefined;
    sycEntityObjectTypeName: string | undefined;
    identifierCode: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectTypeSydObjectLookupTableDto implements ISycEntityObjectTypeSydObjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectTypeSydObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectTypeSydObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectTypeSydObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectTypeSydObjectLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectTypeSycEntityObjectTypeLookupTableDto implements ISycEntityObjectTypeSycEntityObjectTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectTypeSycEntityObjectTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectTypeSycEntityObjectTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectTypeSycEntityObjectTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectTypeSycEntityObjectTypeLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycEntityObjectTypeSycIdentifierDefinitionLookupTableDto implements ISycEntityObjectTypeSycIdentifierDefinitionLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycEntityObjectTypeSycIdentifierDefinitionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycEntityObjectTypeSycIdentifierDefinitionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycEntityObjectTypeSycIdentifierDefinitionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycEntityObjectTypeSycIdentifierDefinitionLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto implements IPagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto {
    totalCount!: number;
    items!: SycEntityObjectTypeSycIdentifierDefinitionLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SycEntityObjectTypeSycIdentifierDefinitionLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSycEntityObjectTypeSycIdentifierDefinitionLookupTableDto {
    totalCount: number;
    items: SycEntityObjectTypeSycIdentifierDefinitionLookupTableDto[] | undefined;

    [key: string]: any;
}

export class SycIdentifierDefinitionDto implements ISycIdentifierDefinitionDto {
    code!: string | undefined;
    isTenantLevel!: boolean;
    numberOfSegments!: number;
    maxLength!: number;
    minSegmentLength!: number;
    maxSegmentLength!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycIdentifierDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.isTenantLevel = _data["isTenantLevel"];
            this.numberOfSegments = _data["numberOfSegments"];
            this.maxLength = _data["maxLength"];
            this.minSegmentLength = _data["minSegmentLength"];
            this.maxSegmentLength = _data["maxSegmentLength"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycIdentifierDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycIdentifierDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["isTenantLevel"] = this.isTenantLevel;
        data["numberOfSegments"] = this.numberOfSegments;
        data["maxLength"] = this.maxLength;
        data["minSegmentLength"] = this.minSegmentLength;
        data["maxSegmentLength"] = this.maxSegmentLength;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycIdentifierDefinitionDto {
    code: string | undefined;
    isTenantLevel: boolean;
    numberOfSegments: number;
    maxLength: number;
    minSegmentLength: number;
    maxSegmentLength: number;
    id: number;

    [key: string]: any;
}

export class SycSegmentIdentifierDefinitionDto implements ISycSegmentIdentifierDefinitionDto {
    code!: string | undefined;
    name!: string | undefined;
    segmentNumber!: number;
    segmentHeader!: string | undefined;
    segmentMask!: string | undefined;
    segmentLength!: number;
    segmentType!: string | undefined;
    isAutoGenerated!: boolean;
    isEditable!: boolean;
    isVisible!: boolean;
    codeStartingValue!: number;
    lookOrFieldName!: string | undefined;
    sycIdentifierDefinitionId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycSegmentIdentifierDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.segmentNumber = _data["segmentNumber"];
            this.segmentHeader = _data["segmentHeader"];
            this.segmentMask = _data["segmentMask"];
            this.segmentLength = _data["segmentLength"];
            this.segmentType = _data["segmentType"];
            this.isAutoGenerated = _data["isAutoGenerated"];
            this.isEditable = _data["isEditable"];
            this.isVisible = _data["isVisible"];
            this.codeStartingValue = _data["codeStartingValue"];
            this.lookOrFieldName = _data["lookOrFieldName"];
            this.sycIdentifierDefinitionId = _data["sycIdentifierDefinitionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycSegmentIdentifierDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycSegmentIdentifierDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["segmentNumber"] = this.segmentNumber;
        data["segmentHeader"] = this.segmentHeader;
        data["segmentMask"] = this.segmentMask;
        data["segmentLength"] = this.segmentLength;
        data["segmentType"] = this.segmentType;
        data["isAutoGenerated"] = this.isAutoGenerated;
        data["isEditable"] = this.isEditable;
        data["isVisible"] = this.isVisible;
        data["codeStartingValue"] = this.codeStartingValue;
        data["lookOrFieldName"] = this.lookOrFieldName;
        data["sycIdentifierDefinitionId"] = this.sycIdentifierDefinitionId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycSegmentIdentifierDefinitionDto {
    code: string | undefined;
    name: string | undefined;
    segmentNumber: number;
    segmentHeader: string | undefined;
    segmentMask: string | undefined;
    segmentLength: number;
    segmentType: string | undefined;
    isAutoGenerated: boolean;
    isEditable: boolean;
    isVisible: boolean;
    codeStartingValue: number;
    lookOrFieldName: string | undefined;
    sycIdentifierDefinitionId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycIdentifierDefinitionForViewDto implements IGetSycIdentifierDefinitionForViewDto {
    sycIdentifierDefinition!: SycIdentifierDefinitionDto;
    sycSegmentIdentifierDefinitions!: SycSegmentIdentifierDefinitionDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetSycIdentifierDefinitionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycIdentifierDefinition = _data["sycIdentifierDefinition"] ? SycIdentifierDefinitionDto.fromJS(_data["sycIdentifierDefinition"]) : <any>undefined;
            if (Array.isArray(_data["sycSegmentIdentifierDefinitions"])) {
                this.sycSegmentIdentifierDefinitions = [] as any;
                for (let item of _data["sycSegmentIdentifierDefinitions"])
                    this.sycSegmentIdentifierDefinitions!.push(SycSegmentIdentifierDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSycIdentifierDefinitionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycIdentifierDefinitionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycIdentifierDefinition"] = this.sycIdentifierDefinition ? this.sycIdentifierDefinition.toJSON() : <any>undefined;
        if (Array.isArray(this.sycSegmentIdentifierDefinitions)) {
            data["sycSegmentIdentifierDefinitions"] = [];
            for (let item of this.sycSegmentIdentifierDefinitions)
                data["sycSegmentIdentifierDefinitions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSycIdentifierDefinitionForViewDto {
    sycIdentifierDefinition: SycIdentifierDefinitionDto;
    sycSegmentIdentifierDefinitions: SycSegmentIdentifierDefinitionDto[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycIdentifierDefinitionForViewDto implements IPagedResultDtoOfGetSycIdentifierDefinitionForViewDto {
    totalCount!: number;
    items!: GetSycIdentifierDefinitionForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycIdentifierDefinitionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycIdentifierDefinitionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycIdentifierDefinitionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycIdentifierDefinitionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycIdentifierDefinitionForViewDto {
    totalCount: number;
    items: GetSycIdentifierDefinitionForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycIdentifierDefinitionDto implements ICreateOrEditSycIdentifierDefinitionDto {
    code!: string | undefined;
    isTenantLevel!: boolean;
    numberOfSegments!: number;
    maxLength!: number;
    minSegmentLength!: number;
    maxSegmentLength!: number;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycIdentifierDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.isTenantLevel = _data["isTenantLevel"];
            this.numberOfSegments = _data["numberOfSegments"];
            this.maxLength = _data["maxLength"];
            this.minSegmentLength = _data["minSegmentLength"];
            this.maxSegmentLength = _data["maxSegmentLength"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycIdentifierDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycIdentifierDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["isTenantLevel"] = this.isTenantLevel;
        data["numberOfSegments"] = this.numberOfSegments;
        data["maxLength"] = this.maxLength;
        data["minSegmentLength"] = this.minSegmentLength;
        data["maxSegmentLength"] = this.maxSegmentLength;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycIdentifierDefinitionDto {
    code: string | undefined;
    isTenantLevel: boolean;
    numberOfSegments: number;
    maxLength: number;
    minSegmentLength: number;
    maxSegmentLength: number;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycIdentifierDefinitionForEditOutput implements IGetSycIdentifierDefinitionForEditOutput {
    sycIdentifierDefinition!: CreateOrEditSycIdentifierDefinitionDto;

    [key: string]: any;

    constructor(data?: IGetSycIdentifierDefinitionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycIdentifierDefinition = _data["sycIdentifierDefinition"] ? CreateOrEditSycIdentifierDefinitionDto.fromJS(_data["sycIdentifierDefinition"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycIdentifierDefinitionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycIdentifierDefinitionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycIdentifierDefinition"] = this.sycIdentifierDefinition ? this.sycIdentifierDefinition.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycIdentifierDefinitionForEditOutput {
    sycIdentifierDefinition: CreateOrEditSycIdentifierDefinitionDto;

    [key: string]: any;
}

export class SycPlanDto implements ISycPlanDto {
    code!: string | undefined;
    name!: string | undefined;
    notes!: string | undefined;
    applicationId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.applicationId = _data["applicationId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["applicationId"] = this.applicationId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycPlanDto {
    code: string | undefined;
    name: string | undefined;
    notes: string | undefined;
    applicationId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycPlanForViewDto implements IGetSycPlanForViewDto {
    sycPlan!: SycPlanDto;
    sycApplicationName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycPlanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycPlan = _data["sycPlan"] ? SycPlanDto.fromJS(_data["sycPlan"]) : <any>undefined;
            this.sycApplicationName = _data["sycApplicationName"];
        }
    }

    static fromJS(data: any): GetSycPlanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycPlanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycPlan"] = this.sycPlan ? this.sycPlan.toJSON() : <any>undefined;
        data["sycApplicationName"] = this.sycApplicationName;
        return data;
    }
}

export interface IGetSycPlanForViewDto {
    sycPlan: SycPlanDto;
    sycApplicationName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycPlanForViewDto implements IPagedResultDtoOfGetSycPlanForViewDto {
    totalCount!: number;
    items!: GetSycPlanForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycPlanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycPlanForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycPlanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycPlanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycPlanForViewDto {
    totalCount: number;
    items: GetSycPlanForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycPlanDto implements ICreateOrEditSycPlanDto {
    code!: string;
    name!: string | undefined;
    notes!: string | undefined;
    applicationId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.applicationId = _data["applicationId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["applicationId"] = this.applicationId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycPlanDto {
    code: string;
    name: string | undefined;
    notes: string | undefined;
    applicationId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycPlanForEditOutput implements IGetSycPlanForEditOutput {
    sycPlan!: CreateOrEditSycPlanDto;
    sycApplicationName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycPlanForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycPlan = _data["sycPlan"] ? CreateOrEditSycPlanDto.fromJS(_data["sycPlan"]) : <any>undefined;
            this.sycApplicationName = _data["sycApplicationName"];
        }
    }

    static fromJS(data: any): GetSycPlanForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycPlanForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycPlan"] = this.sycPlan ? this.sycPlan.toJSON() : <any>undefined;
        data["sycApplicationName"] = this.sycApplicationName;
        return data;
    }
}

export interface IGetSycPlanForEditOutput {
    sycPlan: CreateOrEditSycPlanDto;
    sycApplicationName: string | undefined;

    [key: string]: any;
}

export class SycPlanSycApplicationLookupTableDto implements ISycPlanSycApplicationLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycPlanSycApplicationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycPlanSycApplicationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycPlanSycApplicationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycPlanSycApplicationLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycPlanServiceDto implements ISycPlanServiceDto {
    unitOfMeasure!: string | undefined;
    unitPrice!: number;
    units!: number;
    billingFrequency!: string | undefined;
    minimumUnits!: number;
    applicationId!: number | undefined;
    planId!: number | undefined;
    serviceId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycPlanServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.unitPrice = _data["unitPrice"];
            this.units = _data["units"];
            this.billingFrequency = _data["billingFrequency"];
            this.minimumUnits = _data["minimumUnits"];
            this.applicationId = _data["applicationId"];
            this.planId = _data["planId"];
            this.serviceId = _data["serviceId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycPlanServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycPlanServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["unitPrice"] = this.unitPrice;
        data["units"] = this.units;
        data["billingFrequency"] = this.billingFrequency;
        data["minimumUnits"] = this.minimumUnits;
        data["applicationId"] = this.applicationId;
        data["planId"] = this.planId;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycPlanServiceDto {
    unitOfMeasure: string | undefined;
    unitPrice: number;
    units: number;
    billingFrequency: string | undefined;
    minimumUnits: number;
    applicationId: number | undefined;
    planId: number | undefined;
    serviceId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycPlanServiceForViewDto implements IGetSycPlanServiceForViewDto {
    sycPlanService!: SycPlanServiceDto;
    sycApplicationName!: string | undefined;
    sycPlanName!: string | undefined;
    sycServiceCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycPlanServiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycPlanService = _data["sycPlanService"] ? SycPlanServiceDto.fromJS(_data["sycPlanService"]) : <any>undefined;
            this.sycApplicationName = _data["sycApplicationName"];
            this.sycPlanName = _data["sycPlanName"];
            this.sycServiceCode = _data["sycServiceCode"];
        }
    }

    static fromJS(data: any): GetSycPlanServiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycPlanServiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycPlanService"] = this.sycPlanService ? this.sycPlanService.toJSON() : <any>undefined;
        data["sycApplicationName"] = this.sycApplicationName;
        data["sycPlanName"] = this.sycPlanName;
        data["sycServiceCode"] = this.sycServiceCode;
        return data;
    }
}

export interface IGetSycPlanServiceForViewDto {
    sycPlanService: SycPlanServiceDto;
    sycApplicationName: string | undefined;
    sycPlanName: string | undefined;
    sycServiceCode: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycPlanServiceForViewDto implements IPagedResultDtoOfGetSycPlanServiceForViewDto {
    totalCount!: number;
    items!: GetSycPlanServiceForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycPlanServiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycPlanServiceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycPlanServiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycPlanServiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycPlanServiceForViewDto {
    totalCount: number;
    items: GetSycPlanServiceForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycPlanServiceDto implements ICreateOrEditSycPlanServiceDto {
    unitOfMeasure!: string | undefined;
    unitPrice!: number;
    units!: number;
    billingFrequency!: string | undefined;
    minimumUnits!: number;
    applicationId!: number | undefined;
    planId!: number | undefined;
    serviceId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycPlanServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.unitPrice = _data["unitPrice"];
            this.units = _data["units"];
            this.billingFrequency = _data["billingFrequency"];
            this.minimumUnits = _data["minimumUnits"];
            this.applicationId = _data["applicationId"];
            this.planId = _data["planId"];
            this.serviceId = _data["serviceId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycPlanServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycPlanServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["unitPrice"] = this.unitPrice;
        data["units"] = this.units;
        data["billingFrequency"] = this.billingFrequency;
        data["minimumUnits"] = this.minimumUnits;
        data["applicationId"] = this.applicationId;
        data["planId"] = this.planId;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycPlanServiceDto {
    unitOfMeasure: string | undefined;
    unitPrice: number;
    units: number;
    billingFrequency: string | undefined;
    minimumUnits: number;
    applicationId: number | undefined;
    planId: number | undefined;
    serviceId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycPlanServiceForEditOutput implements IGetSycPlanServiceForEditOutput {
    sycPlanService!: CreateOrEditSycPlanServiceDto;
    sycApplicationName!: string | undefined;
    sycPlanName!: string | undefined;
    sycServiceCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycPlanServiceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycPlanService = _data["sycPlanService"] ? CreateOrEditSycPlanServiceDto.fromJS(_data["sycPlanService"]) : <any>undefined;
            this.sycApplicationName = _data["sycApplicationName"];
            this.sycPlanName = _data["sycPlanName"];
            this.sycServiceCode = _data["sycServiceCode"];
        }
    }

    static fromJS(data: any): GetSycPlanServiceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycPlanServiceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycPlanService"] = this.sycPlanService ? this.sycPlanService.toJSON() : <any>undefined;
        data["sycApplicationName"] = this.sycApplicationName;
        data["sycPlanName"] = this.sycPlanName;
        data["sycServiceCode"] = this.sycServiceCode;
        return data;
    }
}

export interface IGetSycPlanServiceForEditOutput {
    sycPlanService: CreateOrEditSycPlanServiceDto;
    sycApplicationName: string | undefined;
    sycPlanName: string | undefined;
    sycServiceCode: string | undefined;

    [key: string]: any;
}

export class SycPlanServiceSycApplicationLookupTableDto implements ISycPlanServiceSycApplicationLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycPlanServiceSycApplicationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycPlanServiceSycApplicationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycPlanServiceSycApplicationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycPlanServiceSycApplicationLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycPlanServiceSycPlanLookupTableDto implements ISycPlanServiceSycPlanLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycPlanServiceSycPlanLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycPlanServiceSycPlanLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycPlanServiceSycPlanLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycPlanServiceSycPlanLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycPlanServiceSycServiceLookupTableDto implements ISycPlanServiceSycServiceLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycPlanServiceSycServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycPlanServiceSycServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycPlanServiceSycServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycPlanServiceSycServiceLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SycReportDto implements ISycReportDto {
    name!: string | undefined;
    description!: string | undefined;
    imgUrl!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.imgUrl = _data["imgUrl"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["imgUrl"] = this.imgUrl;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycReportDto {
    name: string | undefined;
    description: string | undefined;
    imgUrl: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycReportForViewDto implements IGetSycReportForViewDto {
    sycReport!: SycReportDto;

    [key: string]: any;

    constructor(data?: IGetSycReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycReport = _data["sycReport"] ? SycReportDto.fromJS(_data["sycReport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycReport"] = this.sycReport ? this.sycReport.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycReportForViewDto {
    sycReport: SycReportDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycReportForViewDto implements IPagedResultDtoOfGetSycReportForViewDto {
    totalCount!: number;
    items!: GetSycReportForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycReportForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycReportForViewDto {
    totalCount: number;
    items: GetSycReportForViewDto[] | undefined;

    [key: string]: any;
}

export class GetSycSegmentIdentifierDefinitionForViewDto implements IGetSycSegmentIdentifierDefinitionForViewDto {
    sycSegmentIdentifierDefinition!: SycSegmentIdentifierDefinitionDto;
    sycIdentifierDefinitionCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycSegmentIdentifierDefinitionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycSegmentIdentifierDefinition = _data["sycSegmentIdentifierDefinition"] ? SycSegmentIdentifierDefinitionDto.fromJS(_data["sycSegmentIdentifierDefinition"]) : <any>undefined;
            this.sycIdentifierDefinitionCode = _data["sycIdentifierDefinitionCode"];
        }
    }

    static fromJS(data: any): GetSycSegmentIdentifierDefinitionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycSegmentIdentifierDefinitionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycSegmentIdentifierDefinition"] = this.sycSegmentIdentifierDefinition ? this.sycSegmentIdentifierDefinition.toJSON() : <any>undefined;
        data["sycIdentifierDefinitionCode"] = this.sycIdentifierDefinitionCode;
        return data;
    }
}

export interface IGetSycSegmentIdentifierDefinitionForViewDto {
    sycSegmentIdentifierDefinition: SycSegmentIdentifierDefinitionDto;
    sycIdentifierDefinitionCode: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto implements IPagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto {
    totalCount!: number;
    items!: GetSycSegmentIdentifierDefinitionForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycSegmentIdentifierDefinitionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycSegmentIdentifierDefinitionForViewDto {
    totalCount: number;
    items: GetSycSegmentIdentifierDefinitionForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycSegmentIdentifierDefinitionDto implements ICreateOrEditSycSegmentIdentifierDefinitionDto {
    code!: string | undefined;
    name!: string | undefined;
    segmentNumber!: number;
    segmentHeader!: string | undefined;
    segmentMask!: string | undefined;
    segmentLength!: number;
    segmentType!: string | undefined;
    isAutoGenerated!: boolean;
    isEditable!: boolean;
    isVisible!: boolean;
    codeStartingValue!: number;
    lookOrFieldName!: string | undefined;
    sycIdentifierDefinitionId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycSegmentIdentifierDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.segmentNumber = _data["segmentNumber"];
            this.segmentHeader = _data["segmentHeader"];
            this.segmentMask = _data["segmentMask"];
            this.segmentLength = _data["segmentLength"];
            this.segmentType = _data["segmentType"];
            this.isAutoGenerated = _data["isAutoGenerated"];
            this.isEditable = _data["isEditable"];
            this.isVisible = _data["isVisible"];
            this.codeStartingValue = _data["codeStartingValue"];
            this.lookOrFieldName = _data["lookOrFieldName"];
            this.sycIdentifierDefinitionId = _data["sycIdentifierDefinitionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycSegmentIdentifierDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycSegmentIdentifierDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["segmentNumber"] = this.segmentNumber;
        data["segmentHeader"] = this.segmentHeader;
        data["segmentMask"] = this.segmentMask;
        data["segmentLength"] = this.segmentLength;
        data["segmentType"] = this.segmentType;
        data["isAutoGenerated"] = this.isAutoGenerated;
        data["isEditable"] = this.isEditable;
        data["isVisible"] = this.isVisible;
        data["codeStartingValue"] = this.codeStartingValue;
        data["lookOrFieldName"] = this.lookOrFieldName;
        data["sycIdentifierDefinitionId"] = this.sycIdentifierDefinitionId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycSegmentIdentifierDefinitionDto {
    code: string | undefined;
    name: string | undefined;
    segmentNumber: number;
    segmentHeader: string | undefined;
    segmentMask: string | undefined;
    segmentLength: number;
    segmentType: string | undefined;
    isAutoGenerated: boolean;
    isEditable: boolean;
    isVisible: boolean;
    codeStartingValue: number;
    lookOrFieldName: string | undefined;
    sycIdentifierDefinitionId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycSegmentIdentifierDefinitionForEditOutput implements IGetSycSegmentIdentifierDefinitionForEditOutput {
    sycSegmentIdentifierDefinition!: CreateOrEditSycSegmentIdentifierDefinitionDto;
    sycIdentifierDefinitionCode!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSycSegmentIdentifierDefinitionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycSegmentIdentifierDefinition = _data["sycSegmentIdentifierDefinition"] ? CreateOrEditSycSegmentIdentifierDefinitionDto.fromJS(_data["sycSegmentIdentifierDefinition"]) : <any>undefined;
            this.sycIdentifierDefinitionCode = _data["sycIdentifierDefinitionCode"];
        }
    }

    static fromJS(data: any): GetSycSegmentIdentifierDefinitionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycSegmentIdentifierDefinitionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycSegmentIdentifierDefinition"] = this.sycSegmentIdentifierDefinition ? this.sycSegmentIdentifierDefinition.toJSON() : <any>undefined;
        data["sycIdentifierDefinitionCode"] = this.sycIdentifierDefinitionCode;
        return data;
    }
}

export interface IGetSycSegmentIdentifierDefinitionForEditOutput {
    sycSegmentIdentifierDefinition: CreateOrEditSycSegmentIdentifierDefinitionDto;
    sycIdentifierDefinitionCode: string | undefined;

    [key: string]: any;
}

export class SycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto implements ISycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto implements IPagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto {
    totalCount!: number;
    items!: SycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto {
    totalCount: number;
    items: SycSegmentIdentifierDefinitionSycIdentifierDefinitionLookupTableDto[] | undefined;

    [key: string]: any;
}

export class SycServiceDto implements ISycServiceDto {
    code!: string | undefined;
    description!: string | undefined;
    unitOfMeasure!: string | undefined;
    unitPrice!: number;
    notes!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISycServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.description = _data["description"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.unitPrice = _data["unitPrice"];
            this.notes = _data["notes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["description"] = this.description;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["unitPrice"] = this.unitPrice;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data;
    }
}

export interface ISycServiceDto {
    code: string | undefined;
    description: string | undefined;
    unitOfMeasure: string | undefined;
    unitPrice: number;
    notes: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetSycServiceForViewDto implements IGetSycServiceForViewDto {
    sycService!: SycServiceDto;

    [key: string]: any;

    constructor(data?: IGetSycServiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycService = _data["sycService"] ? SycServiceDto.fromJS(_data["sycService"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycServiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycServiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycService"] = this.sycService ? this.sycService.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycServiceForViewDto {
    sycService: SycServiceDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycServiceForViewDto implements IPagedResultDtoOfGetSycServiceForViewDto {
    totalCount!: number;
    items!: GetSycServiceForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycServiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycServiceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycServiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycServiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycServiceForViewDto {
    totalCount: number;
    items: GetSycServiceForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycServiceDto implements ICreateOrEditSycServiceDto {
    code!: string;
    description!: string | undefined;
    unitOfMeasure!: string | undefined;
    unitPrice!: number;
    notes!: string | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.description = _data["description"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.unitPrice = _data["unitPrice"];
            this.notes = _data["notes"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSycServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["description"] = this.description;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["unitPrice"] = this.unitPrice;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSycServiceDto {
    code: string;
    description: string | undefined;
    unitOfMeasure: string | undefined;
    unitPrice: number;
    notes: string | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSycServiceForEditOutput implements IGetSycServiceForEditOutput {
    sycService!: CreateOrEditSycServiceDto;

    [key: string]: any;

    constructor(data?: IGetSycServiceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycService = _data["sycService"] ? CreateOrEditSycServiceDto.fromJS(_data["sycService"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycServiceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycServiceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycService"] = this.sycService ? this.sycService.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycServiceForEditOutput {
    sycService: CreateOrEditSycServiceDto;

    [key: string]: any;
}

export class SycTenantInvitatiosDto implements ISycTenantInvitatiosDto {
    id!: number;

    [key: string]: any;

    constructor(data?: ISycTenantInvitatiosDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SycTenantInvitatiosDto {
        data = typeof data === 'object' ? data : {};
        let result = new SycTenantInvitatiosDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ISycTenantInvitatiosDto {
    id: number;

    [key: string]: any;
}

export class GetSycTenantInvitatiosForViewDto implements IGetSycTenantInvitatiosForViewDto {
    sycTenantInvitatios!: SycTenantInvitatiosDto;

    [key: string]: any;

    constructor(data?: IGetSycTenantInvitatiosForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycTenantInvitatios = _data["sycTenantInvitatios"] ? SycTenantInvitatiosDto.fromJS(_data["sycTenantInvitatios"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycTenantInvitatiosForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycTenantInvitatiosForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycTenantInvitatios"] = this.sycTenantInvitatios ? this.sycTenantInvitatios.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycTenantInvitatiosForViewDto {
    sycTenantInvitatios: SycTenantInvitatiosDto;

    [key: string]: any;
}

export class PagedResultDtoOfGetSycTenantInvitatiosForViewDto implements IPagedResultDtoOfGetSycTenantInvitatiosForViewDto {
    totalCount!: number;
    items!: GetSycTenantInvitatiosForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetSycTenantInvitatiosForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSycTenantInvitatiosForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSycTenantInvitatiosForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSycTenantInvitatiosForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSycTenantInvitatiosForViewDto {
    totalCount: number;
    items: GetSycTenantInvitatiosForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSycTenantInvitatiosDto implements ICreateOrEditSycTenantInvitatiosDto {
    id!: number;
    tenantId!: number;
    partnerId!: number;
    createDate!: moment.Moment;

    [key: string]: any;

    constructor(data?: ICreateOrEditSycTenantInvitatiosDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.partnerId = _data["partnerId"];
            this.createDate = _data["createDate"] ? moment(_data["createDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrEditSycTenantInvitatiosDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSycTenantInvitatiosDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["partnerId"] = this.partnerId;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateOrEditSycTenantInvitatiosDto {
    id: number;
    tenantId: number;
    partnerId: number;
    createDate: moment.Moment;

    [key: string]: any;
}

export class GetSycTenantInvitatiosForEditOutput implements IGetSycTenantInvitatiosForEditOutput {
    sycTenantInvitatios!: CreateOrEditSycTenantInvitatiosDto;

    [key: string]: any;

    constructor(data?: IGetSycTenantInvitatiosForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sycTenantInvitatios = _data["sycTenantInvitatios"] ? CreateOrEditSycTenantInvitatiosDto.fromJS(_data["sycTenantInvitatios"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSycTenantInvitatiosForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSycTenantInvitatiosForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sycTenantInvitatios"] = this.sycTenantInvitatios ? this.sycTenantInvitatios.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSycTenantInvitatiosForEditOutput {
    sycTenantInvitatios: CreateOrEditSycTenantInvitatiosDto;

    [key: string]: any;
}

export class SydObjectDto implements ISydObjectDto {
    name!: string | undefined;
    code!: string | undefined;
    objectTypeId!: number;
    parentId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISydObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.objectTypeId = _data["objectTypeId"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SydObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SydObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["objectTypeId"] = this.objectTypeId;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISydObjectDto {
    name: string | undefined;
    code: string | undefined;
    objectTypeId: number;
    parentId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSydObjectForViewDto implements IGetSydObjectForViewDto {
    sydObject!: SydObjectDto;
    sysObjectTypeName!: string | undefined;
    sydObjectName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSydObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sydObject = _data["sydObject"] ? SydObjectDto.fromJS(_data["sydObject"]) : <any>undefined;
            this.sysObjectTypeName = _data["sysObjectTypeName"];
            this.sydObjectName = _data["sydObjectName"];
        }
    }

    static fromJS(data: any): GetSydObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSydObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sydObject"] = this.sydObject ? this.sydObject.toJSON() : <any>undefined;
        data["sysObjectTypeName"] = this.sysObjectTypeName;
        data["sydObjectName"] = this.sydObjectName;
        return data;
    }
}

export interface IGetSydObjectForViewDto {
    sydObject: SydObjectDto;
    sysObjectTypeName: string | undefined;
    sydObjectName: string | undefined;

    [key: string]: any;
}

export class TreeNodeOfGetSydObjectForViewDto implements ITreeNodeOfGetSydObjectForViewDto {
    data!: GetSydObjectForViewDto;
    children!: TreeNodeOfGetSydObjectForViewDto[] | undefined;
    leaf!: boolean;
    expanded!: boolean;
    label!: string | undefined;
    totalChildrenCount!: number | undefined;

    [key: string]: any;

    constructor(data?: ITreeNodeOfGetSydObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? GetSydObjectForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeNodeOfGetSydObjectForViewDto.fromJS(item));
            }
            this.leaf = _data["leaf"];
            this.expanded = _data["expanded"];
            this.label = _data["label"];
            this.totalChildrenCount = _data["totalChildrenCount"];
        }
    }

    static fromJS(data: any): TreeNodeOfGetSydObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeOfGetSydObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["leaf"] = this.leaf;
        data["expanded"] = this.expanded;
        data["label"] = this.label;
        data["totalChildrenCount"] = this.totalChildrenCount;
        return data;
    }
}

export interface ITreeNodeOfGetSydObjectForViewDto {
    data: GetSydObjectForViewDto;
    children: TreeNodeOfGetSydObjectForViewDto[] | undefined;
    leaf: boolean;
    expanded: boolean;
    label: string | undefined;
    totalChildrenCount: number | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto implements IPagedResultDtoOfTreeNodeOfGetSydObjectForViewDto {
    totalCount!: number;
    items!: TreeNodeOfGetSydObjectForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTreeNodeOfGetSydObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TreeNodeOfGetSydObjectForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreeNodeOfGetSydObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTreeNodeOfGetSydObjectForViewDto {
    totalCount: number;
    items: TreeNodeOfGetSydObjectForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSydObjectDto implements ICreateOrEditSydObjectDto {
    name!: string;
    code!: string;
    objectTypeId!: number;
    parentId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSydObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.objectTypeId = _data["objectTypeId"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSydObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSydObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["objectTypeId"] = this.objectTypeId;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSydObjectDto {
    name: string;
    code: string;
    objectTypeId: number;
    parentId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSydObjectForEditOutput implements IGetSydObjectForEditOutput {
    sydObject!: CreateOrEditSydObjectDto;
    sysObjectTypeName!: string | undefined;
    sydObjectName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSydObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sydObject = _data["sydObject"] ? CreateOrEditSydObjectDto.fromJS(_data["sydObject"]) : <any>undefined;
            this.sysObjectTypeName = _data["sysObjectTypeName"];
            this.sydObjectName = _data["sydObjectName"];
        }
    }

    static fromJS(data: any): GetSydObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSydObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sydObject"] = this.sydObject ? this.sydObject.toJSON() : <any>undefined;
        data["sysObjectTypeName"] = this.sysObjectTypeName;
        data["sydObjectName"] = this.sydObjectName;
        return data;
    }
}

export interface IGetSydObjectForEditOutput {
    sydObject: CreateOrEditSydObjectDto;
    sysObjectTypeName: string | undefined;
    sydObjectName: string | undefined;

    [key: string]: any;
}

export class SydObjectSysObjectTypeLookupTableDto implements ISydObjectSysObjectTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISydObjectSysObjectTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SydObjectSysObjectTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SydObjectSysObjectTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISydObjectSysObjectTypeLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class SydObjectSydObjectLookupTableDto implements ISydObjectSydObjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;
    objectTypeId!: number;

    [key: string]: any;

    constructor(data?: ISydObjectSydObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.objectTypeId = _data["objectTypeId"];
        }
    }

    static fromJS(data: any): SydObjectSydObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SydObjectSydObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["objectTypeId"] = this.objectTypeId;
        return data;
    }
}

export interface ISydObjectSydObjectLookupTableDto {
    id: number;
    displayName: string | undefined;
    objectTypeId: number;

    [key: string]: any;
}

export enum SliderEnum {
    AutoSlider = 0,
    CallToAction = 1,
    AdvSlider = 2,
}

export class PageSettingDto implements IPageSettingDto {
    id!: number;
    type!: SliderEnum;
    name!: string | undefined;
    code!: string | undefined;
    title!: string | undefined;
    image!: string | undefined;
    description!: string | undefined;
    order!: number;
    linkPageUrl!: string | undefined;
    externalUrl!: string | undefined;

    [key: string]: any;

    constructor(data?: IPageSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.order = _data["order"];
            this.linkPageUrl = _data["linkPageUrl"];
            this.externalUrl = _data["externalUrl"];
        }
    }

    static fromJS(data: any): PageSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["code"] = this.code;
        data["title"] = this.title;
        data["image"] = this.image;
        data["description"] = this.description;
        data["order"] = this.order;
        data["linkPageUrl"] = this.linkPageUrl;
        data["externalUrl"] = this.externalUrl;
        return data;
    }
}

export interface IPageSettingDto {
    id: number;
    type: SliderEnum;
    name: string | undefined;
    code: string | undefined;
    title: string | undefined;
    image: string | undefined;
    description: string | undefined;
    order: number;
    linkPageUrl: string | undefined;
    externalUrl: string | undefined;

    [key: string]: any;
}

export class SysObjectTypeDto implements ISysObjectTypeDto {
    name!: string | undefined;
    code!: string | undefined;
    parentId!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ISysObjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SysObjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysObjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISysObjectTypeDto {
    name: string | undefined;
    code: string | undefined;
    parentId: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetSysObjectTypeForViewDto implements IGetSysObjectTypeForViewDto {
    sysObjectType!: SysObjectTypeDto;
    sysObjectTypeName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSysObjectTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sysObjectType = _data["sysObjectType"] ? SysObjectTypeDto.fromJS(_data["sysObjectType"]) : <any>undefined;
            this.sysObjectTypeName = _data["sysObjectTypeName"];
        }
    }

    static fromJS(data: any): GetSysObjectTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSysObjectTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sysObjectType"] = this.sysObjectType ? this.sysObjectType.toJSON() : <any>undefined;
        data["sysObjectTypeName"] = this.sysObjectTypeName;
        return data;
    }
}

export interface IGetSysObjectTypeForViewDto {
    sysObjectType: SysObjectTypeDto;
    sysObjectTypeName: string | undefined;

    [key: string]: any;
}

export class TreeNodeOfGetSysObjectTypeForViewDto implements ITreeNodeOfGetSysObjectTypeForViewDto {
    data!: GetSysObjectTypeForViewDto;
    children!: TreeNodeOfGetSysObjectTypeForViewDto[] | undefined;
    leaf!: boolean;
    expanded!: boolean;
    label!: string | undefined;
    totalChildrenCount!: number | undefined;

    [key: string]: any;

    constructor(data?: ITreeNodeOfGetSysObjectTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? GetSysObjectTypeForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeNodeOfGetSysObjectTypeForViewDto.fromJS(item));
            }
            this.leaf = _data["leaf"];
            this.expanded = _data["expanded"];
            this.label = _data["label"];
            this.totalChildrenCount = _data["totalChildrenCount"];
        }
    }

    static fromJS(data: any): TreeNodeOfGetSysObjectTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeOfGetSysObjectTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["leaf"] = this.leaf;
        data["expanded"] = this.expanded;
        data["label"] = this.label;
        data["totalChildrenCount"] = this.totalChildrenCount;
        return data;
    }
}

export interface ITreeNodeOfGetSysObjectTypeForViewDto {
    data: GetSysObjectTypeForViewDto;
    children: TreeNodeOfGetSysObjectTypeForViewDto[] | undefined;
    leaf: boolean;
    expanded: boolean;
    label: string | undefined;
    totalChildrenCount: number | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto implements IPagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto {
    totalCount!: number;
    items!: TreeNodeOfGetSysObjectTypeForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TreeNodeOfGetSysObjectTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTreeNodeOfGetSysObjectTypeForViewDto {
    totalCount: number;
    items: TreeNodeOfGetSysObjectTypeForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditSysObjectTypeDto implements ICreateOrEditSysObjectTypeDto {
    name!: string;
    code!: string | undefined;
    parentId!: number | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditSysObjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSysObjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSysObjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSysObjectTypeDto {
    name: string;
    code: string | undefined;
    parentId: number | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetSysObjectTypeForEditOutput implements IGetSysObjectTypeForEditOutput {
    sysObjectType!: CreateOrEditSysObjectTypeDto;
    sysObjectTypeName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetSysObjectTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sysObjectType = _data["sysObjectType"] ? CreateOrEditSysObjectTypeDto.fromJS(_data["sysObjectType"]) : <any>undefined;
            this.sysObjectTypeName = _data["sysObjectTypeName"];
        }
    }

    static fromJS(data: any): GetSysObjectTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSysObjectTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sysObjectType"] = this.sysObjectType ? this.sysObjectType.toJSON() : <any>undefined;
        data["sysObjectTypeName"] = this.sysObjectTypeName;
        return data;
    }
}

export interface IGetSysObjectTypeForEditOutput {
    sysObjectType: CreateOrEditSysObjectTypeDto;
    sysObjectTypeName: string | undefined;

    [key: string]: any;
}

export class SysObjectTypeSysObjectTypeLookupTableDto implements ISysObjectTypeSysObjectTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ISysObjectTypeSysObjectTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): SysObjectTypeSysObjectTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysObjectTypeSysObjectTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISysObjectTypeSysObjectTypeLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean;
    creationTime!: moment.Moment;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? moment(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = _data["editionId"];
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;

    [key: string]: any;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean;
    inviterTenantId!: number | undefined;
    firstName!: string;
    lastName!: string;

    [key: string]: any;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.connectionString = _data["connectionString"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? moment(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.inviterTenantId = _data["inviterTenantId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["inviterTenantId"] = this.inviterTenantId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    inviterTenantId: number | undefined;
    firstName: string;
    lastName: string;

    [key: string]: any;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    [key: string]: any;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? moment(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    id: number;

    [key: string]: any;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    [key: string]: any;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    [key: string]: any;

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];

    [key: string]: any;
}

export class TenantInfoDto implements ITenantInfoDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;

    [key: string]: any;

    constructor(data?: ITenantInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): TenantInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ITenantInfoDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;

    [key: string]: any;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;

    [key: string]: any;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.earnings = _data["earnings"];
            this.cases = _data["cases"];
            this.closed = _data["closed"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;

    [key: string]: any;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    [key: string]: any;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of _data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;

    [key: string]: any;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    [key: string]: any;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.period = _data["period"];
            this.sales = _data["sales"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;

    [key: string]: any;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    [key: string]: any;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;

    [key: string]: any;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;

    [key: string]: any;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data;
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;

    [key: string]: any;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares!: number[] | undefined;

    [key: string]: any;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;

    [key: string]: any;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales!: number[] | undefined;

    [key: string]: any;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data;
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;

    [key: string]: any;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    salesSummary!: SalesSummaryData[] | undefined;

    [key: string]: any;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;

    [key: string]: any;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    [key: string]: any;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.countryName = _data["countryName"];
            this.sales = _data["sales"];
            if (Array.isArray(_data["change"])) {
                this.change = [] as any;
                for (let item of _data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = _data["averagePrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;

    [key: string]: any;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    [key: string]: any;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;

    [key: string]: any;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    [key: string]: any;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;

    [key: string]: any;
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType;
    editionId!: number | undefined;
    inviterTenantId!: number | undefined;
    firstName!: string;
    lastName!: string;
    accountType!: string | undefined;
    accountTypeId!: string | undefined;

    [key: string]: any;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.captchaResponse = _data["captchaResponse"];
            this.subscriptionStartType = _data["subscriptionStartType"];
            this.editionId = _data["editionId"];
            this.inviterTenantId = _data["inviterTenantId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.accountType = _data["accountType"];
            this.accountTypeId = _data["accountTypeId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        data["inviterTenantId"] = this.inviterTenantId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["accountType"] = this.accountType;
        data["accountTypeId"] = this.accountTypeId;
        return data;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
    inviterTenantId: number | undefined;
    firstName: string;
    lastName: string;
    accountType: string | undefined;
    accountTypeId: string | undefined;

    [key: string]: any;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean;
    isActive!: boolean;
    isEmailConfirmationRequired!: boolean;
    firstName!: string | undefined;
    lastName!: string | undefined;
    accountType!: string | undefined;
    accountTypeId!: string | undefined;

    [key: string]: any;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isTenantActive = _data["isTenantActive"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.accountType = _data["accountType"];
            this.accountTypeId = _data["accountTypeId"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["accountType"] = this.accountType;
        data["accountTypeId"] = this.accountTypeId;
        return data;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
    firstName: string | undefined;
    lastName: string | undefined;
    accountType: string | undefined;
    accountTypeId: string | undefined;

    [key: string]: any;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;

    [key: string]: any;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;

    [key: string]: any;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType;
    textHtmlColor!: string | undefined;

    [key: string]: any;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            this.textHtmlColor = _data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;

    [key: string]: any;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto;
    featureValues!: NameValueDto[] | undefined;

    [key: string]: any;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;

    [key: string]: any;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    [key: string]: any;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of _data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of _data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;

    [key: string]: any;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    useCaptchaOnLogin!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    [key: string]: any;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = _data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;

    [key: string]: any;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    [key: string]: any;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.useHostDefaultEmailSettings = _data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;

    [key: string]: any;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    [key: string]: any;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isModuleEnabled = _data["isModuleEnabled"];
            this.isEnabled = _data["isEnabled"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;

    [key: string]: any;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    [key: string]: any;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;

    [key: string]: any;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    [key: string]: any;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;

    [key: string]: any;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto;
    ldap!: LdapSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto;

    [key: string]: any;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : <any>undefined;
            this.userManagement = _data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = _data["email"] ? TenantEmailSettingsEditDto.fromJS(_data["email"]) : <any>undefined;
            this.ldap = _data["ldap"] ? LdapSettingsEditDto.fromJS(_data["ldap"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? TenantBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;

    [key: string]: any;
}

export class TicketNoteDto implements ITicketNoteDto {
    title!: string | undefined;
    description!: string | undefined;
    ticketId!: number | undefined;
    createDateTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    queueID!: number | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ITicketNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.ticketId = _data["ticketId"];
            this.createDateTime = _data["createDateTime"] ? moment(_data["createDateTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.queueID = _data["queueID"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TicketNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["ticketId"] = this.ticketId;
        data["createDateTime"] = this.createDateTime ? this.createDateTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["queueID"] = this.queueID;
        data["id"] = this.id;
        return data;
    }
}

export interface ITicketNoteDto {
    title: string | undefined;
    description: string | undefined;
    ticketId: number | undefined;
    createDateTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    queueID: number | undefined;
    id: number;

    [key: string]: any;
}

export class GetTicketNoteForViewDto implements IGetTicketNoteForViewDto {
    ticketNote!: TicketNoteDto;
    ticketTicketNumber!: string | undefined;
    createUserName!: string | undefined;
    attachments!: AttachmentInfoDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetTicketNoteForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ticketNote = _data["ticketNote"] ? TicketNoteDto.fromJS(_data["ticketNote"]) : <any>undefined;
            this.ticketTicketNumber = _data["ticketTicketNumber"];
            this.createUserName = _data["createUserName"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketNoteForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketNoteForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ticketNote"] = this.ticketNote ? this.ticketNote.toJSON() : <any>undefined;
        data["ticketTicketNumber"] = this.ticketTicketNumber;
        data["createUserName"] = this.createUserName;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTicketNoteForViewDto {
    ticketNote: TicketNoteDto;
    ticketTicketNumber: string | undefined;
    createUserName: string | undefined;
    attachments: AttachmentInfoDto[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetTicketNoteForViewDto implements IPagedResultDtoOfGetTicketNoteForViewDto {
    totalCount!: number;
    items!: GetTicketNoteForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetTicketNoteForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTicketNoteForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTicketNoteForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTicketNoteForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTicketNoteForViewDto {
    totalCount: number;
    items: GetTicketNoteForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditTicketNoteDto implements ICreateOrEditTicketNoteDto {
    title!: string | undefined;
    description!: string | undefined;
    ticketId!: number | undefined;
    creatorUserId!: number | undefined;
    queueID!: number | undefined;
    entityAttachments!: AttachmentInfoDto[] | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditTicketNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.ticketId = _data["ticketId"];
            this.creatorUserId = _data["creatorUserId"];
            this.queueID = _data["queueID"];
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AttachmentInfoDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTicketNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTicketNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["ticketId"] = this.ticketId;
        data["creatorUserId"] = this.creatorUserId;
        data["queueID"] = this.queueID;
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTicketNoteDto {
    title: string | undefined;
    description: string | undefined;
    ticketId: number | undefined;
    creatorUserId: number | undefined;
    queueID: number | undefined;
    entityAttachments: AttachmentInfoDto[] | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetTicketNoteForEditOutput implements IGetTicketNoteForEditOutput {
    ticketNote!: CreateOrEditTicketNoteDto;
    ticketTicketNumber!: string | undefined;
    createUserName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetTicketNoteForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ticketNote = _data["ticketNote"] ? CreateOrEditTicketNoteDto.fromJS(_data["ticketNote"]) : <any>undefined;
            this.ticketTicketNumber = _data["ticketTicketNumber"];
            this.createUserName = _data["createUserName"];
        }
    }

    static fromJS(data: any): GetTicketNoteForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketNoteForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ticketNote"] = this.ticketNote ? this.ticketNote.toJSON() : <any>undefined;
        data["ticketTicketNumber"] = this.ticketTicketNumber;
        data["createUserName"] = this.createUserName;
        return data;
    }
}

export interface IGetTicketNoteForEditOutput {
    ticketNote: CreateOrEditTicketNoteDto;
    ticketTicketNumber: string | undefined;
    createUserName: string | undefined;

    [key: string]: any;
}

export class TicketNoteTicketLookupTableDto implements ITicketNoteTicketLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    [key: string]: any;

    constructor(data?: ITicketNoteTicketLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TicketNoteTicketLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketNoteTicketLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITicketNoteTicketLookupTableDto {
    id: number;
    displayName: string | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfTicketNoteTicketLookupTableDto implements IPagedResultDtoOfTicketNoteTicketLookupTableDto {
    totalCount!: number;
    items!: TicketNoteTicketLookupTableDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfTicketNoteTicketLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TicketNoteTicketLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketNoteTicketLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketNoteTicketLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTicketNoteTicketLookupTableDto {
    totalCount: number;
    items: TicketNoteTicketLookupTableDto[] | undefined;

    [key: string]: any;
}

export class TicketDto implements ITicketDto {
    title!: string | undefined;
    ticketNumber!: string | undefined;
    description!: string | undefined;
    queueId!: number | undefined;
    queueName!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.ticketNumber = _data["ticketNumber"];
            this.description = _data["description"];
            this.queueId = _data["queueId"];
            this.queueName = _data["queueName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["ticketNumber"] = this.ticketNumber;
        data["description"] = this.description;
        data["queueId"] = this.queueId;
        data["queueName"] = this.queueName;
        data["id"] = this.id;
        return data;
    }
}

export interface ITicketDto {
    title: string | undefined;
    ticketNumber: string | undefined;
    description: string | undefined;
    queueId: number | undefined;
    queueName: string | undefined;
    id: number;

    [key: string]: any;
}

export class GetTicketForViewDto implements IGetTicketForViewDto {
    ticket!: TicketDto;
    attachments!: AttachmentInfoDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetTicketForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ticket = _data["ticket"] ? TicketDto.fromJS(_data["ticket"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTicketForViewDto {
    ticket: TicketDto;
    attachments: AttachmentInfoDto[] | undefined;

    [key: string]: any;
}

export class PagedResultDtoOfGetTicketForViewDto implements IPagedResultDtoOfGetTicketForViewDto {
    totalCount!: number;
    items!: GetTicketForViewDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetTicketForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTicketForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTicketForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTicketForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTicketForViewDto {
    totalCount: number;
    items: GetTicketForViewDto[] | undefined;

    [key: string]: any;
}

export class CreateOrEditTicketDto implements ICreateOrEditTicketDto {
    title!: string | undefined;
    ticketNumber!: string | undefined;
    description!: string | undefined;
    queueId!: number | undefined;
    queueName!: string | undefined;
    entityAttachments!: AttachmentInfoDto[] | undefined;
    id!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrEditTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.ticketNumber = _data["ticketNumber"];
            this.description = _data["description"];
            this.queueId = _data["queueId"];
            this.queueName = _data["queueName"];
            if (Array.isArray(_data["entityAttachments"])) {
                this.entityAttachments = [] as any;
                for (let item of _data["entityAttachments"])
                    this.entityAttachments!.push(AttachmentInfoDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["ticketNumber"] = this.ticketNumber;
        data["description"] = this.description;
        data["queueId"] = this.queueId;
        data["queueName"] = this.queueName;
        if (Array.isArray(this.entityAttachments)) {
            data["entityAttachments"] = [];
            for (let item of this.entityAttachments)
                data["entityAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTicketDto {
    title: string | undefined;
    ticketNumber: string | undefined;
    description: string | undefined;
    queueId: number | undefined;
    queueName: string | undefined;
    entityAttachments: AttachmentInfoDto[] | undefined;
    id: number | undefined;

    [key: string]: any;
}

export class GetTicketForEditOutput implements IGetTicketForEditOutput {
    ticket!: CreateOrEditTicketDto;
    attachments!: AttachmentInfoDto[] | undefined;

    [key: string]: any;

    constructor(data?: IGetTicketForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ticket = _data["ticket"] ? CreateOrEditTicketDto.fromJS(_data["ticket"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTicketForEditOutput {
    ticket: CreateOrEditTicketDto;
    attachments: AttachmentInfoDto[] | undefined;

    [key: string]: any;
}

export class DisplayNameValueDto implements IDisplayNameValueDto {
    label!: string | undefined;
    value!: string | undefined;

    [key: string]: any;

    constructor(data?: IDisplayNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DisplayNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface IDisplayNameValueDto {
    label: string | undefined;
    value: string | undefined;

    [key: string]: any;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;

    [key: string]: any;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    [key: string]: any;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.twoFactorVerificationCode = _data["twoFactorVerificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.singleSignIn = _data["singleSignIn"];
            this.returnUrl = _data["returnUrl"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;

    [key: string]: any;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    [key: string]: any;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;

    [key: string]: any;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    [key: string]: any;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    [key: string]: any;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    [key: string]: any;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;

    [key: string]: any;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    [key: string]: any;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    [key: string]: any;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    [key: string]: any;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    [key: string]: any;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    [key: string]: any;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        (<any>this.additionalParams)![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    (<any>data["additionalParams"])[key] = (<any>this.additionalParams)[key];
            }
        }
        return data;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    [key: string]: any;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;

    [key: string]: any;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    [key: string]: any;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;

    [key: string]: any;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    [key: string]: any;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;

    [key: string]: any;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    creationTime!: moment.Moment;
    memberId!: number;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.profilePictureId = _data["profilePictureId"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.memberId = _data["memberId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["memberId"] = this.memberId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    memberId: number;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;

    [key: string]: any;
}

export class UserDto implements IUserDto {
    name!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;

    [key: string]: any;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        return data;
    }
}

export interface IUserDto {
    name: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;

    [key: string]: any;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;

    [key: string]: any;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;

    [key: string]: any;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;
    inheritedFromOrganizationUnit!: boolean;

    [key: string]: any;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
            this.inheritedFromOrganizationUnit = _data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data;
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;

    [key: string]: any;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;
    tenancyName!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.profilePictureId = _data["profilePictureId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of _data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of _data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
    tenancyName: string | undefined;

    [key: string]: any;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    [key: string]: any;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    [key: string]: any;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    [key: string]: any;

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];

    [key: string]: any;
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    organizationUnits!: number[] | undefined;
    code!: string | undefined;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : new UserEditDto();
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.setRandomPassword = _data["setRandomPassword"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        data["code"] = this.code;
        return data;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
    code: string | undefined;

    [key: string]: any;
}

export class UserDelegationDto implements IUserDelegationDto {
    username!: string | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    id!: number;

    [key: string]: any;

    constructor(data?: IUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.username = _data["username"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["username"] = this.username;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDelegationDto {
    username: string | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
    totalCount!: number;
    items!: UserDelegationDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDelegationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserDelegationDto {
    totalCount: number;
    items: UserDelegationDto[] | undefined;

    [key: string]: any;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
    targetUserId!: number;
    startTime!: moment.Moment;
    endTime!: moment.Moment;

    [key: string]: any;

    constructor(data?: ICreateUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.targetUserId = _data["targetUserId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["targetUserId"] = this.targetUserId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateUserDelegationDto {
    targetUserId: number;
    startTime: moment.Moment;
    endTime: moment.Moment;

    [key: string]: any;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;

    [key: string]: any;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    [key: string]: any;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.username = _data["username"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;

    [key: string]: any;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;

    [key: string]: any;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;

    [key: string]: any;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    [key: string]: any;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;

    [key: string]: any;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment;

    [key: string]: any;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmail = _data["userNameOrEmail"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;

    [key: string]: any;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;

    [key: string]: any;
}

export class WebhookEvent implements IWebhookEvent {
    webhookName!: string;
    data!: string | undefined;
    creationTime!: moment.Moment;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: moment.Moment | undefined;
    id!: string;

    [key: string]: any;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookEvent {
    webhookName: string;
    data: string | undefined;
    creationTime: moment.Moment;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: moment.Moment | undefined;
    id: string;

    [key: string]: any;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: moment.Moment;

    [key: string]: any;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: moment.Moment;

    [key: string]: any;
}

export class PagedResultDtoOfGetAllSendAttemptsOutput implements IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount!: number;
    items!: GetAllSendAttemptsOutput[] | undefined;

    [key: string]: any;

    constructor(data?: IPagedResultDtoOfGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount: number;
    items: GetAllSendAttemptsOutput[] | undefined;

    [key: string]: any;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: moment.Moment;
    lastModificationTime!: moment.Moment | undefined;

    [key: string]: any;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment | undefined;

    [key: string]: any;
}

export class ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput implements IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    [key: string]: any;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    id!: string;

    [key: string]: any;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllSubscriptionsOutput {
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    id: string;

    [key: string]: any;
}

export class ListResultDtoOfGetAllSubscriptionsOutput implements IListResultDtoOfGetAllSubscriptionsOutput {
    items!: GetAllSubscriptionsOutput[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSubscriptionsOutput {
    items: GetAllSubscriptionsOutput[] | undefined;

    [key: string]: any;
}

export class WebhookSubscription implements IWebhookSubscription {
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;
    id!: string;

    [key: string]: any;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookSubscription {
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
    id: string;

    [key: string]: any;
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    [key: string]: any;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;

    [key: string]: any;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    [key: string]: any;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    [key: string]: any;
}

export class ListResultDtoOfGetAllAvailableWebhooksOutput implements IListResultDtoOfGetAllAvailableWebhooksOutput {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    [key: string]: any;

    constructor(data?: IListResultDtoOfGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllAvailableWebhooksOutput {
    items: GetAllAvailableWebhooksOutput[] | undefined;

    [key: string]: any;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    [key: string]: any;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;

    [key: string]: any;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string; };
    stripe!: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in _data["Paypal"]) {
                    if (_data["Paypal"].hasOwnProperty(key))
                        (<any>this.paypal)![key] = _data["Paypal"][key];
                }
            }
            if (_data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in _data["Stripe"]) {
                    if (_data["Stripe"].hasOwnProperty(key))
                        (<any>this.stripe)![key] = _data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    (<any>data["Paypal"])[key] = (<any>this.paypal)[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    (<any>data["Stripe"])[key] = (<any>this.stripe)[key];
            }
        }
        return data;
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string; };
    stripe: { [key: string]: string; };

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}